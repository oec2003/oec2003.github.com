<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冯威的博客</title>
  
  <subtitle>公众号：不止dotNET | 临渊羡鱼不如退而结网</subtitle>
  <link href="http://fwhyy.com/atom.xml" rel="self"/>
  
  <link href="http://fwhyy.com/"/>
  <updated>2022-11-08T08:48:08.019Z</updated>
  <id>http://fwhyy.com/</id>
  
  <author>
    <name>oec2003</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于信息收集和加工的思考</title>
    <link href="http://fwhyy.com/2022/11/thoughts-on-information-collection-and-processing/"/>
    <id>http://fwhyy.com/2022/11/thoughts-on-information-collection-and-processing/</id>
    <published>2022-11-07T00:35:35.000Z</published>
    <updated>2022-11-08T08:48:08.019Z</updated>
    
    <content type="html"><![CDATA[<p>随着互联网的发展，获取信息的手段越来越多，我们对手机的依赖程度超乎想象，每天忙碌着，大脑接收着丰富的信息，感觉每天都学习到了很多的知识。</p><p>但我们对学习经常会有些误区：</p><p>1、书买了摆在书架上，看看书架上摆的书，好像就看了书似的；</p><p>2、把看过的内容当做已经学会了；</p><p>3、发现好的内容随手就收藏了，收藏了就感觉自己掌握了。</p><p>信息的获取并不代表这知识的掌握，从获取到掌握大概有这么些步骤：探索 ➔ 收集 ➔ 思考 ➔ 创作 ➔ 分享 ➔ 讨论。</p><span id="more"></span><p>这个步骤和 DIKW 模型比较吻合，DIKW 模型是一个可以很好的帮助我们理解数据（Data）、信息（Information）、知识（Knowledge）和智慧（Wisdom）之间的关系的模型，可以参考下面这个图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202211081647596.png"></p><p>简单说就是从输入到输出，在这个过程中产生的价值就会留存在我们大脑中，让我们的认知得到提升，认知不断提升，人就变得智慧了，我大致是这么理解的。</p><p>这些步骤如果纯手动，效率比较低，所以需要一些工具的辅助，目前，我也只是零散地在使用一些工具，还没有形成完整的一套工作流，比如：</p><p><strong>flomo</strong></p><ul><li>使用 flomo 进行灵感的收集；</li><li>给 flomo 微信号发送微信语音可以转文字到 flomo ；</li><li>微信读书和得到电子书的划线和评论可以通过 flomo 的 API 进行同步；</li><li>flomo 的回顾功能可以让记录的内容不会落灰。</li></ul><p><strong>logseq</strong></p><ul><li>logseq 目前也在重度使用，没有输入的压力，打开就是日志界面，只管输入就行，不用考虑文件夹，不用思考文件要放到哪里；</li><li>强大的 query 功能；</li><li>标签和双中括号创建页面并建立了双向链接，让随时可以找到想要的内容；</li><li>配合 agenda 插件，就有了一个好用的日历系统；</li><li>pdf 文件的阅读器，对内容随时标注。</li></ul><p><strong>Obsidian</strong></p><ul><li>最终输出时使用 Obsidian ；</li><li>输出内容时，从 flomo 和 logseq 找到相关内容，提取出来放到 Obsidian 中，经过整理最终成文；</li><li>使用 git 插件使用 github 作为备份。</li></ul><p>对于工具的使用，有两种观点：</p><p>1、all-in-one ：用一个软件实现所有的功能，充分挖掘每一个细节，但一个产品在易用性和功能完备性上做到两全是非常困难的；</p><p>2、组合使用：使用多个软件搭建出一个体系，每个软件使用其最擅长的部分。</p><p>我更喜欢第二种方式，因为目前我还没发现大而全又特别好用的产品，如果 all-in-one ，就必然会牺牲掉某些功能的体验，会采用一些变通的方式达到目的。</p><p>使用组合的方式，就需要找一堆适合自己的软件，然后形成流程闭环。不找不知道，一找吓一跳：</p><p>inoreader、rsshub、flomo、Obsidian、logseq、readwise、readwise reader 、IFTTT、instapaper、devonthink3、heptabase、cubox、icubox、hazel、Matter、简悦，收趣、notion、我来、Pinbox、feed43、Hypothesis、Roam Search、Typora、Pocket、Feedly、greasyfork 等等。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202211081647915.png"></p><p>上面有笔记类的、rss 订阅类的、剪藏类的，而且很多工具功能上有很多重叠，比如：flomo 可以回顾、logseq 也可以回顾、readwise 也行。虽说差生工具多，但可千万不要成为一个工具党。具体怎样来使用，我还在摸索之中，但遵循一个原则，使用流程不要太复杂，互相之间的配合最好能自动化。</p><p>太复杂，就会带来额外的使用成本，慢慢地就会放弃使用，就像微信的收藏，需要打开微信 ➔ 我 ➔ 收藏，对我来说还是太麻烦，所以使用频率很低。反之，我家里的很多健身工具，唯独安装在两个卧室墙壁之间的单杠使用频率最高，就是因为方便。</p><p>工具在发挥自己的优势的情况下，能少用就少用，这需要根据自己的实际情况，找到一个合适的平衡点，对我来说，可以满足下面这些诉求就可以：</p><p>1、除了微信读书、得到电子书之外，信息的输入还有电子书、公众号、小宇宙等，遇到有感兴趣的内容需要快速收集；</p><p>2、在即刻、豆瓣、推上关注了一些大佬，想了解动态，每个平台去刷一遍太费时间；</p><p>3、还有一些中英文的技术网站、newsletter、资讯需要订阅，这些内容有些需要进一步深度阅读；</p><p>4、平时在浏览知乎、豆瓣后者使用搜索引擎的时候，发现有价值的内容需要能快速记录下来；</p><p>5、收集的信息需要进行二次处理，用自己的语言进行整理，建立联系，也就是卡片笔记法中的知识卡片，这也是我目前缺少的一个步骤；</p><p>6、输出的时候，提取相关的知识卡片进行组织整理，相比现在的使用收集的信息进行整理，效率要高得多。</p><p>总结下就是：信息收集 ➔ 信息加工 ➔ 输出分享</p><ul><li>信息收集：来源有很多，有网页或内容片段的剪藏、有 rss 的订阅、有播客、有电子书纸质书等，可能会使用不同的工具，但最后能自动汇聚到一个地方；</li><li>信息加工：我认为这是非常重要的一个环节，是思考复盘的过程，最好是回顾和二次处理能在一个工具里；</li><li>输出分享：如果上面两个步骤做的比较好，输出就很轻松和容易了。</li></ul><p>想象着，这套工作流如果打通了，效率是不是能提升不少呢？</p><p>有点期待。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着互联网的发展，获取信息的手段越来越多，我们对手机的依赖程度超乎想象，每天忙碌着，大脑接收着丰富的信息，感觉每天都学习到了很多的知识。&lt;/p&gt;
&lt;p&gt;但我们对学习经常会有些误区：&lt;/p&gt;
&lt;p&gt;1、书买了摆在书架上，看看书架上摆的书，好像就看了书似的；&lt;/p&gt;
&lt;p&gt;2、把看过的内容当做已经学会了；&lt;/p&gt;
&lt;p&gt;3、发现好的内容随手就收藏了，收藏了就感觉自己掌握了。&lt;/p&gt;
&lt;p&gt;信息的获取并不代表这知识的掌握，从获取到掌握大概有这么些步骤：探索 ➔ 收集 ➔ 思考 ➔ 创作 ➔ 分享 ➔ 讨论。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="flomo" scheme="http://fwhyy.com/tags/flomo/"/>
    
    <category term="logseq" scheme="http://fwhyy.com/tags/logseq/"/>
    
    <category term="DIKW" scheme="http://fwhyy.com/tags/dikw/"/>
    
    <category term="信息收集" scheme="http://fwhyy.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    <category term="Obsidian" scheme="http://fwhyy.com/tags/obsidian/"/>
    
  </entry>
  
  <entry>
    <title>为使用 Arc 浏览器，升级了 macOS Ventura</title>
    <link href="http://fwhyy.com/2022/10/to-use-arc-browser-macos-ventura-has-been-upgraded/"/>
    <id>http://fwhyy.com/2022/10/to-use-arc-browser-macos-ventura-has-been-upgraded/</id>
    <published>2022-10-31T00:35:35.000Z</published>
    <updated>2022-11-08T08:48:10.463Z</updated>
    
    <content type="html"><![CDATA[<p>在系统的版本上，我算得上是一个保守派，买电脑时系统的版本是 10.15.7 ，到现在一直没有升级过。</p><p>最近在即刻上看到很多人推荐 Arc 浏览器，Arc 现在还没有正式开放，需要邀请，经过一番周折，在安装时发现最低系统要求是 macOS 11 以上，于是便决定升级系统。</p><p>本文就说说 Ventura 的升级和 Arc 浏览器的体验。</p><span id="more"></span><p>晚上到家后就开始升级系统，12 G 的安装包下载了 2 个多小时，但是升级的时候最后卡在了 1% 的进度上，一直折腾到 12 点多，中间手动重启了电脑好几次，还是会卡住。睡觉前，没有关电脑，希望晚上能发生点奇迹。早上 5 点起床，果然奇迹没有发生，屏幕上的 1% 纹丝不动。</p><p>边做好送修的准备，边查资料，最后在苹果官网上找到一篇文章给解决，真是非常的幸运。文章链接如下：</p><p><a href="https://support.apple.com/zh-cn/HT210898">https://support.apple.com/zh-cn/HT210898</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302038462.png"></p><p>在 Ventura 系统中最重要的更新就是「台前调度」，在系统右上角的控制中心中开启台前调度，开启后屏幕的左边会出现 APP 切换的卡片，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302039289.png"></p><p>这个功能初玩感觉很新鲜，但发现这跟三指上划的作用相同，仅仅少了一次滑动的操作而已，而且 APP 如果是全屏显示，还需要将鼠标划入左侧才能唤初切换的卡片，感觉和三指上划也差不多。</p><p>除此之外，还发现了几处局限性：</p><p>1、我电脑是 16 寸的 Mac Pro ，左侧的切换卡片最多只有 5 个，当打开的 APP 超过 5 个时切换就比较麻烦了，要是加个上下能滑动就好了；</p><p>2、在启用了「台前调度」模式下，点击左侧卡片中的 APP ，屏幕就会被这个 APP 所占据，无法做到同时让 Finder 和 Obsidian 同时出现在屏幕上，从 Finder 中拖动图片到 Obsidian 中。</p><p>所以，对我来说，要需要做不少的优化和改进，才能达到可用的程度。</p><p>Ventura 系统只是玩了下「台前调度」，就开始安装 Arc 浏览器了，安装后需要使用邮箱进行注册，创建账号时提示 Unknown server error ：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302052484.jpg"></p><p>经过一番折腾（不同的上网方式），终于是注册成功了，初次看见 Arc ，最大的感觉就是颜值很高，交互体验也特别好。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302056707.jpg"></p><p>好了，现在来看看 Arc 都有什么特别的功能。</p><p>1、使用逻辑</p><p>传统的浏览器都是提供收藏夹，从收藏夹中点击多个页面就以添加 Tab 的方式打开，打开的页面很多的时候就成灾难了，我经常页面多到连标题都看不见了。</p><p>Arc 打破了这种传统思维：</p><ul><li>提供工作空间（Space）的概念，我们可以根据自己的使用场景添加不同的 Space ，比如我分为：working、reading、writing 等；</li><li>每个 Space 中可以添加很多的 Tab 来展示网页，这些 Tab 分为固定的和临时的，固定的 Tab 关闭浏览器后再打开依然会显示，也可以添加文件夹来组织 Tab ；</li><li>临时 Tab 会在闲置 12 小时后自动关闭；</li><li>常用的站点可以固定在顶部，不受 Space 切换的影响。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202211081644251.png"></p><p>2、网页全屏展示</p><p>因为 Arc 的 Tab 和内容区域是左右布局，内容区域就非常干净，没有传统浏览器上面的地址栏、页签栏和标签栏。</p><p>把左边的 Sidebar 隐藏后，右边感觉上就像是一个独立 APP 了，特别适合一些单页应用，比如：inoreader、readwise reader 等，看下面我的 inoreader ，是不是很像一个独立的 APP 。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202211081644181.png"></p><p>3、酷炫的颜色设置</p><p>每个 Space 都可以设置不同的主题色，在底部的 Space 上点击右键，点击 Theme… </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302052953.png"></p><ul><li>可以添加多个颜色设置渐变；</li><li>可以设置暗色主题、亮色主题或随系统；</li><li>可以设置透明度；</li><li>可以设置颗粒度。</li></ul><p>一个颜色的设置做的这么好玩，我认为在一些 ToC 的产品中是可以借鉴的。</p><p>4、分屏</p><p>在 Tab 上点开扩展按钮，点击 Open in Split View ，可以在右边区域扩展一个页面，这个功能在大屏显示器中就比较舒服了，比如左边可以开一个微信读书，右边放一个 flomo 来记笔记。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302057577.png"></p><p>这个功能在之前只能在 macOS 中开一个新的全屏桌面，将两个浏览器页签并排放入这个桌面。操作上比较复杂一点，而且不能保持，电脑重启就没了。</p><p>5、小窗浏览</p><p>这是在 Obsidian 中添加网页链接后无意间发现的，当我在 Obsidian 中输入了一个链接并点击这个链接的时候，Arc 会启动一个小的浏览器窗口，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210302057573.png"></p><p>除了上面提到的，Arc 还有 Easel、Note、Boost、网页内截图等功能，有兴趣的可以自己去研究下。</p><p>各类的浏览器用过不少，无疑，Arc 是带来冲击力最大的一个，在看似没有办法再优化的一些点上又有了突破性的创新。</p><p>再想想我们正在做的零代码产品，如果不人云亦云，而是在某些垂直的功能上进行深挖，在易用性和功能上做些创新，解决一些用户的痛点问题，是不是就能异军突起呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在系统的版本上，我算得上是一个保守派，买电脑时系统的版本是 10.15.7 ，到现在一直没有升级过。&lt;/p&gt;
&lt;p&gt;最近在即刻上看到很多人推荐 Arc 浏览器，Arc 现在还没有正式开放，需要邀请，经过一番周折，在安装时发现最低系统要求是 macOS 11 以上，于是便决定升级系统。&lt;/p&gt;
&lt;p&gt;本文就说说 Ventura 的升级和 Arc 浏览器的体验。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="Arc" scheme="http://fwhyy.com/tags/arc/"/>
    
    <category term="Ventura" scheme="http://fwhyy.com/tags/ventura/"/>
    
    <category term="macOS" scheme="http://fwhyy.com/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>读《阅读的方法》</title>
    <link href="http://fwhyy.com/2022/10/read-reading-methods/"/>
    <id>http://fwhyy.com/2022/10/read-reading-methods/</id>
    <published>2022-10-24T00:41:03.000Z</published>
    <updated>2022-11-08T08:48:14.805Z</updated>
    
    <content type="html"><![CDATA[<p>关于阅读的方法，有一本著名的书《如何阅读一本书》，从阅读的层次、书籍的分类、不同类型书籍的阅读方法讲的非常清楚了。</p><p>本文要说的是今年罗胖出的《阅读的方法》，虽然书名叫阅读的方法，但书中却没有具体的方法，我觉得叫阅读的意义可能更合适。</p><p>书的作者是罗振宇，人称罗胖，得到创始人，最出名的是从 2015 年开始坚持每年举办「时间的朋友」跨年演讲，以及公众号每天早上 6 点准时推送 60 秒的语音内容。</p><p>这本书很容易读，我读书非常慢，一个周末也读完了。下面说说我的一些理解。</p><span id="more"></span><h2 id="专注、随意"><a href="#专注、随意" class="headerlink" title="专注、随意"></a>专注、随意</h2><p>看书需要专注，最好是能进入心流状态，我一直跟女儿说，学习的时候专注地学习，玩的时候就畅快地玩，否则既没学习，也没玩好，时间也浪费掉了，所以如果读书时，还在想着其他事情，肯定是过目即忘。</p><p>但看书也是随意的，任何一本书都可以随时翻开、随时合上，不必把读书太当一回事。阅读应该是一件轻松愉快的事，不用刻意追求结果，享受过程就好。我之前看书经常是从前言看起，导致很多书都看不完，就像四级单词永远都在背 abandon 一样，罗胖说的这种随意正是我需要的。</p><p>随意地看，记不住怎么办？在知乎、头条上也看到过很多人问，读的书记不住，那看了有什么用？我之前也会有这样的困惑，直到我看到这样一个解释：</p><blockquote><p>你有生以来吃了那么多饭，都能记得吃的啥吗？不必记得，因为它的精华，已经成长为你强健的身体。读书也一样，不必记得，但读书的过程及内容，已经融入了你的修养。</p></blockquote><p>有了专注和随意，我们才有机会接触到更多不同种类的书，从书中了解到自己的局限性，也可以看到世界的多样性。当看到是那些和我们的直觉、本能不一样的观点和方法时，需要记录、思考，这个过程可以让我们成长。</p><p>慢慢读的书越来越多，我们的谈资就多，能够与人交流，交流的过程中又能吸收不同的知识，如此往复。我老婆觉得这种「谈资」太功利了，就像我最近在看马未都的观复都嘟，我跟老婆说，这个可以了解不少中国传统文化的东西，知识面变宽了，可以吹吹牛逼了，老婆就说我太功利，我倒觉得这些“功利”的东西是在过程中所产生的附属物，也并非坏事。</p><h2 id="抽象思维"><a href="#抽象思维" class="headerlink" title="抽象思维"></a>抽象思维</h2><p>在面向对象的编程中，处处都体现了抽象思维，抽象接口、抽象基类等。有抽象的思维就能以俯视的角度去看问题，当站在更高的层次往下看时，很多问题便不再是问题，很多困难也可以迎刃而解了。</p><p>例如：从开发人员的角度，是在做一个具体的任务，比如：攻坚某个技术难题，但从公司层面讨论后发现，这一块的需求是个伪需求，优先级没那么高，甚至可以不做，资源可以用来做更有意义的事情，那个所谓的难题自然也就不用去研究了。</p><p>抽象的另一个好处就是层次越高就越有共性，能够建立起一套模型，比如在低代码的产品中有很多的业务组件，如果不进行抽象，看到的每个组件都不相同，因为都是实现不同的业务，但如果抽象成模型，一个组件有入参、出参、事件，只要是遵循这三者的规范，都可以接入到平台中，并能和平台的其他部分进行无缝对接，这样站在抽象层面来看，价值就很大了。</p><h2 id="往下深挖一厘米"><a href="#往下深挖一厘米" class="headerlink" title="往下深挖一厘米"></a>往下深挖一厘米</h2><p>很多时候我们看书，或者听演讲，碰到了一些新词，看过，听过后便觉得自己很熟悉了，好像真的了解了一样，但如果跟人谈起，被问到，会发现根本就解释不清楚。</p><p>后来我养成了一个习惯，碰到新的概念或词语，便会记录、查询，了解其意思，在这个过程中可能又会遇到其他的不懂的词语，如此循环下去，尽量把每一个疑惑都搞懂。</p><p>否则，不懂装懂就会闹书中这个故事里的笑话了：</p><blockquote><p>从前，有位僧人与一位文士同宿于夜航船中。文士高谈阔论，僧人敬畏慑服，双脚蜷缩而眠。过了一阵，僧人感觉文士言语中多有破绽，就问文士说：“请问这位相公，‘澹台灭明’是一个人还是两个人？”学子说：“是两个人。”僧人又问：“这个尧舜是一个人还是两个人？”学子说：“当然是一个人！”僧人听了笑着说：“这么说来，还是让小僧先伸伸脚吧。”</p></blockquote><p>往下深挖除了从 0 到 1 弄清楚某个概念，还有不断重复的意思。</p><p>杨绛在《钱锺书是这样做读书笔记的》中提到，“钱锺书读过的书不仅多而且不易遗忘，这种本领归功于他独特的读书笔记之法。钟书做一遍笔记的时间，约莫是读这本书的一倍。他说，一本书，第二遍再读，总会发现读第一遍时会有很多疏忽。最精彩的句子，要读几遍之后才发现。” 。</p><p>看到这个我才了解到自己的阅读是多么不认真和肤浅。</p><p>最后，除了重复，往下深挖还可以从多方位，不同的角度来理解同一个事物，就像学习编程过程中一个知识点可以多找几本参考书，看看不同的作者是怎么理解这个知识点的，这样会更全面地学习。看书也是一样，不要只读一个人所谓的“代表作”，否则会错过很多，随机漫步似的闲逛，能发现更有意思的风景。</p><h2 id="以史为鉴"><a href="#以史为鉴" class="headerlink" title="以史为鉴"></a>以史为鉴</h2><p>我们在编程时遇到的各种问题，总是很容易在网上找到答案，因为我们遇到的问题，早就有很多的人遇到过了，并且沉淀出来了解决方案，我们只需要找到它，学习利用即可。</p><p>书籍世界储存了人类文明中所有重要人物在关键时刻的选择，成功的、失败的、好的、坏的，在别人的剧本里早就上演过了。</p><p>阅读的越多，我们的解决方案也就越多，到遇到问题，需要做出选择的时候，这些方案可以给供我们参考，书中的一个比喻很有意思：</p><blockquote><p>可以把头脑想象成一个会议室，一开始是我们的家长、老师、朋友在会议室中，随着读书越来越多，会议室中的厉害的人也越来越多，当遇到艰难的选择，他们就会把意见放到桌上，供我们参考，最终一个人活得像一支队伍。</p></blockquote><h2 id="超时空对话"><a href="#超时空对话" class="headerlink" title="超时空对话"></a>超时空对话</h2><p>常说读万卷书，行万里路，疫情当下，行万里路变得更加困难了，但读万卷书，只要你愿意，是可行的。</p><p>游记可以跟随作者的脚步去游历名山大川、了解风土人情。</p><p>自传、回忆录可以看到作者是怎样记录、沉淀、筛选和输出他经历的那些有趣的场景和细节。</p><p>读这些书时，可能有困惑，可能随即又能找到答案，如同穿越了时空，和作者在面对面对话一样。</p><h2 id="书的延伸"><a href="#书的延伸" class="headerlink" title="书的延伸"></a>书的延伸</h2><p>一本书的知识是有限的，但作者会有很多的引用和推荐，我们可以顺这些线索找到更多的书籍，每本书都和其他的很多书有关联，就像走进一扇小门，却发现里面别有洞天，不断地能打开新的世界。</p><p>如果没有阅读的开始，就会错过很多美丽的风景。</p><p>之前在网上无意中发现 flomo 这个工具，然后看 flomo 101 的入门文档，知道了这个工具的创始人是少楠，后来在少楠的播客节目中知道《增长黑客》的作者范冰，范冰也有自己的播客节目，其中有一期聊知识管理工具，我便尝试了 Obsidian ，在学习 Obsidian 用法的过程中，又发现了 logseq ,现在 Obsidian 和 logseq 是我很喜欢并常用的两个工具。</p><p>就这样在知识获取的过程中不断地产生连接，最终就像一张网一样。</p><p>罗胖的这本书，就是这样一张网的源头，里面有大量书籍片段的引用，每章后还有书单推荐，我们可以根据自己的兴趣，用这本书做跳板，去结出属于自己的网。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>看过一句话，觉得很有道理：“想都是问题，做才有答案”，读书、跑步也都一样，首先要做的就是行动起来。</p><p>当阅读已经成为生活的一部分，方法真的还重要吗？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于阅读的方法，有一本著名的书《如何阅读一本书》，从阅读的层次、书籍的分类、不同类型书籍的阅读方法讲的非常清楚了。&lt;/p&gt;
&lt;p&gt;本文要说的是今年罗胖出的《阅读的方法》，虽然书名叫阅读的方法，但书中却没有具体的方法，我觉得叫阅读的意义可能更合适。&lt;/p&gt;
&lt;p&gt;书的作者是罗振宇，人称罗胖，得到创始人，最出名的是从 2015 年开始坚持每年举办「时间的朋友」跨年演讲，以及公众号每天早上 6 点准时推送 60 秒的语音内容。&lt;/p&gt;
&lt;p&gt;这本书很容易读，我读书非常慢，一个周末也读完了。下面说说我的一些理解。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="方法" scheme="http://fwhyy.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习：并发编程</title>
    <link href="http://fwhyy.com/2022/10/go-learning-concurrency/"/>
    <id>http://fwhyy.com/2022/10/go-learning-concurrency/</id>
    <published>2022-10-17T00:21:16.000Z</published>
    <updated>2022-11-08T08:40:14.069Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言在创建之初，CPU 多核发展的正猛，Go 语言的创始人果断将面向多核、原生就支持并发作为了 Go 语言的设计目标之一，所以所在 Go 语言中使用并发有得天独厚的优势。</p><p>那么，什么是并发呢？</p><span id="more"></span><p>聊到并发，就会有一系列的其他概念相继而来，比如：并行、进程、线程、异步等。</p><p>我们经常使用 C# 的 Winform 程序写一些工具，编译后为一个 exe 文件，文件执行后就会作为一个进程在 Windows 中执行，在之前的单核 CPU 时代，在某个时刻只能执行一个进程对应的程序代码，两个进程不存在并行执行的可能，多个处理器或多核处理器是并行执行的必要条件。</p><p>如果对程序进行改造，对执行的任务进行分解，每个分解出来的小的模块由一个单独的线程进行处理，多个线程共享这个进程所拥有的资源，线程作为执行单元可被独立调度到处理器上运行。也许还是执行在单 CPU 中，但是在并发执行的。</p><p>Go 语言的创始人 Rob Pike 曾说过：并行关乎执行，并发关乎结构。</p><p>举一个生活中的例子：</p><p>现在每天都在做的排队做核酸，有三个步骤：</p><p>1、排队；</p><p>2、扫二维码；</p><p>3、捅喉咙</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210160632390.png" alt="image-20221016044835822"></p><ul><li>需要做核酸的人分多个队伍进行排队，是并行在进行处理；</li><li>每一个队伍中只有一个检测人员，先进行扫码，然后去捅喉咙，两个步骤完成后，再进行下一个。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202210160635086.png" alt="image-20221016045411793"></p><ul><li>扫码和捅喉咙都有单独的人员进行处理，这就像将程序拆分成多个线程进行处理一样；</li><li>并发在单 CPU 也能发生，就像上图中只有一个队伍的情况，但多核或多 CPU 更多发挥其作用。</li></ul><p>由此可见，要发挥并发的作用，离不开线程和多核，但线程创建的成本虽然已经比进程小了很多，但依然不适合创建大量的线程，因为除了每个线程占用的资源外，操作系统调度线程的成本也不小。</p><p>因此，Go 语言创造了 goroutine ，也叫协程，这是一个由 Go 运行时负责调度的轻量级线程。和常规的线程相比，有这些好处：</p><ul><li>资源占用小Groutine 的 Stack 的初始化的大小为 2k ，而像 C# 、Java 语言中线程的 Stack 都是兆级别的，所以 Go 中的协程的创建会更加快；</li><li>由 Go 运行时调度，而不是操作系统，切换速度会更快。</li></ul><p>在 Go 中怎样使用 goroutine 呢？非常的简单，使用关键字 go 就可以了，默认情况下，主程序在单独的一个 goroutine 中，如果某个函数或匿名函数使用了 go 关键字，那么就会创建一个单独的 goroutine 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testGouroutine</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;goroutine:&quot;</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;这是主程序&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> testGouroutine(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> testGouroutine(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> testGouroutine(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> testGouroutine(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在使用 go 关键字的函数中使用了主程序中的资源，就会出现竞争的情况，看下面的这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">counter++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次运行，counter 的值都会不一样，因为每次不同的协程队公共资源 counter 的抢夺情况不一样，要解决这个问题就要用到锁：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line"></span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> mut.Unlock()</span><br><span class="line">mut.Lock()</span><br><span class="line">counter++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;counter:&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，使用 go 关键字执行的函数即便是有返回值，也会被忽略，如果需要在 goroutine 之间进行通信，需要使用通道。</p><p>通道使用 make 进行构建，关键字为 chan 。看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//使用 make 创建一个字符型的通道，通道使用关键字 chan</span></span><br><span class="line">msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">//在异步匿名函数中模拟同步数据，完成一个给通道发送一个消息</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">msg &lt;- <span class="string">&quot;success&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg &lt;- <span class="string">&quot;总共需要同步 10 个模块，已经处理 &quot;</span> + strconv.Itoa(i) + <span class="string">&quot;个&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每循环依次，演示 1 秒，模拟耗时</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程中进行进度显示</span></span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> msg &#123;</span><br><span class="line"><span class="keyword">if</span> m == <span class="string">&quot;success&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;同步完成&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在匿名函数中每隔一秒就给主 gorourine 发送一个消息，主 gorourine 把这个消息打印出来。</p><p>最后总结下：</p><p>1、并行关乎执行，并发关乎结构；</p><p>2、Go 语言的并发是基于轻量级的 goroutine ，相比普通的线程，goroutine 有很多的好处；</p><p>3、在不同的 goroutine 之间进行通信需要用到通道，通道使用 make 创建，关键字为 chan 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go 语言在创建之初，CPU 多核发展的正猛，Go 语言的创始人果断将面向多核、原生就支持并发作为了 Go 语言的设计目标之一，所以所在 Go 语言中使用并发有得天独厚的优势。&lt;/p&gt;
&lt;p&gt;那么，什么是并发呢？&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="golang" scheme="http://fwhyy.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>如何健康地跑步？</title>
    <link href="http://fwhyy.com/2022/10/how-to-run-healthily/"/>
    <id>http://fwhyy.com/2022/10/how-to-run-healthily/</id>
    <published>2022-10-12T08:35:35.000Z</published>
    <updated>2022-11-08T08:48:19.264Z</updated>
    
    <content type="html"><![CDATA[<p>最近某司高管跑步 28 公里后猝死，被各大媒体报道，每次这种悲剧发生，而且还跟跑步扯上关系，总是让人心痛。</p><p>通过报道了解到，这位高管酷爱跑马拉松，身体素质和运动能力肯定是强于普通人的，但还是遭遇了不幸，只能说有一定基础和能力的人都会过于自信而导致忽视了一些重要的身体信号，就像 2021 年 5 月 22 日黄河石林山地马拉松百公里越野赛中遇难的也基本是专业运动员一样，都过于自信了，其中还包括大神梁晶。</p><span id="more"></span><p>我从 2016 年开始跑步，到现在总跑量将近 4000 公里，期间跑过 2 次全马，17 次半马，没怎么受过伤，我觉得除了运气之外，靠的是对跑步、马拉松运动的敬畏。</p><p>跑步是为了健康，但怎样让跑步不伤害健康，我觉得要做好以下几点：</p><p><strong>关注跑步本身</strong></p><p>很多人跑步习惯关注：</p><ul><li>数据：配速、心率、步频、步幅、摄氧量等；</li><li>技术：怎样送髋？前脚掌还是后脚掌落地？</li><li>装备：鞋子、运动手表、营养补给。</li></ul><p>这些外在的东西往往会让我们忽略了跑步本身，我们需要做的就是迈开腿，跑起来而已，距离、配速都不重要，如果有同伴和你一起跑，以跑步的时候还能跟同伴聊天为标准来调整速度。</p><p>跑步时，也需要多聆听自己身体发出的声音，做到适可而止。如果工作忙，加班多，就多休息，在保证身体没有透支的情况下再去跑步，否则跑的越多，伤害越大。</p><p><strong>接受自己的普通</strong></p><p>大部分跑者都是普通人，这里的普通人有两层意思：</p><p>1、刚走上跑步之路的小白，就像我 16 年的时候跑步 2 公里就到极限了；</p><p>2、年轻时是运动健将，随着年龄的增长，到了 40 、50 岁，身体各方面都下降，慢慢变得普通了。</p><p>再普通的人也都有着一颗竞技的心，我也是一样。提高成绩本身是没问题的，但不要采用一些激进的方式想要快速提高，比如在刚开始的时候就强迫自己每天 5 公里，或者当身体已经发出警告时，还咬牙坚持，这种不是有体育精神，而是傻。</p><p>王建硕在播客中被问到为什么能坚持写作，他说：</p><blockquote><p>我给自己设定了一个规则，每天不能写超过一篇的文章，有时候有很多内容想写，也只能到明天了，这样就让自己有一种欲望，期望明天快点到来。</p></blockquote><p>我觉得这个方法挺不错的，跑步也是一样，普通人就佛系一点，可以设定每次距离不要超过 1 公里，等这 1 公里能驾轻就熟了，再适当调整目标。</p><p>当没有了距离和配速的压力，跑步就变得轻松了，我们只用享受跑步的这个过程，其他的就交给时间，你会发现，慢慢你跑的距离会越来越长，配速也会越来越快。</p><p><strong>热身</strong></p><p>跑前热身，跑后拉伸，真的非常重要，特别是冬天，更是要加大热身的时间，充分热身后才开始跑步，可以大大减少受伤的几率。</p><p>2017 年跑完北京马拉松后，有点飘了，觉得全马都没有问题，平时的 5 公里就更不在话下，每次出门直接就开跑，一段时间后，膝盖就有点疼，后来靠墙静蹲了很长时间才慢慢恢复。</p><p>从那以后，就很注意热身和拉伸了，去年 9 月 1 号开始连续跑了 100 天，每天至少 5 公里，整个过程中身体都没出现过异常。</p><p><strong>半马怡情，全马伤身</strong></p><p>普通人跑跑 5 公里、10 公里就好，毕竟是为了身体健康，没有必要去跑马拉松。</p><p>如果确实喜欢挑战，我建议跑跑半马就好，虽然全马的距离是半马的两倍，但难度可不是两倍。我跑过的两个全马都是在 2017 年，4 月份的汉马和 10 月的北京马拉松。都非常痛苦，跑完像生了一场大病一样，差不多一个星期才恢复。</p><p>后来我发现，只要我每个月有 100 多公里的跑量作为基础，连续准备几个月，跑半马就非常轻松了。去年连续跑 100 天期间，半马成绩连连  PB，都不是刻意去追求速度，而是量变到质变的结果。</p><p><strong>最后</strong></p><p>猝死和跑步只是有相关关系，并不是因果关系，如果觉得怕猝死，而放弃锻炼，也是大可不必。</p><p>希望每个人都能健康地跑起来，跑出健康，有了健康，才有更多的可能性。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近某司高管跑步 28 公里后猝死，被各大媒体报道，每次这种悲剧发生，而且还跟跑步扯上关系，总是让人心痛。&lt;/p&gt;
&lt;p&gt;通过报道了解到，这位高管酷爱跑马拉松，身体素质和运动能力肯定是强于普通人的，但还是遭遇了不幸，只能说有一定基础和能力的人都会过于自信而导致忽视了一些重要的身体信号，就像 2021 年 5 月 22 日黄河石林山地马拉松百公里越野赛中遇难的也基本是专业运动员一样，都过于自信了，其中还包括大神梁晶。&lt;/p&gt;</summary>
    
    
    
    <category term="跑步" scheme="http://fwhyy.com/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
    <category term="马拉松" scheme="http://fwhyy.com/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
    <category term="跑步" scheme="http://fwhyy.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>系统学习还是得看书，Go 书籍推荐</title>
    <link href="http://fwhyy.com/2022/10/go-book-recommendation/"/>
    <id>http://fwhyy.com/2022/10/go-book-recommendation/</id>
    <published>2022-10-08T00:21:16.000Z</published>
    <updated>2022-11-08T08:48:21.859Z</updated>
    
    <content type="html"><![CDATA[<p>想要更系统地学习编程语言，看书是比较有效的途径之一。最近又学习了下 Go 语言，为什么是又，因为 2013 年买过许式伟大佬翻译的一本 Go 语言书籍，但没有系统学下去，现在想想原因可能是这本书过于严肃，没那么有趣，还有就是当时对编程语言的理解也没那么深。</p><p>所以说看书虽然系统，还是要选择能够看的进去的书。之前看过一句话：写作需要阅读作为基础，阅读也需要阅读作为基础，我觉得很有道理。所以在看书之前，可以先将这个领域的相关概念大概了解下，不同的文章做下横向比较，再去阅读书籍，会有不错的效果，这就像学生时代的课前预习一样。</p><span id="more"></span><p>Go 目前最新的版本到了 1.19 ，出版的书籍肯定是更不上版本迭代的速度，但建议还是尽可能找比较新的书。</p><p>2022 年出版的《Go 语言精进之路》个人感觉还不错，作者 Tony Bai（白明），资深架构师、tonybai.com 博主，是 Gopher 部落技术社群发起人。2015 年就在自己博客上开始分享 Go 相关的知识，有非常丰富的实战经验。</p><p>在出版这本书之前，Tony Bai 还在极客时间开设了一个关于 Go 的入门级专栏 《Tony Bai · Go 语言第一课》，有兴趣可以去看看：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202211081627274.png"></p><p>再来说说《Go 语言精进之路》这本书吧。</p><p>全书分为十个部分，上下两册，上册包含 1<del>7 ，下册包含 8</del>10 ，我很喜欢第一部分和第二部分。</p><p>第一部分：</p><ul><li> Go 语言的诞生和演进：了解语言诞生的故事和发展历程，可以增强我们学习编程语言的兴趣；</li><li>Go 语言的各个版本的变化：这个对我来说非常有用，能够知道每个版本中的新增了什么功能，添加了什么特性。之前看《C# 本质论》的时候就非常喜欢，因为在一些特性的地方都标注了是在哪个版本中添加；</li><li>Go 语言设计哲学：作为一门年轻的语言，在设计之初肯定是有很多的考量，要规避什么问题、解决什么问题，而且了解语言的设计哲学，对我们学习 Go 编程思维、编写高质量 Go 代码是很有帮助的；</li><li>Go 编程思维：原生的并发支持。</li></ul><p>第二部分：</p><p>每个技术团队应该都有自己的编码规范，我认为规范，在一个团队中保持统一就好，比如你在团队中要求 C# 的方法名使用小写字母开头，也不是不行，大家就都按照这个标准，但问题是，这不符合业界的标准，如果有新来的同事，有可能会产生冲突。</p><p>除了代码风格，命名规范，还有项目结构也是初学者非常头疼的问题。10 年前，博客园的弦哥发起了一个 .NET 中搭架子大赛，各路大佬纷纷献计，非常热闹，可见程序员对项目结构是非常关注的。当时大赛的链接如下：</p><p><a href="https://www.cnblogs.com/legendxian/archive/2012/06/20/2554740.html">https://www.cnblogs.com/legendxian/archive/2012/06/20/2554740.html</a></p><p><a href="https://www.cnblogs.com/legendxian/archive/2012/06/18/2553111.html">https://www.cnblogs.com/legendxian/archive/2012/06/18/2553111.html</a></p><p>在这本书的第二部分就涉及了项目结构相关内容，给新手解决了一大难题。</p><p>其他部分：</p><p>后面的一些章节通过条目的方式讲解了 Go 语言的方方面面，示例代码中的结构和变量的命名和非常严谨。在网上看到有些评价说有的地方比较啰嗦，这个就见仁见智了，我个人比较喜欢把一个点讲的比较透彻的，有时内容过于精简，我还需要去找些同类的书籍对比着看，来帮助理解。</p><p>目前，我自己感觉对 Go 语言已经入门了，相信在学习完这本书之后，可以熟练掌握 Go 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;想要更系统地学习编程语言，看书是比较有效的途径之一。最近又学习了下 Go 语言，为什么是又，因为 2013 年买过许式伟大佬翻译的一本 Go 语言书籍，但没有系统学下去，现在想想原因可能是这本书过于严肃，没那么有趣，还有就是当时对编程语言的理解也没那么深。&lt;/p&gt;
&lt;p&gt;所以说看书虽然系统，还是要选择能够看的进去的书。之前看过一句话：写作需要阅读作为基础，阅读也需要阅读作为基础，我觉得很有道理。所以在看书之前，可以先将这个领域的相关概念大概了解下，不同的文章做下横向比较，再去阅读书籍，会有不错的效果，这就像学生时代的课前预习一样。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="golang" scheme="http://fwhyy.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习：那些不一样的知识点（下）</title>
    <link href="http://fwhyy.com/2022/10/go-learning-those-different-knowledge-points-2/"/>
    <id>http://fwhyy.com/2022/10/go-learning-those-different-knowledge-points-2/</id>
    <published>2022-10-01T00:21:16.000Z</published>
    <updated>2022-11-08T08:48:24.965Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇《Go 学习：那些不一样的知识点（上）》中已经提到了 10 个 Go 语言中有特点的地方，本文继续介绍一些 Go 语言中语法或使用方式比较独特的知识点。</p><h2 id="11、切片类型"><a href="#11、切片类型" class="headerlink" title="11、切片类型"></a>11、切片类型</h2><p>同 Python 一样，Go 语言中也支持切片类型，而 C# 在 C# 8 中也增加了对数组进行切片操作的语法糖，先来看一个 C# 的例子：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var s = new string[] &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot; &#125;;</span><br><span class="line">    Console.WriteLine(string.Join(&quot;,&quot;,s)); </span><br><span class="line">    //取下标 2 到 4</span><br><span class="line">    var s1 = s[2..5]; </span><br><span class="line">    Console.WriteLine(string.Join(&quot;,&quot;,s1));  //输出 c,d,e</span><br><span class="line">    //最后两个之前的所有元素</span><br><span class="line">    var s2 = s[..^2]; </span><br><span class="line">    Console.WriteLine(string.Join(&quot;,&quot;,s2)); //输出 a,b,c,d</span><br><span class="line">    //最后两个元素</span><br><span class="line">    var s3 = s[^2..];</span><br><span class="line">    Console.WriteLine(string.Join(&quot;,&quot;,s3)); //输出 e,f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言中使用 make 关键字来构建切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="string">&quot;b&quot;</span></span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;c&quot;</span></span><br><span class="line">fmt.Println(s) <span class="comment">//输出 [a b c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内容追加</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;d&quot;</span>)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">fmt.Println(s) <span class="comment">//输出[a b c d e f]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据下标取数，下标从 0 开始计算，下面例子中是取下标为 2,3,4 的值</span></span><br><span class="line">l := s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(l) <span class="comment">//输出 [c d e]</span></span><br><span class="line"><span class="comment">//取下标为 0,1 的值</span></span><br><span class="line">l = s[:<span class="number">2</span>]</span><br><span class="line">fmt.Println(l) <span class="comment">//输出 [a b]</span></span><br><span class="line"><span class="comment">//取下标为 3,4,5 的值</span></span><br><span class="line">l = s[<span class="number">3</span>:]</span><br><span class="line">fmt.Println(l) <span class="comment">//输出 [d e f]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12、range-的使用"><a href="#12、range-的使用" class="headerlink" title="12、range 的使用"></a>12、range 的使用</h2><p>在上一篇的示例中，遍历 map 的时候有使用过 range，而 range 的作用不仅能遍历 map ，还可以遍历数组、切片、字符串等：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;下标：&quot;</span>, index, <span class="string">&quot;值：&quot;</span>, num)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// 下标： 0 值： 1</span></span><br><span class="line"><span class="comment">// 下标： 1 值： 2</span></span><br><span class="line"><span class="comment">// 下标： 2 值： 3</span></span><br><span class="line"><span class="comment">// 下标： 3 值： 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 map</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;oec2003&quot;</span>, <span class="number">2</span>: <span class="string">&quot;fengwei&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//oec2003</span></span><br><span class="line"><span class="comment">//fengwei</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历字符串</span></span><br><span class="line">s := <span class="string">&quot;hello,oec2003!&quot;</span></span><br><span class="line"><span class="keyword">for</span> _, k := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(k))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13、指针"><a href="#13、指针" class="headerlink" title="13、指针"></a>13、指针</h2><p>上大学时学习 C 语言有学习过指针，C# 虽然也能使用指针，但不常用，而且是在有限范围内使用，C#的指针是一个持有另一类型内存地址的变量，在C#中，指针只能被声明为持有值类型和数组的内存地址，指针类型不被默认的垃圾收集机制所跟踪。</p><p>下面看看 Go 中的指针使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//接收具体的数值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useValue</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收指向 int 类型的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">usePointer</span><span class="params">(num *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*num = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">useValue(i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line"></span><br><span class="line">usePointer(&amp;i)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用数值传递时，函数中对参数值进行了修改，但不会影响原值；</li><li>对指针类型的参数赋值时，需要添加 &amp; 符号，表示传递的不是 i 的值，而是 i 的值对应的地址，所当函数内对这个地址的值进行修改后，原值也会发生变化。</li></ul><h2 id="14、结构体和方法"><a href="#14、结构体和方法" class="headerlink" title="14、结构体和方法"></a>14、结构体和方法</h2><p>在 Go 语言中没有类的概念，取而代之的是结构体，结构体使用 struct 关键字声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//定义一个名为 user 的结构体</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := user&#123;name: <span class="string">&quot;oec2003&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">fmt.Println(user1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在上面例子中 userInfo 结构体中添加方法，并不是写在结构体的内部，看下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个名为 userInfo 的结构体</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">getUserInfo</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + u.name + <span class="string">&quot;,年龄：&quot;</span> + strconv.Itoa(u.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := user&#123;name: <span class="string">&quot;oec2003&quot;</span>, age: <span class="number">18</span>&#125;</span><br><span class="line">fmt.Println(user1.getUserInfo())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过在定义函数的时候指定一个结构体类型的实例，就可以将函数变成结构体的方法了；</li><li>有点像是 .NET 中的扩展方法。</li></ul><h2 id="15、接口"><a href="#15、接口" class="headerlink" title="15、接口"></a>15、接口</h2><p>在 Go 语言中，接口是非入侵性的，接口的实现不依赖接口的定义，这一点跟 C# 有很大的不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个数据库访问的接口，有一个方法返回连接字符串</span></span><br><span class="line"><span class="keyword">type</span> database <span class="keyword">interface</span> &#123;</span><br><span class="line">getConnection() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mysql 的执行器</span></span><br><span class="line"><span class="keyword">type</span> mysqlExecutor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sqlserver 的执行器</span></span><br><span class="line"><span class="keyword">type</span> sqlserverExecutor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 给 mysql 执行器添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m mysqlExecutor)</span> <span class="title">getConnection</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;这是 mysql 连接字符串&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给 sqlserver 执行器添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m sqlserverExecutor)</span> <span class="title">getConnection</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;这是 sqlserver 连接字符串&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个函数获取连接字符串，参数为 database 接口类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getConnection</span><span class="params">(d database)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.getConnection()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//只要是结构体中的方法有跟接口方法有相同的签名，就可以进行调用</span></span><br><span class="line">m := mysqlExecutor&#123;&#125;</span><br><span class="line">fmt.Println(getConnection(m))</span><br><span class="line"></span><br><span class="line">s := sqlserverExecutor&#123;&#125;</span><br><span class="line">fmt.Println(getConnection(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//这是 mysql 连接字符串</span></span><br><span class="line"><span class="comment">//这是 sqlserver 连接字符串</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟结构体的方法不需要结构体的内部一样，接口的实现也不要显示的声明，只需要方法的签名和接口中的方法签名相同，就算是实现了接口方法。</p><h2 id="16、并发"><a href="#16、并发" class="headerlink" title="16、并发"></a>16、并发</h2><p>Go 语言因为出生的比较晚，在设计之初就考虑到了并发编程的场景，并以原生支持并发著称，下面以一个简单的例子来感受下 Go 的并发：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello,&quot;</span>, msg, <span class="string">&quot;:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//主线程调用</span></span><br><span class="line">sayHello(<span class="string">&quot;fengwei&quot;</span>)</span><br><span class="line"><span class="comment">//使用 go 关键字让函数异步调用，单独开启线程</span></span><br><span class="line"><span class="keyword">go</span> sayHello(<span class="string">&quot;fengwei&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码执行的结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello, fengwei : 0</span><br><span class="line">hello, fengwei : 1</span><br><span class="line">hello, fengwei : 2</span><br></pre></td></tr></table></figure><p>使用 go 关键字异步调用的方法并没有打印出来，因为主线程不会等异步函数执行就会继续往下走，然后程序就运行结束了，可以在调用后 sleep 1 秒钟来让异步调用的结果能打印出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//主线程调用</span></span><br><span class="line">sayHello(<span class="string">&quot;fengwei&quot;</span>)</span><br><span class="line"><span class="comment">//使用 go 关键字让函数异步调用，单独开启线程</span></span><br><span class="line"><span class="keyword">go</span> sayHello(<span class="string">&quot;oec2003&quot;</span>)</span><br><span class="line">    <span class="comment">//等待 1 秒</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">// hello, fengwei : 0</span></span><br><span class="line"><span class="comment">// hello, fengwei : 1</span></span><br><span class="line"><span class="comment">// hello, fengwei : 2</span></span><br><span class="line"><span class="comment">// hello, oec2003 : 0</span></span><br><span class="line"><span class="comment">// hello, oec2003 : 1</span></span><br><span class="line"><span class="comment">// hello, oec2003 : 2</span></span><br></pre></td></tr></table></figure><p>上面只有一个异步函数的调用，如果有多个异步函数调用，那么这些异步函数的调用顺序是随机的，有兴趣的朋友可以自己试试看。</p><h2 id="17、通道"><a href="#17、通道" class="headerlink" title="17、通道"></a>17、通道</h2><p>在 Go 语言中可以很方便地使用并发，那么在并发中多个线程怎么通信，就要用到通道了。通道使用关键字 chan 定义，使用 make 类构建通道，下面代码创建了一个字符类型的通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//使用 make 创建一个字符型的通道，通道使用关键字 chan</span></span><br><span class="line">msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有这样一个场景：</p><p>1、用一个匿名异步函数来处理耗时操作，比如同步数据，使用通道反馈给主线程进度；</p><p>2、在主线程中实时更新进度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//使用 make 创建一个字符型的通道，通道使用关键字 chan</span></span><br><span class="line">msg := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="comment">//在异步匿名函数中模拟同步数据，完成一个给通道发送一个消息</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">msg &lt;- <span class="string">&quot;success&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">msg &lt;- <span class="string">&quot;总共需要同步 10 个模块，已经处理 &quot;</span> + strconv.Itoa(i) + <span class="string">&quot;个&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//每循环依次，演示 1 秒，模拟耗时</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程中进行进度显示</span></span><br><span class="line"><span class="keyword">for</span> m := <span class="keyword">range</span> msg &#123;</span><br><span class="line"><span class="keyword">if</span> m == <span class="string">&quot;success&quot;</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;同步完成&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果为，每隔一秒，输出一条进度信息，全部输出完结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">总共需要同步 10 个模块，已经处理 1个</span><br><span class="line">总共需要同步 10 个模块，已经处理 2个</span><br><span class="line">总共需要同步 10 个模块，已经处理 3个</span><br><span class="line">总共需要同步 10 个模块，已经处理 4个</span><br><span class="line">总共需要同步 10 个模块，已经处理 5个</span><br><span class="line">总共需要同步 10 个模块，已经处理 6个</span><br><span class="line">总共需要同步 10 个模块，已经处理 7个</span><br><span class="line">总共需要同步 10 个模块，已经处理 8个</span><br><span class="line">总共需要同步 10 个模块，已经处理 9个</span><br><span class="line">同步完成</span><br></pre></td></tr></table></figure><h2 id="18、异常处理"><a href="#18、异常处理" class="headerlink" title="18、异常处理"></a>18、异常处理</h2><p>在 Go 语言中没有 C# 中 try catch 的异常处理机制，而采用的是使用返回值的判断，Go 语言的一些内置函数就是使用多返回值来处理异常，比如：strconv.Atoi ，看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">age := <span class="string">&quot;oec2003&quot;</span></span><br><span class="line">age1, err := strconv.Atoi(age)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;转换出错，错误信息：&quot;</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;转换成功，值为：&quot;</span>, age1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 age 的值不是数字的时候，就会打印出错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换出错，错误信息： strconv.Atoi: parsing &quot;oec2003&quot;: invalid syntax</span><br></pre></td></tr></table></figure><p>我们自定义的函数也可以通过多返回值的方式来返回错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值的第二个参数为 error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">division</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;除数不能为 0&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">result, err := division(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这，Go 语言的学习应该就算是入门了，接着可以针对 Go 的并发进行深入研究，还可以学习下在 Go 语言中是怎么使用面向对象编程的？怎样进行数据库的操作？一些常用库是如何使用的？</p><p>然后拿 Go 语言去做一些实际的小项目，比如：SSG 类型的博客系统、容器的发布部署系统等等。在实际项目的过程中，不断地解决问题，慢慢就可以从入门变成熟悉了 。</p><p>希望本文对您有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇《Go 学习：那些不一样的知识点（上）》中已经提到了 10 个 Go 语言中有特点的地方，本文继续介绍一些 Go 语言中语法或使用方式比较独特的知识点。&lt;/p&gt;
&lt;h2 id=&quot;11、切片类型&quot;&gt;&lt;a href=&quot;#11、切片类型&quot; class=&quot;headerlink&quot; title=&quot;11、切片类型&quot;&gt;&lt;/a&gt;11、切片类型&lt;/h2&gt;&lt;p&gt;同 Python 一样，Go 语言中也支持切片类型，而 C# 在 C# 8 中也增加了对数组进行切片操作的语法糖，先来看一个 C# 的例子：&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="golang" scheme="http://fwhyy.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习：那些不一样的知识点（上）</title>
    <link href="http://fwhyy.com/2022/09/go-learning-those-different-knowledge-points/"/>
    <id>http://fwhyy.com/2022/09/go-learning-those-different-knowledge-points/</id>
    <published>2022-09-26T00:20:20.000Z</published>
    <updated>2022-09-26T00:50:50.365Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 Go 语言的过程中，会涉及到语法、数据结构、和一些 Go 特有的东西，其中有不少现在还印象深刻，本文就说说 Go 语言中那些不一样的地方。</p><span id="more"></span><h2 id="1、变量和函数的声明"><a href="#1、变量和函数的声明" class="headerlink" title="1、变量和函数的声明"></a>1、变量和函数的声明</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> <span class="comment">//使用 var 关键字定义一个名为 name 的字符串类型变量</span></span><br><span class="line">name = <span class="string">&quot;oec2003&quot;</span> <span class="comment">//给变量赋值</span></span><br><span class="line"></span><br><span class="line">age:=<span class="number">18</span> <span class="comment">//使用 := 来定义变量，会自动进行类型推导，这种方式也是常用的方式</span></span><br><span class="line"></span><br><span class="line">fmt.Println(name,age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例是变量的声明方式，可以看到跟 C# 不同的是，类型是写在变量名之后的，而在 Go 中的函数也遵循这个原则：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello,&quot;</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的定义使用 func 关键字；</li><li>参数也是类型写在了参数名的后面；</li><li>函数的返回值写在了方法名的后面</li></ul><h2 id="2、不支持类型的隐式转换"><a href="#2、不支持类型的隐式转换" class="headerlink" title="2、不支持类型的隐式转换"></a>2、不支持类型的隐式转换</h2><p>为了提高代码的可读性和避免一些隐藏的错误，在 Go 中不支持类型的隐式转换。</p><p>在 C# 中下面的代码可以正常编译和运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int a = 18;</span><br><span class="line">    long b = a;</span><br><span class="line">    Console.WriteLine(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在 Go 中下面的代码是会有编译错误的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int16</span>=<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int32</span>=a</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int16 和 int32 之间不能隐式转换，只能进行显示转换，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int16</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int32</span> = <span class="keyword">int32</span>(a)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h2><p>为了提高生产力，避免在语言中犯错，Go 有很强的约束性，不支持前置 ++ 和 – ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">a:=10</span><br><span class="line">a++ //可以支持后置 ++ 和 --</span><br><span class="line">++a //不支持前置 ++ 和 --</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对数组的比较和 C# 也有区别，比如在 C# 中比较两个长度相同、值相同的数组，返回的是 False ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    int[] a = new[] &#123;1, 2, 3&#125;;</span><br><span class="line">    int[] b = new[] &#123;1, 2, 3&#125;;</span><br><span class="line">    Console.WriteLine(a==b); // 返回 False</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在 Go 中会有不一样的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">b := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(a == b) <span class="comment">// 长度相同、内容相同、值顺序相同 返回 ture</span></span><br><span class="line"></span><br><span class="line">b = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(a == b) <span class="comment">// 长度不同 返回 false</span></span><br><span class="line"></span><br><span class="line">b = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(a == b) <span class="comment">// 长度相同、内容相同、值顺序不相同 返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、map-的值可以是一个函数"><a href="#4、map-的值可以是一个函数" class="headerlink" title="4、map 的值可以是一个函数"></a>4、map 的值可以是一个函数</h2><p>Go 中的 map 和 C# 中的 Dictionary 有点像，map 的值可以是普通的数据类型外，也可以是一个函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aa</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> num * num</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;&#125;</span><br><span class="line">m[<span class="number">1</span>] = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a + b &#125;</span><br><span class="line">m[<span class="number">2</span>] = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a - b &#125;</span><br><span class="line">m[<span class="number">3</span>] = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a * b &#125;</span><br><span class="line">m[<span class="number">4</span>] = <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> a * b &#125;</span><br><span class="line"></span><br><span class="line">m[<span class="number">1</span>](<span class="number">12</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> m &#123;</span><br><span class="line">fmt.Println(f(<span class="number">12</span>, <span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果如下：</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">36</span></span><br></pre></td></tr></table></figure><h2 id="5、条件判断"><a href="#5、条件判断" class="headerlink" title="5、条件判断"></a>5、条件判断</h2><p>在 Go 中的条件判断也有 if 和 switch 两种。</p><p>if 可以支持在条件的表达式中进行变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;oec2003&quot;</span>, <span class="number">2</span>: <span class="string">&quot;fengwei&quot;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> v, isExist := m[<span class="number">2</span>]; isExist &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;不存在&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li> if 后的表达式分成了两段，第一段对变量进行赋值；第二段进行条件的判断，两段之间用分号分隔；</li><li>第二段的条件判断必须返回布尔值。</li></ul><p>switch 的使用也有些不一样的地方：</p><ul><li>单个 case 中可以支持多个值，用逗号分隔；</li><li>不需要显示添加 break 来退出 case；</li><li>switch 后可以不加任何表达式，就跟 if 类似了。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;system is mac&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;system is linux&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;其他&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似 if else</span></span><br><span class="line">name:=<span class="string">&quot;oec2003&quot;</span></span><br><span class="line"><span class="keyword">switch</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> name==<span class="string">&quot;oec2003&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;name is oec2003&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;name is undefine&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//case 后面支持多个值</span></span><br><span class="line">name := <span class="string">&quot;fengwei&quot;</span></span><br><span class="line"><span class="keyword">switch</span> name &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;oec2003&quot;</span>, <span class="string">&quot;fengwei&quot;</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;都是我的名字&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;不认识&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、循环"><a href="#6、循环" class="headerlink" title="6、循环"></a>6、循环</h2><p>在 Go 语言中，关键字非常少，因此，循环处理只有一个关键字 for  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于 C# 中的 while</span></span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    n++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于 C#中的 while(true)</span></span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;这是一个死循环&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于 C# 中的正常的 for</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于 C# 中的 foreach</span></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> v := <span class="keyword">range</span> a &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面使用一个关键字包含了 C# 中所有遍历的方式；</li><li>for 后面的表达式不需要写括号。</li></ul><h2 id="7、特别的-main-函数"><a href="#7、特别的-main-函数" class="headerlink" title="7、特别的 main 函数"></a>7、特别的 main 函数</h2><p>一个简单完整的 Go 程序如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello oec2003!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Go 的 main 函数没有返回值和参数，如果需要在 main 函数中使用参数，需要引入 os 包：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">//这里需要注意，第一个参数下标为 1</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;hello&quot;</span>, os.Args[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有的参数</span></span><br><span class="line"><span class="keyword">for</span> _, arg := <span class="keyword">range</span> os.Args &#123;</span><br><span class="line">fmt.Println(arg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>os.Args 是一个字符串的数组；</li><li>使用 range 可以用来遍历数组；</li><li>在 for中使用 _ 可以忽略第一个参数。</li></ul><h2 id="8、初始化函数"><a href="#8、初始化函数" class="headerlink" title="8、初始化函数"></a>8、初始化函数</h2><p>我们知道在 Go 语言中，main 函数是程序的入口函数，但 main 函数并不是第一个执行的函数，在 main 之前还有 init 函数会先被执行，在 init 函数中可以做一些初始化的工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;在这里做初始化工作&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;程序开始执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9、函数支持多返回值"><a href="#9、函数支持多返回值" class="headerlink" title="9、函数支持多返回值"></a>9、函数支持多返回值</h2><p>在 C# 中函数支持多返回值的方式有很多种，比如：返回一个对象、参数使用 out ，还有就是在 C# 7.0 添加的新功能元组，下面为 C# 中用元组的方式返回多值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Program</span><br><span class="line">&#123; </span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        var userInfo = GetUserInfo();</span><br><span class="line">        var name = userInfo.name;</span><br><span class="line">        var age = userInfo.age;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(name+age);</span><br><span class="line">    &#125;</span><br><span class="line">    static (string name, int age) GetUserInfo()</span><br><span class="line">    &#123;</span><br><span class="line">    return (&quot;oec2003&quot;, 18);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言的函数多返回值和 C# 的元组的方式比较像：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;oec2003&quot;</span>, <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name, age := getUserInfo()</span><br><span class="line">fmt.Println(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接收值时，如果某些值不需要，可以使用 _ 进行忽略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getUserInfo</span><span class="params">()</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;oec2003&quot;</span>, <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">name,_ := getUserInfo()</span><br><span class="line">fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10、函数延迟执行"><a href="#10、函数延迟执行" class="headerlink" title="10、函数延迟执行"></a>10、函数延迟执行</h2><p>在 Go 中使用 defer 关键字可以让函数延迟执行，可以用来做释放资源，释放锁等，先看下面的代码，</p><p>clear 函数前面添加了 defer 关键字，虽然在第 main 函数第一行，但会最后调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;清理资源&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> clear()</span><br><span class="line">fmt.Println(<span class="string">&quot;程序开始&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序执行结果为</span></span><br><span class="line">程序开始</span><br><span class="line">清理资源</span><br></pre></td></tr></table></figure><p>使用 panic 使程序崩溃，会发现被 defer 定义的函数依然会在最后执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clear</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;清理资源&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> clear()</span><br><span class="line">fmt.Println(<span class="string">&quot;程序开始&quot;</span>)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;程序崩溃啦&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序开始</span><br><span class="line">清理资源</span><br><span class="line"><span class="built_in">panic</span>: 程序崩溃啦</span><br></pre></td></tr></table></figure><p>这有点像是在 C# 中使用 try catch ，异常捕获之后，finally 块中的代码还是会被执行，我认为 Go 语言的这种处理更加灵活，以组合的方式来达到目的，这也符合 Go 语言的设计哲学。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在学习 Go 语言的过程中，会涉及到语法、数据结构、和一些 Go 特有的东西，其中有不少现在还印象深刻，本文就说说 Go 语言中那些不一样的地方。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="golang" scheme="http://fwhyy.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go 学习：从环境搭建到写一个 Web 服务</title>
    <link href="http://fwhyy.com/2022/09/go-learning-from-environment-building-to-writing-a-web-service/"/>
    <id>http://fwhyy.com/2022/09/go-learning-from-environment-building-to-writing-a-web-service/</id>
    <published>2022-09-19T00:20:20.000Z</published>
    <updated>2022-09-25T13:42:43.608Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了 Go 语言，做下记录。</p><h2 id="Go-的来历"><a href="#Go-的来历" class="headerlink" title="Go 的来历"></a>Go 的来历</h2><p>和 C、C++ 相比， Go 是一门很年轻的语言。2007 年，在 Google 的内部，有三位大佬因为 C++ 的复杂性、构建编译速度很慢和对并发支持不好等原因，便决定开发一门新的语言，于是他们基于 C 语言，做了功能的删减和新增，便有了 Go 的诞生。</p><span id="more"></span><p>2009 年 10 月 30 日，在 Google Techtalk 上，Go 语言的初始三位创始人之一的罗伯·派克做了一次关于 Go 语言的演讲，这也是 Go 语言第一次公开露面。十天后，谷歌正式宣布 Go 语言项目开源。</p><p>2012 年 3 月 28 日，Go 1.0 版本正式发布，同时 Go 官方发布了 “Go 1 兼容性” 承诺：只要符合 Go 1 语言规范的源代码，Go 编译器将保证向后兼容（backwards compatible），这给开发者带来了安全感。</p><h2 id="Go-的特点"><a href="#Go-的特点" class="headerlink" title="Go 的特点"></a>Go 的特点</h2><ul><li>只有 25 个关键字，主流编程语言最少；</li><li>内置垃圾收集，这是相比较 C 语言而言，（C# 和 Java 也有垃圾收集）；</li><li>方法或变量的首字母大小写决定可见性，无需通过额外的访问修饰符，太喜欢这个了；</li><li>内置接口类型，为程序的组合带来方便；</li><li>变量初始为类型零值，避免以随机值作为初值的问题；</li><li>函数或方法中的错误会通过 return 语句显式地返回，调用者不能忽略对返回的错误的处理；</li><li>内置数组边界检查，减少越界访问带来的安全隐患；</li><li>内置并发支持，简化并发程序设计，这也是很多人使用 Go 语言的一个原因；</li><li>为了提升可读性，Go 不支持默认函数参数。</li><li>每个类型有自己的方法集，类型定义和方法实现是独立的。</li></ul><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="https://golang.org/">https://golang.org</a> : Go 原来的官网，现在访问会跳转到 go.dev ;</li><li><a href="https://go.dev/">https://go.dev</a> :  Go 现在的官网；</li><li><a href="https://pkg.go.dev/">https://pkg.go.dev/</a> ：包管理；</li><li><a href="https://goproxy.cn/">https://goproxy.cn/</a> ：傲飞开发的 Go 模块代理站，现在由七牛云托管；</li><li><a href="http://goproxy.io/">http://goproxy.io/</a> : 李保坤开发的 Go 模块代理站。</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul><li>Mac：10.15.7</li><li>Go：1.19 ，目前最新的版本</li><li>VS Code：1.71.0</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1、在 <a href="https://go.dev/dl">https://go.dev/dl</a> 页面下载 Mac 版本的 pkg 安装文件：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252138347.png"></p><p>2、根据向导进行 Go 的安装，程序会安装到 /usr/local/go 目录中；</p><p>3、重启终端、输入命令 <code>go version</code> ，如果能正确显示版本号说明安装成功；</p><p>4、在 VS Code 中安装 go 扩展：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252138983.png"></p><p>5、在 VS Code 中敲 cmd+shift+p ，然后输入 Go:Install ，选择下图红框部分进行扩展工具的安装；</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252138893.png"></p><p>6、全选所有的扩展工具，点击确定，但这时通常会出现错误，不能正常安装，采用下面第七步的方式可以解决这个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252139757.png"></p><p>7、在 ~/.bash_profile 文件中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure><p>执行 <code>source ~/.bash_profile</code> 使配置生效，然后重新执行第六步的扩展工具安装。</p><p>8、到这环境就准备好了，可以开始写代码。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>1、在 go-study 目录中创建 helloworld 目录，go-study 是我用来学习 Go 语言存放代码的一个根目录；</p><p>2、使用 VS Code 打开 helloworld 目录，并在目录中创建 main.go 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;hello oec2003!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用 <code>go run main.go</code> 运行程序：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252139306.png"></p><h3 id="一个-web-服务"><a href="#一个-web-服务" class="headerlink" title="一个 web 服务"></a>一个 web 服务</h3><p>假设有这样一个场景：</p><p>零代码平台涉及到很多不同的服务和中间件，在客户服务器私有化部署时需要运维人员在服务器上进行各种配置才能搞定。</p><p>如果用 go 写一个 web 程序，通过界面的简单配置和 shell 脚本的相结合，可以打打降低部署的难度。</p><p>下面就来看看怎样来做这个简单配置的 web 程序。</p><p>1、创建 deploy-app 目录，在目录中创建 main.go 文件，内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;embed&quot;</span></span><br><span class="line"><span class="string">&quot;io/fs&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(getFileSystem()))</span><br><span class="line">ip, err := getLocalIP()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;启动成功，通过 http://&quot;</span> + ip + <span class="string">&quot;:10002 访问&quot;</span>)</span><br><span class="line"></span><br><span class="line">server := http.Server&#123;</span><br><span class="line">Addr: <span class="string">&quot;:10002&quot;</span>,</span><br><span class="line">Handler: <span class="literal">nil</span>,</span><br><span class="line">&#125;</span><br><span class="line">server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:embed wwwroot</span></span><br><span class="line"><span class="keyword">var</span> embededFiles embed.FS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileSystem</span><span class="params">(useOS <span class="keyword">bool</span>)</span> <span class="title">http</span>.<span class="title">FileSystem</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> useOS &#123;</span><br><span class="line"><span class="keyword">return</span> http.FS(os.DirFS(<span class="string">&quot;wwwroot&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">fsys, err := fs.Sub(embededFiles, <span class="string">&quot;wwwroot&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> http.FS(fsys)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLocalIP</span><span class="params">()</span> <span class="params">(ip <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    addrs, err := net.InterfaceAddrs()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">ipAddr, ok := addr.(*net.IPNet)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ipAddr.IP.IsLoopback() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ipAddr.IP.IsGlobalUnicast() &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ipAddr.IP.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>package ：定义名为 main 的包，包名为 main 的包为应用程序的入口包；</li><li>import ：导入需要使用的包;</li><li>go:embed : embed 是在 Go 1.16 中新加的功能，通过 //go:embed 指令，可以在编译阶段将静态资源文件打包进编译好的程序中，并提供访问这些文件的能力；</li><li>getLocalIP ：获取 IP 的一个函数；</li><li>server.ListenAndServe() ：使用该方法可以启动一个 http 的服务器监听。</li></ul><p>2、在 deploy-app 目录中创建 wwwroot 目录，在 wwwroot 中创建 idnex.html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>瞬翕云私有部署版<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>私有化部署<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;ant-typography&quot;</span>&gt;</span>访问地址设置<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>例：http://fwhyy.com、http://10.211.55.3:9000（支持设置 域名、域名+端口、IP+端口）<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>访问地址<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group mb-3&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-group-text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inputGroup-sizing-default&quot;</span>&gt;</span>http://<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Sizing example input&quot;</span> <span class="attr">aria-describedby</span>=<span class="string">&quot;inputGroup-sizing-default&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、使用 <code>go run main.go</code> 运行看看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252140037.png"></p><p>在浏览器中使用 <a href="http://192.168.1.7:10002/">http://192.168.1.7:10002</a> 进行访问，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252140450.png"></p><p>4、使用命令 <code>GOOS=linux GOARCH=amd64 go build main.go </code> 进行编译构建，构建完成后会在 deploy-app 目录中生成一个名为 main 的二进制文件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252140700.png"></p><p>5、将 main 文件拷贝到 CentOS 虚拟机中，使用 <code>./main</code> 命令运行，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252140905.png"></p><p>可以看到运行效果和本机运行的效果相同：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252140135.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、使用 embed 功能可以将静态资源打包到二进制的包中；</p><p>2、Go 语言编译后的是一个二进制文件，在服务器上不需要进行运行时的安装即可运行；</p><p>3、学习任何语言，语法部分可以通过刷刷力扣的题来进行熟悉，一个比较实用的小技巧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近学习了 Go 语言，做下记录。&lt;/p&gt;
&lt;h2 id=&quot;Go-的来历&quot;&gt;&lt;a href=&quot;#Go-的来历&quot; class=&quot;headerlink&quot; title=&quot;Go 的来历&quot;&gt;&lt;/a&gt;Go 的来历&lt;/h2&gt;&lt;p&gt;和 C、C++ 相比， Go 是一门很年轻的语言。2007 年，在 Google 的内部，有三位大佬因为 C++ 的复杂性、构建编译速度很慢和对并发支持不好等原因，便决定开发一门新的语言，于是他们基于 C 语言，做了功能的删减和新增，便有了 Go 的诞生。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="golang" scheme="http://fwhyy.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>时隔六年，软技能第二版来了</title>
    <link href="http://fwhyy.com/2022/09/after-six-years-the-second-edition-of-soft-skills-is-here/"/>
    <id>http://fwhyy.com/2022/09/after-six-years-the-second-edition-of-soft-skills-is-here/</id>
    <published>2022-09-13T00:20:20.000Z</published>
    <updated>2022-09-25T13:46:58.874Z</updated>
    
    <content type="html"><![CDATA[<p>《软技能》的第一版是 2016 年出版，当时读完这本书有种相见恨晚的感觉，随后便写了两篇读书笔记发布在博客中：</p><p><a href="http://fwhyy.com/2016/10/reading-soft-skills-agile-personal-management/">http://fwhyy.com/2016/10/reading-soft-skills-agile-personal-management/</a><br><a href="http://fwhyy.com/2016/10/Reading-soft-skills-learning-to-improve-productivity/">http://fwhyy.com/2016/10/Reading-soft-skills-learning-to-improve-productivity/</a></p><span id="more"></span><p>2018 年开通公众号后，又将之前的博客文章进行整理发到了公众号上，足以证明我对这本书的喜爱。</p><p>这本书让我们了解写代码之外的世界，包括健身、个人品牌打造、健身、理财等。这些技能的提升能让我们的工作和生活变得更加美好。</p><p>时隔六年，作者对这本书进行升级，发布了第二版，书的译者依然有王小刚，他曾经承诺只要作者还有软技能相关书籍出版，仍然会义无反顾担任翻译工作，现在看来，没有食言。</p><p>六年的时间，作者的生活、心态都发生了变化，带着新的思考修订了本书，删减了一些章节、也新增了不少章节，重要的是修改了部分章节的标题，也调整了一些章节的顺序，让读者更容易理解，这个变化相信也是作者成长的表现。</p><p>第二版中一共增加了 6 章，分别是：12、22、54、63、72、73 ，之前看过第一版的朋友可以先看看这些新增的部分。</p><p>第十二章：与老板和同事的相处之道</p><p>在工作中，一个很重要的点是沟通和协作，沟通和协作并不会总是顺畅的，可能同事很讨厌、可能领导做出的决定你持相反的意见，怎样能处理的让自己舒服，也让别人舒服，第 12 章的内容能给你一些启发。</p><p>第二十二章：在 YouTube 上创建自己的专栏</p><p>俗话说，一图胜千言，而视频相比较图片来说，更能有效地传播和个人品牌的建立，当然在国内如果没有更好的网络，上 YouTube 会有困难。不过国内有视频号、B 站等平台。</p><p>相比较写文章而言，视频的输出更加困难，需要会拍摄、剪辑，声音会出镜、甚至真人也会出现在视频中，但很多人会觉得自己的声音不好听；从容面对镜头也不是每个人都能做到；视频的制作也是有一定的门槛，这些都是进行视频输出的阻力。</p><p>我到现在也没敢去尝试，不过按照作者的说法，先去做，迈出这一步很重要，不需要一开始就是完美的，过程中不断改进。</p><p>第五十四章：如何创造真正的财富</p><p>作者的观点和纳瓦尔很相似，认为财富不等同于金钱，要善于投资，没钱时投资自己，使自己变得更强，等收入增加了可以投资一些能产生现金回报的项目。</p><p>关于财富，如果想要深入了解，建议可以阅读下《纳瓦尔宝典》。</p><p>第六十三章：我的减脂增肌秘诀</p><p>作者的秘诀非常的疯狂，一天只吃一顿，我其实不用提醒这种方式不要轻易尝试，一般人也做不到。作者书中也提到，如果想要尝试建议先咨询下医生。</p><p>减脂增肌不是目的，目的是有个健康的身体，让健康的饮食和运动成为生活的一部分，在我们拥有健康身体的同时顺带着就减脂增肌了。</p><p>第七十二章：走出舒适区</p><p>走出舒适区的一个阻碍是担心受挫，做一场技术分享，担心会冷场，听众不感兴趣；开始写博客，担心自己的观点不会被认可，遭受到别人言论的攻击，导致走不出那一步。</p><p>作者认为就算真的被人当成傻瓜，又能怎样？何况很多时候是我们自己的内心戏太足，别人可能根本没那么关注你的那些心里活动。</p><p>无惧失败，才能成功，乔丹说：“我失败了一次又一次，这就是我能成功的原因”。</p><p>第七十三章：斯多葛哲学，以及它如何改变你的生活</p><p>什么是斯多葛主义？</p><blockquote><p>1、怎样让你的价值最大化，并且不浪费你的生命去关注你无法掌控的事情<br>2、努力使我们成为最好的自己，专注我们可以去掌控的事情<br>3、好和坏都是对中性事件的不同解释，要彻底摆脱受害者心态<br>4、感受你的情绪，但不要被它左右和羁绊</p></blockquote><p>斯多葛主义是在改变我们的认知和对生活的态度，让他们能够更积极去面对工作和生活，但做出改变是不易的，多读书、多思考吧。</p><p>最后在翻看这本书时，发现第六十一章就是讲怎样获得完美腹肌，正好用的上，学到的一个非常重要的点是，除了常规的饮食控制和运动训练外，一定要有针对性地进行负重训练。</p><p>很值得看的一本书！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《软技能》的第一版是 2016 年出版，当时读完这本书有种相见恨晚的感觉，随后便写了两篇读书笔记发布在博客中：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://fwhyy.com/2016/10/reading-soft-skills-agile-personal-management/&quot;&gt;http://fwhyy.com/2016/10/reading-soft-skills-agile-personal-management/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://fwhyy.com/2016/10/Reading-soft-skills-learning-to-improve-productivity/&quot;&gt;http://fwhyy.com/2016/10/Reading-soft-skills-learning-to-improve-productivity/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="软技能" scheme="http://fwhyy.com/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
    <category term="书籍推荐" scheme="http://fwhyy.com/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
    <category term="成长" scheme="http://fwhyy.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>六块腹肌</title>
    <link href="http://fwhyy.com/2022/09/six-pack-abs/"/>
    <id>http://fwhyy.com/2022/09/six-pack-abs/</id>
    <published>2022-09-05T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:07.650Z</updated>
    
    <content type="html"><![CDATA[<p>去年九月，因送小孩开学时的一个闪念，便开始了连续 100 天的跑步计划，最终也顺利地完成了计划，体重减了不少，重要的是慢慢让坚持变成一种习惯。</p><p>今天九月，因为疫情的反复，女儿学校通知在家上网课，独自开车上班的我，又思考着要立 Flag 了，准备花一年的时间，练出 6 块腹肌。</p><span id="more"></span><p>腹肌，似乎每个男生都梦想过，但很少有人去付出行动，让他呈现出来。</p><p>对我来说，尽管有长期跑步的习惯，但从大学毕业后，体重就没有低过 145，所以说练出六块腹肌有非常大的挑战，甚至我觉得不太可能实现。不管最终的结果如何，通往这个结果的过程我认为是有收获和意义的。</p><p>孔子说过：「取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣」，意思就是要把目标定高点，有利于激发出我们的能力，即使达不到最终的目标，也不会太差。另外有一句英语「Jump for the Sun,at least,you will land on the Moon」说的也是这个意思。</p><p>为什么会有练腹肌的想法呢？</p><p>1、兴趣是最好的老师，首先是对腹肌有兴趣，是一直以来想要拥有但没能如愿的；</p><p>2、给每天重复的两点一线生活添点乐趣，也给以后的回忆留点内容，要知道，年龄越大越喜欢回忆；</p><p>3、腹肌不会自动浮现，过程中需要去践行的一些事我认为是正向的，能给小朋友以榜样。</p><p>一年的时间，如果没能很好的规划，一晃就过去了，所以还需要有一个大概的计划才行，计划也不用很细，太细的计划很难坚持。</p><p>再次重申一下，我看重的是这个过程，而不是结果，所以我的计划完全是凭借我的经验，很有可能是不科学甚至错误的。</p><p>我准备从三个方面入手：饮食控制、减脂、针对性的腹部训练。</p><p>饮食控制的一个基本原则是不影响正常生活。记得 2017 年为了减重，对饮食控制极为严格，同学聚会上也没有破例，结果非常不错，但不能长久，后来饮食恢复了，体重也就恢复了。</p><p>现在的想法有所改变，尽量地控制糖和油，晚餐尽量少吃，平时的家人朋友聚会、公司聚餐该吃吃、该喝喝，结束后加大运动量消耗掉就可以了。</p><p>慢慢的让一个健康的饮食习惯变成生活的一部分。</p><p>如果体脂率太高，即便有腹肌，也会藏在脂肪之下，是看不见的。减脂是很重要的一个环节，我 175 的身高，体重需要降到 140 左右才行，甚至更低，现在距离这个目标还有将近 20 斤，准备用半年到 9 个月的时间来达成。</p><p>减脂就做两个运动：跑步和 HIIT。</p><p>跑步是减脂很有效的一种方法，但如果身体适应了你的节奏和强度，就会进入平台期，2022 年，除了 7 月自驾 318 ，跑步给耽搁了，其他月份都完成了单月 100 公里的跑量，但体重没什么大的变化。</p><p>所以，在接下来的一年中会逐步增加跑量，并适当加些法特莱克跑，效果应该会不错。</p><p>HIIT 是高强度间歇训练，一周一两次，在 Keep 上随便找一个开始就行，重要的不是做哪一套 HIIT ，而是开始做。</p><p>练习腹部肌肉最常见的有仰卧起坐、西西里卷腹、两头起卷腹、俄罗斯转体，练习这些动作一个瑜伽垫就够了，而且不用等到减脂之后，现在就可以开始，并且持续下去。</p><p>另外，我家里还有单杠、杠铃、壶铃、健腹轮等健身器材，这些可以做一些辅助的训练，比如在单杠上可以做悬吊提膝、横向交叉摆腿等；在做俄罗斯转体时可以拿壶铃和杠铃片进行负重。</p><p>肌肉的训练需要劳逸结合才能发挥最大作用，网上很多人说腹部是耐受肌群，可以天天练，我持保留意见，再怎么耐受，过度地训练也会导致受伤，还是要根据身体的感受来做调节。</p><p>相信在一年后，能看见一个更好的自己；</p><p>相信在十年后，我对这一段经历还能记忆犹新。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年九月，因送小孩开学时的一个闪念，便开始了连续 100 天的跑步计划，最终也顺利地完成了计划，体重减了不少，重要的是慢慢让坚持变成一种习惯。&lt;/p&gt;
&lt;p&gt;今天九月，因为疫情的反复，女儿学校通知在家上网课，独自开车上班的我，又思考着要立 Flag 了，准备花一年的时间，练出 6 块腹肌。&lt;/p&gt;</summary>
    
    
    
    <category term="健身" scheme="http://fwhyy.com/categories/%E5%81%A5%E8%BA%AB/"/>
    
    
    <category term="健身" scheme="http://fwhyy.com/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>.NET Core 使用 LibreOffice 实现 Office 预览（Docker 部署）</title>
    <link href="http://fwhyy.com/2022/08/libreoffice-implements-office-preview/"/>
    <id>http://fwhyy.com/2022/08/libreoffice-implements-office-preview/</id>
    <published>2022-08-29T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:09.230Z</updated>
    
    <content type="html"><![CDATA[<p>前些年做云盘产品的时候，一个很核心的功能就是 Office 文件预览，当时还没有使用 .NET Core ,程序部署在 Windows Server 服务器上，文件预览的方案采用了微软的 OWA 。</p><p>目前在做的零代码产品中的表单附件控件，同样面临着 Office 文件预览的问题，现在技术栈采用了 .NET Core ，并使用容器化部署，自然就抛弃了 OWA 的方案。</p><p>本文简单介绍下 OWA 的替代方案。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、在表单的附件控件上传 Office 文件后，存储到 MongoDB 中，并发消息给文件转换程序；</p><p>2、文件转换程序从 MongoDB 获取 Office 文件，通过 Libreoffice 转换为 PDF 文件；</p><p>3、将 PDF 文件存储到 MongoDB 中，并将 PDF 文件在 MongoDB 中的 FileID 存储到平台和原始文件进行关联；</p><p>4、在表单中点击文件预览时使用关联的 PDF 的文件 ID 从 MongoDB 中获取 PDF 文件进行展示。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>1、创建一个 .NET Core 的控制台程序用来做文件的转换；</p><p>2、下载 Libreoffice 安装包、Libreoffice 中文语言包、jdk1.8 安装包 、中文字体包，这些文件我放在云盘了，可以访问这个链接下载：<a href="https://pan.baidu.com/s/131lLewbCvGDGLlZzYdSYNA">https://pan.baidu.com/s/131lLewbCvGDGLlZzYdSYNA</a> 提取码: 5aas</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208281754206.png"></p><p>3、搭建一台 centos 虚拟机，并准备好 docker 环境；</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>.NET Core：3.1</li><li>CentOS：7.6</li><li>Docker：</li><li>Liberoffice：7.3.5</li><li>RabbitMQ：3.8.2</li><li>MongoDB：5.0</li></ul><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="编写控制台程序进行文件转换"><a href="#编写控制台程序进行文件转换" class="headerlink" title="编写控制台程序进行文件转换"></a>编写控制台程序进行文件转换</h3><p>1、创建一个名为 OfficeToPdf 的 .NET Core 控制台程序，在 Main 方法中对消息队列进行监听；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)  </span><br><span class="line">&#123;  </span><br><span class="line">    try  </span><br><span class="line">    &#123;  </span><br><span class="line">        var mqManager = new MQManager(new MQConfig  </span><br><span class="line">        &#123;  </span><br><span class="line">            AutomaticRecoveryEnabled = true,  </span><br><span class="line">            HeartBeat = 60,  </span><br><span class="line">            NetworkRecoveryInterval = new TimeSpan(60),  </span><br><span class="line">            Host = EnvironmentHelper.GetEnvValue(&quot;MQHostName&quot;),  </span><br><span class="line">            UserName = EnvironmentHelper.GetEnvValue(&quot;MQUserName&quot;),  </span><br><span class="line">            Password = EnvironmentHelper.GetEnvValue(&quot;MQPassword&quot;),  </span><br><span class="line">            Port = EnvironmentHelper.GetEnvValue(&quot;MQPort&quot;)  </span><br><span class="line">        &#125;);        </span><br><span class="line">        if (mqManager.Connected)  </span><br><span class="line">        &#123;            </span><br><span class="line">        _logger.Log(LogLevel.Info, &quot;RabbitMQ连接成功。&quot;);  </span><br><span class="line">            _logger.Log(LogLevel.Info, &quot;RabbitMQ消息接收中...&quot;);  </span><br><span class="line">  </span><br><span class="line">            mqManager.Subscribe&lt;PowerPointConvertMessage&gt;(Convert);  </span><br><span class="line">            mqManager.Subscribe&lt;WordConvertMessage&gt;(Convert);  </span><br><span class="line">            mqManager.Subscribe&lt;ExcelConvertMessage&gt;(Convert);  </span><br><span class="line">        &#125;        </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">            _logger.Warn(&quot;RabbitMQ连接初始化失败,请检查连接。&quot;);  </span><br><span class="line">            Console.ReadLine();  </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;catch(Exception ex)  </span><br><span class="line">    &#123;        </span><br><span class="line">    _logger.Error(ex.Message);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在 Convert 方法中对消息进行处理，首先根据消息的中的文件 ID 获取文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Stream sourceStream = fileOperation.GetFile(officeMessage.FileInfo.FileId);  </span><br><span class="line">if(sourceStream == null)  </span><br><span class="line">&#123;  </span><br><span class="line">    logger.Log(LogLevel.Error, $&quot;文件ID：&#123;officeMessage.FileInfo.FileId&#125;，不存在&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">string filename = officeMessage.FileInfo.FileId;  </span><br><span class="line">string extension = System.IO.Path.GetExtension(officeMessage.FileInfo.FileName);  </span><br><span class="line">  </span><br><span class="line">sourcePath = System.IO.Path.Combine(Directory.GetCurrentDirectory(), filename + extension);  </span><br><span class="line">destPath = System.IO.Path.Combine(Directory.GetCurrentDirectory(), string.Format(&quot;&#123;0&#125;.pdf&quot;, filename));  </span><br><span class="line">  </span><br><span class="line">logger.Log(LogLevel.Info, $&quot;文件原路径：&#123;sourcePath&#125;&quot;);  </span><br><span class="line">logger.Log(LogLevel.Info, $&quot;文件目标路径：&#123;destPath&#125;&quot;);  </span><br><span class="line">if (extension != null &amp;&amp; (extension.Equals(&quot;.xlsx&quot;,StringComparison.OrdinalIgnoreCase) ||   </span><br><span class="line">                          extension.Equals(&quot;.xls&quot;, StringComparison.OrdinalIgnoreCase)))  </span><br><span class="line">&#123;  </span><br><span class="line">    if (!SetExcelScale(sourceStream, sourcePath))  </span><br><span class="line">        return false;  </span><br><span class="line">&#125;  </span><br><span class="line">else  </span><br><span class="line">&#123;  </span><br><span class="line">    byte[] sourceBuffer = new Byte[sourceStream.Length];  </span><br><span class="line">    sourceStream.Read(sourceBuffer, 0, sourceBuffer.Length);  </span><br><span class="line">    sourceStream.Seek(0, SeekOrigin.Begin);  </span><br><span class="line">    if (!SaveToFile(sourceBuffer, sourcePath))  </span><br><span class="line">        return false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、启用 LibreOffice 进行文件转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var psi = new ProcessStartInfo(  </span><br><span class="line">        &quot;libreoffice7.3&quot;,  </span><br><span class="line">        string.Format(&quot;--invisible --convert-to pdf  &#123;0&#125;&quot;, filename + extension))  </span><br><span class="line">    &#123;RedirectStandardOutput = true&#125;;  </span><br><span class="line">  </span><br><span class="line">// 启动  </span><br><span class="line">var proc = Process.Start(psi);  </span><br><span class="line">if (proc == null)  </span><br><span class="line">&#123;  </span><br><span class="line">    logger.Error(&quot;请检查 LibreOffice 是否成功安装.&quot;);  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">logger.Log(LogLevel.Info, &quot;文件转换开始......&quot;);  </span><br><span class="line">using (var sr = proc.StandardOutput)  </span><br><span class="line">&#123;  </span><br><span class="line">    while (!sr.EndOfStream)  </span><br><span class="line">    &#123;        Console.WriteLine(sr.ReadLine());  </span><br><span class="line">    &#125;    if (!proc.HasExited)  </span><br><span class="line">    &#123;        proc.Kill();  </span><br><span class="line">    &#125;&#125;  </span><br><span class="line">  </span><br><span class="line">logger.Log(LogLevel.Info, &quot;文件转成完成&quot;);</span><br></pre></td></tr></table></figure><p>4、文件转换成功后，存储转换后的 PDF 文件到 MongoDB，然后和原始文件进行关联，下面代码是调用了零代码平台中的接口进行处理，这里可以根据自己的业务需求自行修改 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string host = EnvironmentHelper.GetEnvValue(&quot;ApiHost&quot;);  </span><br><span class="line">string api = EnvironmentHelper.GetEnvValue(&quot;AssociationApi&quot;);  </span><br><span class="line">if (string.IsNullOrEmpty(api))  </span><br><span class="line">&#123;  </span><br><span class="line">    logger.Warn(&quot;请检查 AssociationApi 环境变量的配置&quot;);  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line">if (string.IsNullOrEmpty(host))  </span><br><span class="line">&#123;  </span><br><span class="line">    logger.Warn(&quot;请检查 ApiHost 环境变量的配置&quot;);  </span><br><span class="line">    return false;  </span><br><span class="line">&#125;  </span><br><span class="line">string result = APIHelper.RunApiGet(host, $&quot;&#123;api&#125;/&#123;fileId&#125;/&#123;destFileId&#125;&quot;);</span><br></pre></td></tr></table></figure><h3 id="构建-Libreoffice-基础镜像"><a href="#构建-Libreoffice-基础镜像" class="headerlink" title="构建 Libreoffice 基础镜像"></a>构建 Libreoffice 基础镜像</h3><p>1、在 centos 服务器上 /data 目录中创建目录 liberoffice-docker-build ,将上面提到的 Libreoffice 安装包、Libreoffice 中文语言包、jdk1.8 安装包 、中文字体包拷贝到该目录中；</p><p>2、在该目录中创建 Dockerfile 文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> yum update -y &amp;&amp; \</span></span><br><span class="line"><span class="bash">        yum reinstall -y glibc-common &amp;&amp; \</span></span><br><span class="line"><span class="bash">        yum install -y telnet net-tools &amp;&amp; \</span></span><br><span class="line"><span class="bash">        yum clean all &amp;&amp; \</span></span><br><span class="line"><span class="bash">        rm -rf /tmp/* rm -rf /var/cache/yum/* &amp;&amp; \</span></span><br><span class="line"><span class="bash">        localedef -c -f UTF-8 -i zh_CN zh_CN.UTF-8 &amp;&amp; \</span></span><br><span class="line"><span class="bash">        ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加入windows字体包</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> chinese.tar.gz /usr/share/fonts/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> LibreOffice_7.3.5_Linux_x86-64_rpm.tar.gz /home/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> LibreOffice_7.3.5_Linux_x86-64_rpm_langpack_zh-CN.tar.gz /usr/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行安装</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> /home/LibreOffice_7.3.5.2_Linux_x86-64_rpm/RPMS/ \</span></span><br><span class="line"><span class="bash">        &amp;&amp; yum localinstall *.rpm -y \</span></span><br><span class="line"><span class="bash">        &amp;&amp; <span class="built_in">cd</span> /usr/LibreOffice_7.3.5.2_Linux_x86-64_rpm_langpack_zh-CN/RPMS/   \</span></span><br><span class="line"><span class="bash">        &amp;&amp; yum localinstall *.rpm -y \</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line">        <span class="comment">#安装依赖</span></span><br><span class="line">        &amp;&amp; yum install ibus -y \</span><br><span class="line"></span><br><span class="line">        <span class="comment">#加入中文字体支持并赋权限</span></span><br><span class="line">        &amp;&amp; cd /usr/share/fonts/ \</span><br><span class="line">        &amp;&amp; chmod -R <span class="number">755</span> /usr/share/fonts \</span><br><span class="line">        &amp;&amp; yum install mkfontscale -y \</span><br><span class="line">        &amp;&amp; mkfontscale \</span><br><span class="line">        &amp;&amp; yum install fontconfig -y \</span><br><span class="line">        &amp;&amp; mkfontdir \</span><br><span class="line">        &amp;&amp; fc-cache -fv \</span><br><span class="line">        &amp;&amp; mkdir /usr/local/java/ \</span><br><span class="line"></span><br><span class="line">        <span class="comment">#清理缓存,减少镜像大小</span></span><br><span class="line">        &amp;&amp; yum clean all</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装java环境</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> jdk-8u341-linux-x64.tar.gz /usr/<span class="built_in">local</span>/java/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -s /usr/<span class="built_in">local</span>/java/jdk1.8.0_314 /usr/<span class="built_in">local</span>/java/jdk</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /usr/local/java/jdk</span><br><span class="line"><span class="keyword">ENV</span> JRE_HOME $&#123;JAVA_HOME&#125;/jre</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH .:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line"><span class="keyword">ENV</span> PATH $&#123;JAVA_HOME&#125;/bin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装 dotnet core 3.1 运行环境</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install -y  aspnetcore-runtime-3.1 \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum clean all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /usr</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/bash</span></span><br></pre></td></tr></table></figure><p>3、执行命令 <code>docker build -t libreofficebase:v1.0 .</code> 进行基础镜像的构建，构建好的基础镜像供文件预览镜像构建时使用。</p><h3 id="构建文件预览镜像"><a href="#构建文件预览镜像" class="headerlink" title="构建文件预览镜像"></a>构建文件预览镜像</h3><p>1、在 centos 服务器的 /data 目录中创建目录 doc-preview-docker-build ；</p><p>2、将转换程序 OfficeToPdf 进行编译发布，将发布后的文件拷贝到目录 doc-preview-docker-build 中；</p><p>3、在该目录中创建 Dockerfile 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM libreofficebase:v1 #此处的镜像就是上面构建的 Libreoffice 基础镜像</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">EXPOSE 80/tcp</span><br><span class="line">ENTRYPOINT [&quot;dotnet&quot;, &quot;OfficeToPdf.dll&quot;]</span><br></pre></td></tr></table></figure><p>4、执行命令 <code>docker build -t office-preview:v1.0 .</code> 进行预览镜像的构建。</p><h3 id="运行预览容器"><a href="#运行预览容器" class="headerlink" title="运行预览容器"></a>运行预览容器</h3><p>执行下面命令进行容器的创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name office-preview office-preview</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Office 预览肯定有很多种方案，上面只是目前找到的一种可行的方法，如果你有更好的 Office 文件预览方案，欢迎私信告诉我。</p><p>点击阅读原文，可以查看示例转换程序。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前些年做云盘产品的时候，一个很核心的功能就是 Office 文件预览，当时还没有使用 .NET Core ,程序部署在 Windows Server 服务器上，文件预览的方案采用了微软的 OWA 。&lt;/p&gt;
&lt;p&gt;目前在做的零代码产品中的表单附件控件，同样面临着 Office 文件预览的问题，现在技术栈采用了 .NET Core ，并使用容器化部署，自然就抛弃了 OWA 的方案。&lt;/p&gt;
&lt;p&gt;本文简单介绍下 OWA 的替代方案。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term=".NET" scheme="http://fwhyy.com/tags/net/"/>
    
    <category term="LibreOffice" scheme="http://fwhyy.com/tags/libreoffice/"/>
    
    <category term="预览" scheme="http://fwhyy.com/tags/%E9%A2%84%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>读《纳瓦尔宝典》</title>
    <link href="http://fwhyy.com/2022/08/nawal-treasure-book/"/>
    <id>http://fwhyy.com/2022/08/nawal-treasure-book/</id>
    <published>2022-08-22T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:14.691Z</updated>
    
    <content type="html"><![CDATA[<p>最早是在量贩冰糖的播客听到介绍《纳瓦尔宝典》这本书，播主写了这本书的推荐序，另一篇推荐序是樊登写的，当时就想马上樊登读书应该会讲这本书了，果不其然，在我快看完的时候，樊登读书就推出了。</p><p>下面就看看这本书都讲了些什么。</p><span id="more"></span><p>1、这本书的作者纳瓦尔是印度人，后来移民到了美国，成为了创业者和投资人，投资过推特和优步，读过很多的书，非常喜欢思考，在推上发了很多的独到见解，这本书就是源于推文的整合。</p><p>2、财富与幸福指南是本书的副标题，这是非常讨人喜欢的一个副标题。全书也是围绕着财富和幸福进行展开。</p><p>3、财富不是指金钱，而是指在我们睡着后，还能继续给我们创造金钱的东西，也就是我们常说的「睡后工资」，像房子可以出租；出版的书籍在很多年后还能收到版税等等都是财富，我们应该追求财富而不是金钱。</p><p>4、估计很多人和我一样，靠时间来赚钱，这种就不属于有「睡后工资」，一旦没有工资收入，就会面临很大的压力，做产品、企业也是同样的道理。</p><p>5、想要做到有「睡后工资」需要各方面提升自己的能力，首先找到自己的兴趣所在，因为只有真正有兴趣的东西才能使你有内驱力，每天都充满干劲；再就是要关注新的、前沿的东西，这样就有可能找到新的机会、或者已经存在的红海中缝隙中的蓝海。</p><p>6、关于提升能力，纳瓦尔认为需要将自己产品化，对自己来说，需要思考自己有哪些特长？有什么独特的价值？产品化就是提供标准，能够大批量复用，这样才能将价值最大化。</p><p>7、企业如果做传统的项目实施，假设 10 个人能做 500 万，那么想要做 1000 万，就需要更多的人，更多的人就会带来更多的问题，沟通成本、管理成本都会增加，这样会累死。如果将产品进行 SaaS 化，那就可以进行复制，10 个客户和 1 个客户没有很大的区别，因为产品只需要维护一套。</p><p>8、对企业来说，做边际成本越小的事情越赚钱，上面的例子中 SaaS 化的产品就是企业边际成本为零的载体，对个人来说，这个载体可以是代码、书籍、专利、自媒体等。在这些载体上深耕、让其发展壮大，终有一天会成为撬动财富的有力杠杆。</p><p>9、当有一些想法和点子后，迅速采取行动，并对结果保持耐心。为什么要迅速采取行动，因为开始做一件事情最好的时间一个是十年前，另一个就是现在。</p><p>10、开始行动了，还有另一个阻力，就是每天坚持。对于坚持，一种方法就是广而告之，让身边的人都知道。 就像我坚持跑步，也是朋友圈树立 Flag、在一些运动群打卡，以此来起到监督的作用，去年坚持连续 100 天每天跑步 5 公里也是用的这个方法，至少对我来说挺有用的。</p><p>11、时间的投入是必需的，但判断力更重要。在前进的过程中，方向比速度重要，特别是运用了杠杆以后。在每个岔路口选对方向，其重要程度要远远超过前进的努力程度。人生就是选择正确的方向，然后朝这个方向奋力前行。团队协作也是如此，每个人都很努力，但方向不一致，团队还是会停留在原地。</p><p>12、我们不应该一直穿着衣服来保持身体的温度，而应该不时接触冷空气，因为寒冷可以激活人体的免疫系统。温暖的身体就是我们的舒适圈，工作中也是如此，我们应该时不时在圈子的边缘游走，主动去发现问题，然后解决它。</p><p>13、纳瓦尔认为时间比金钱更重要，比朋友更重要，比什么都重要。我们要珍惜自己的时间，时间对每个人是公平的，但我们却可以有很多方式来“延长”时间，比如：早起、做事三思后行、使用一些效率工具等。</p><p>14、想要幸福，就需要先给幸福下个定义，有人可能觉得知足常乐、小富即安是幸福；有人可能觉得幸福是欲望得到了满足，所以讨论幸福之前要先想想自己想要的是什么。</p><p>15、很多人应该都讨论过财务自由，并将实现财富自由为奋斗的目标。之前在网上看到有人说在北京实现财务自由需要 2000 万，也有人说可能还远远不够。那么有了这些钱之后做什么呢？提前退休？去做想做的事情？现在认为的自己想做的事情一定是真的想做的吗？就一定是自由的吗？我认为这些是值得去思考的。</p><p>16、退休的常规定义就是不上班，而纳瓦尔认为退休就是不再为了想象中的明天而牺牲今天。当你能活在当下，内心充盈地度过每一天时，你就达到了退休的状态，我们可以想想，我们每天是不是这样的状态呢？</p><p>17、再好的东西，我们也会很快就习惯了，它们无法再带来刺激或愉快的感觉了。涨工资也是一样的道理，兴奋几天后，就会觉得是理所应当的了。所以必须寻找我们正在做的事情的内在的价值和意义。</p><p>18、我们在工作和生活中会碰到很多的问题和事情，有时会给我们带来不好的情绪，如果可以从长远角度冷静客观地看待，很多问题其实并不是问题。人生需要做减法。</p><p>19、纳瓦尔很喜欢读书，也倡导大家多读书，读书的唯一原因应该是喜欢，不需要其他任何理由。不要把读书当成一项任务，读书就是因为乐在其中。这个道理我可以跟我女儿讲讲。想象一个场景，冬日的午后，晒着暖暖的阳光，一杯咖啡，一本书，不带目的地看着，这不就是一种幸福吗？</p><p>20、回到终极问题，生命的意义是什么？之前看到过一个回答，生命本身没有意义，但寻找意义的过程是有意义的。最后，希望每个人都能幸福地拥有着财富，过着有意义的一生。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最早是在量贩冰糖的播客听到介绍《纳瓦尔宝典》这本书，播主写了这本书的推荐序，另一篇推荐序是樊登写的，当时就想马上樊登读书应该会讲这本书了，果不其然，在我快看完的时候，樊登读书就推出了。&lt;/p&gt;
&lt;p&gt;下面就看看这本书都讲了些什么。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书笔记" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="成长" scheme="http://fwhyy.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>又解锁一款笔记工具：Logseq</title>
    <link href="http://fwhyy.com/2022/08/unlock-another-note-taking-tool-logseq/"/>
    <id>http://fwhyy.com/2022/08/unlock-another-note-taking-tool-logseq/</id>
    <published>2022-08-15T00:20:20.000Z</published>
    <updated>2022-09-25T13:46:39.572Z</updated>
    
    <content type="html"><![CDATA[<p>我很喜欢去尝试使用一些新的工具，解决一些当下的问题，所以工具永远没有最好，只有最合适，最近一直在使用的 Obsidian 是在范冰的播客中知道的，通过范冰我还知道了另一个笔记工具，也就是今天的主角：Logseq 。</p><span id="more"></span><p>Logseq 跟 Obsidian 一样，也是本地存储，现在对本地存储越来越关注了，新尝试的笔记工具如果不是本地存储，就直接 Pass 了。Logseq 也是开源的，而且现在迭代速度很快。</p><p>为什么使用 Logseq ，因为我在平时的工作中有一些这样的场景：</p><p>1、每天会有当天需要处理的一些事项；</p><p>2、临时会有一些重要不紧急的事项插入进来，暂时还没有 deadline ；</p><p>3、有些事情是能确定具体哪天再做；</p><p>4、边看电子书边记录笔记。</p><p>之前用过一段时间 Notion 的日历，因为 Notion 是 All in one 嘛，所以就希望在一个工具中完成所有事情，后来发现不是很好用，需要在每天中去创建 Page ，然后进行内容的输入，而且在日历界面中不能看到内容明细，更不用说内容项的状态。</p><p>在 Obsidian 中默认就有日志的功能，在核心插件中开启就可以使用了，搭配 Calendar 插件可以方便进行切换，再加上 rollover daily todos 插件可以实现自动将前一天没有处理完的待办事项添加到新创建的日志中。但每天的日志需要点击才能创建，并且对于一些重要不紧急的事情，会一直显示在每天的日志中，随着时间的增长，会越来越多，不方便管理。</p><p>而 Logseq 可以很好解决上面的问题。</p><p>打开 Logseq 默认就在日志界面，每天第一次打开会自动创建一个当天日期的页面，所有的日志页面都汇聚在左边的日志菜单中，可以往下滚动查看之前的内容，这点比 Obsidian 要方便很多。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141441974.png"></p><p>在一个事项的后面输入斜杠，就会出现弹框提示，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141441021.png"></p><ul><li>LATER：重要不紧急的事情可以打上这个标记；</li><li>NOW：当天需要处理的事项，只会显示在当天；</li><li>TODO：当天的待办事项，只会显示当当天；</li><li>DOING：进行中的事项，会显示在记录当天的日志和最新的日志中。</li></ul><p>除了上面四个我常用的标记外，输入斜杠选择 Date picker ，可以选择一个日期，等到了这个日期后，会出现这个日期日志的 Linked Reference 中：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141442507.png"></p><p>通过这样几个任务的标记，就能很方便在当天日志中记录各种类型的日志了，比如：</p><ul><li>使用 Date picker 设置了日期的任务，到了时间就会出现在当天的日志中；</li><li>将标记切换为 DOING ，这个任务就会持续出现在每天的日志中，直到完成。</li></ul><p>但还是有个问题，标记为 LATER 的事项，只会在记录的当天显示，那后面怎么去找这些事项呢？这就需要用到 Logseq 的 Query 查询功能。</p><p>我新创建了一个空白页面叫「我的事项」，使用 Query 分别查出进行中、待处理、已完成的事项，当然你也可以根据自己的需要进行组合查询：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141442321.png"></p><ul><li>进行中：query (todo doing)</li><li>待处理：query (todo later)</li><li>已完成：query (todo done)</li></ul><p>Query 查询出来的结果也是按照时间的顺序排列，可以在待处理中找到优先级高的事项，将标记切换为 DOING ，这样在每天的日志中又会出现了。</p><p>在 Logseq 中写作，没有压力，不用想在哪里写，也不用想写好的内容归类到什么目录，打开就在日志界面，只管写就可以，在做内容回顾时，可以使用双中括号来添加页面，或者用井号来添加 Tag ,这样就建立双向链接了。</p><p>例如，最近在进行招聘，每天会收到人事筛选的简历，我记录到每天的日志中，当我给招聘加上双中括号，Logseq 就是自动创建一个「招聘」的页面，并将内容关联起来。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141442773.png"></p><p>点击上图中的「招聘」，就会进入到招聘页面，内容按照时间顺序，以块的形式组织：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141442342.png"></p><p>在 Logseq 中还有一个功能特别喜欢，那就是 PDF 预览，可以直接将 PDF 文档拖入编辑区域，点击文档名称，在左侧会打开 PDF 的预览界面：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141442409.png"></p><p>选择 PDF 文档中的文本可以进行颜色的标记，也能复制文本的引用到右侧的笔记内容中，如上图，会带上页码和相关内容。点击引用的内容，会直接定位到具体的位置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202208141442404.png"></p><p>如果你之前使用过幕布或 Workflowy ，会觉得 Logseq 非常熟悉，因为 Logseq 也是大纲类的展示，这种展现形式写正式的文章不太适合，但针对我目前使用的一些场景就非常实用和方便了。</p><p>以前，一直想使用 All in one 的工具，现在想法改变了，我觉得一个工具能专注做好一件事就已经很牛逼了，什么都想做，可能就什么都做不好，反而不能让用户喜欢。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我很喜欢去尝试使用一些新的工具，解决一些当下的问题，所以工具永远没有最好，只有最合适，最近一直在使用的 Obsidian 是在范冰的播客中知道的，通过范冰我还知道了另一个笔记工具，也就是今天的主角：Logseq 。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="logseq" scheme="http://fwhyy.com/tags/logseq/"/>
    
    <category term="笔记" scheme="http://fwhyy.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读《华为数字化转型之道》</title>
    <link href="http://fwhyy.com/2022/08/huawei-approach-to-digital-transformation/"/>
    <id>http://fwhyy.com/2022/08/huawei-approach-to-digital-transformation/</id>
    <published>2022-08-08T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:16.010Z</updated>
    
    <content type="html"><![CDATA[<p>数字化转型应该很多人都听过，但如果你做过 ToB 软件，听得更多的是信息化，那信息化和数字化是什么关系呢？</p><p>下面用一个小例子来说说我的理解。</p><span id="more"></span><p>记得刚上初中的时候，平时测验、考试的试卷，都是人工在刻板上进行刻写题目，然后用油墨进行印刷，这就是最原始的纸质化办公。</p><p>后来条件好了，有了电脑，老师可以在 Word 中进行试题的编辑，复印多份，给整个班的学生使用，这就是电子化。</p><p>每一份试卷都让老师人工编辑，还是效率太低，这时采购一套系统，可以自动生成试题，连接打印机进行打印，或者在线做题，这就是信息化。</p><p>再进一步，将在线答题的结果数据，进行统计分析，知道每个人的薄弱点，可以有针对性进行辅导，了解什么类型的题普遍易错，可以优化后续的教学方案，这就是数字化。</p><p>我们常见的信息化不会改变企业的流程，但可以提高效率（上面例子中自动化出题代替人工）；而数字化对企业的商业模式，流程起到指引作用（上面例子中对数据分析后的后续动作），这是一种管理经营的思维模式，也是未来的一种趋势。</p><p>当然了，上面只是一个例子，真正的数字化并非如此简单。但有一本书把数字化转型的本质、方法论、实践讲得非常清楚，那就是《华为数字化转型之道》。</p><p>互联网企业已经从增量进入到了存量阶段，需要找到新的突破；传统企业在后疫情时代想要能很好地存活，也需要寻找新的方向。或许进行数字化转型是一条不错的出路。这本书是华为对过去自己做数字化转型的经验总结，我们可以结合自己企业的业务、流程等，从中获取宝贵经验，少走弯路。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252122765.jpeg"></p><p>全书分为认知篇、方法篇、实践篇和平台篇四个大的板块：</p><ul><li><strong>认知篇</strong>: 首先是讲述为啥要进行数字化转型，重点突出了数据是核心要素，可以通过数据的分析和处理来进一步识别客户的需求，找到新的机会。提出一套方法、四类场景和三个平台能力的转型框架，从转型底层支撑、业务重构进行全面讲解。</li><li><strong>方法篇</strong>：<ul><li>首先是要进行转型的规划，总结下来就是三阶十二步法，先要描绘数字化的愿景，再进行架构的设计，最后定落地方式，包括识别关键点、应该做哪些项目、以及项目的优先级；</li><li>印象比较深的就是用产品思维来管理 IT，对比了信息化和数字化的区别，并提到如何从各个阶段进行进行转化；</li></ul></li><li><strong>实践篇</strong>：从数字化转型的关键是业务的重构，书中从业务运作模式、交易、运营、办公等全面介绍华为在这些方面是如何去做的。</li><li><strong>平台篇</strong>：在数字化转型过程中需要有底层的支撑，比如数据本身、数据平台、和企业在进行变革过程中遇到一系列问题需要的解决方法，这些在平台平台篇都会涉及到。</li></ul><p>现在大部分企业在信息化建设的过程中都积累了大量的 IT 系统，互相之间的关系越来越复杂，IT 部门和业务部门之间也会有一道不可逾越的鸿沟，业务部门嫌 IT 不懂业务，IT 则吐槽业务部门需求变化快。</p><p>在数字化转型过程中，IT 系统不再是固化流程的工具，业务的任何需求变化都需要 IT 系统能够快速响应，传统的方式响应速度慢，成本高，而零代码平台正好能够解决这些问题。</p><p>Forrester 和 Gartner 数据称，预计到2023年，全球会有超过 50% 的大中型企业将把低代码应用平台作为其主要战略应用平台之一。预计到 2024 年，低代码产生的应用程序将占市场总体应用程序的 65% 以上。</p><p>零代码平台在功能上应该如何规划和演进？应该怎样更好地支持业务落地？</p><p>我们以前都是根据客户的功能性的反馈、实施过程中遇到的问题和对市场的分析，那么学习企业的数字化转型，会给更好地完善零代码产品带来新的思路，比如：</p><ul><li>是不是可以增加数据处理的引擎？</li><li>是不是可以跟市面上主流的数据平台提供内置集成？</li><li>在易用性上是不是要考虑到不怎么了解技术的业务人员？</li></ul><p>最后想说的是，不管是甲方企业的管理人员，还是软件公司的管理、技术人员都可以看看本书，肯定会有所收获。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数字化转型应该很多人都听过，但如果你做过 ToB 软件，听得更多的是信息化，那信息化和数字化是什么关系呢？&lt;/p&gt;
&lt;p&gt;下面用一个小例子来说说我的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书笔记" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数字化" scheme="http://fwhyy.com/tags/%E6%95%B0%E5%AD%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>微服务：事务管理</title>
    <link href="http://fwhyy.com/2022/08/microservices-transaction-management/"/>
    <id>http://fwhyy.com/2022/08/microservices-transaction-management/</id>
    <published>2022-08-01T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:04.315Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有的信息管理系统都会涉及到事务，事务的目的是为了保证数据的一致性，这里说的一致性是数据库状态的一致性。</p><p>说到数据库状态的一致性，相信大家都会想到 ACID ：</p><ul><li><p>原子性（Atomic）：在一个事件的多个数据库操作中，要么同时成功，要么同时失败，例如：转账业务；</p></li><li><p>隔离性（Isolation）：不同的业务之间处理数据相互独立，互不影响</p></li><li><p>持久性（Durability）：正常提交的数据能够被持久化，不丢失数据，比如 mysql 天然就能持久化，redis 、 rabbitmq 也能通过设置进行持久化；</p></li><li><p>一致性（Consistency）：最终的数据正确，所以说是通过 AID 这些手段来保证了 C 。</p></li></ul><span id="more"></span><p>在单体架构中，通常是一套程序对应一个数据库，事务基于数据库本身的能力,如果你在 .NET Core 中使用 dapper 或 sqlsugar ，可以很容易进行事务的处理，可以参考下面文档：</p><p><a href="https://dapper-tutorial.net/transaction">https://dapper-tutorial.net/transaction</a><br><a href="https://www.donet5.com/Home/Doc?typeId=1183">https://www.donet5.com/Home/Doc?typeId=1183</a></p><p>但是，在微服务架构，分布式的场景中，事务的处理就会变得复杂，会存在多个节点，多个节点的同步、可用性等都是需要考虑的问题，在分布式中有一个著名的 CAP 理论：</p><ul><li><p>C：数据一致性（Consisitency）：分布式中存在多个节点，对某个指定的客户端来说，从任一节点读取数据保证能够获取到最新的写操作结果；</p></li><li><p>A：可用性（Acailability），非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）</p></li><li><p>P：分区容错性（Partition Tolerance），节点之间的数据传递是基于网络的，由于网络本身不是 100% 可靠，极端情况下会出现网络不可用的情况，进而将网络两端的节点分隔开来，这就是所谓的「网络分区」现象。在出现网络分区时，两部分的数据是不一致的，如果要保证数据的一致性，就必须要让没有及时同步数据的节点变为不可用，这就牺牲了可用性，否则就会牺牲一致性，所以在 P 一定存在的情况下，需要在 C 和 A 中间做取舍。</p></li></ul><p>我们在 CAP、ACID 中讨论的一致性称为「强一致性」（Strong Consistency），而把牺牲了 C 的 AP 系统，但又要保证最终的结果的一致性，称为「弱一致性」，也叫最终一致性。最终一致性的概念由 eBay 的系统架构师丹 · 普利切特（Dan Pritchett）在 2008 年发表于 ACM 的论文「Base: An Acid Alternative」中提出的。</p><p>本文主要说下保证一致性的几种方式：TCC、SAGA 和消息队列。</p><h2 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h2><p>TCC 是 Try-Confirm-Cancel 的缩写，分为了三个阶段：</p><ul><li><p>Try：一个请求涉及到多个服务，多个服务会同时进行 Try，这个阶段为尝试执行阶段，在这个阶段中会进行数据的校验、检查，保障一致性，并准备资源，都成功会进入到 Confirm 阶段；</p></li><li><p>Confirm：确认执行阶段，不进行任何业务检查，多个服务的 Try 都执行成功了，多个服务都进入到 Confirm 阶段，在这个阶段直接使用 Try 阶段准备的资源来完成业务处理。<strong>注意，Confirm 阶段可能会重复执行，因此需要满足幂等性。</strong></p></li><li><p>Cancel：如果在 Try 阶段有一个服务没有成功，那么所有的服务都进入到 Cancel 阶段，在该阶段，释放 Try 阶段预留的业务资源。<strong>注意，Cancel 阶段也可能会重复执行，因此也需要满足幂等性。</strong></p></li></ul><p>在 .NET Core 中可以参考：</p><p><a href="https://github.com/simpleway2016/JMS">https://github.com/simpleway2016/JMS</a></p><p>在 Java 中可以使用 seata：</p><p><a href="https://github.com/seata/seata">https://github.com/seata/seata</a><br><a href="https://seata.io/zh-cn/">https://seata.io/zh-cn/</a></p><p>因为在 TCC 中的第一步 Try 需要预留资源，进行检查和校验，但在某些场景下，资源不是我们所能控制的，比如支付中，余额是银行管理的，我们通常没有权限。所以这时就不太适合 TCC ，可以考虑用 SAGA 来代替 TCC。</p><h2 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h2><p>SAGA 起源于 1987 年普林斯顿大学的赫克托 · 加西亚 · 莫利纳（Hector Garcia Molina）和肯尼斯 · 麦克米伦（Kenneth Salem）在 ACM 发表的一篇论文《SAGAS》。</p><p>SAGA 和 TCC 最大的区别是基于数据补偿机制来代替回滚。一个 SAGA 表示处理多个服务中数据的一系列操作，由一连串的本地事务组成，每个独立的本地事务中还是能够使用 ACID 。</p><p>SATA 由两部分组成：</p><ul><li>将一个大的事务拆分成的若干个小的事务，比如一个大的事务 T ，拆分成 T1、T2、T3;</li><li>每一个子事务有对应的补偿动作,例如对应上面的 T1、T2、T3 有 C1、C2、C3 的补偿动作。</li></ul><p>在 ACID 中如果出现异常，可以很容易进行回滚，但 SAGA 没办法自己回滚，必须依赖补偿动作来进行回滚。</p><p>如果 T1、T2、T3 都提交成功了，整个事务 T 就提交成功，如果执行 T2 时出现异常，这时有两种方式进行处理：</p><p><strong>正向（不断重试）</strong>：不断对 T2 进行重试操作，直到成功（不排除人工干预），等 T2 重试成功后，继续执行后面的 T3；</p><p><strong>反向（补偿）</strong>：T2 出现异常时，执行对应的补偿 C2，C2 必须执行成功（不排除人工），然后执行 T1 对应的补偿动作 C1 。</p><p>在上面提到的 seata 中也同样可以支持 SAGA 模式。</p><p>除了 seata ，还有一个用 go 语言写的 DTM 分布式事务框架也不错：</p><p><a href="https://dtm.pub/">https://dtm.pub/</a><br><a href="https://github.com/dtm-labs/dtm">https://github.com/dtm-labs/dtm</a></p><p>而且，DTM 支持 C# 客户端：</p><p><a href="https://github.com/dtm-labs/dtmcli-csharp">https://github.com/dtm-labs/dtmcli-csharp</a></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列相信大家都不陌生，我们零代码产品中调用外部接口的组件，会被用在一些复杂的业务逻辑编排中，对外部接口的调用就是使用消息队列，RabbitMQ 的延时队列加上死信队列可以来进行重试的操作，来保证数据的最终一致。</p><p>还有另一种方式就是使用事务消息表，比如有这样一个场景，在系统列表中删除一条流程数据，这时需要做：</p><p>1、列表服务中对数据进行删除；</p><p>2、文件服务对这条数据相关的附件进行删除；</p><p>3、流程服务对该业务数据的所有流程信息进行删除。</p><p>具体的步骤如下：</p><p>1、列表服务删除数据成功后，在数据库中创建一张事务消息表，该表中记录事务 ID、数据删除成功的状态、业务数据 ID、附件待删除的状态、流程信息待删除的状态等；</p><p>2、列表服务删除数据成功后，发送消息分别进行附件删除处理和流程信息删除处理；</p><p>3、消息被正确处理后，修改事务消息表的状态；</p><p>4、创建一个单独的消息服务程序，轮询扫描事务消息表，如果发现状态没有变成已完成，就重新发送一个新的消息，这样附件删除和流程信息删除就会进行多次执行，这也要求这些操作必须是幂等的。</p><p>RabbitMQ 本身不支持分布式事务，不过有一些消息中间件是支持的，例如：RocketMQ，原生就支持分布式事务操作，可以更方便进行事务处理。</p><p>本文是一些理论的梳理，要想更彻底地掌握，可以选择一个框架，找几个场景，写写代码演练一下。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;几乎所有的信息管理系统都会涉及到事务，事务的目的是为了保证数据的一致性，这里说的一致性是数据库状态的一致性。&lt;/p&gt;
&lt;p&gt;说到数据库状态的一致性，相信大家都会想到 ACID ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原子性（Atomic）：在一个事件的多个数据库操作中，要么同时成功，要么同时失败，例如：转账业务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离性（Isolation）：不同的业务之间处理数据相互独立，互不影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;持久性（Durability）：正常提交的数据能够被持久化，不丢失数据，比如 mysql 天然就能持久化，redis 、 rabbitmq 也能通过设置进行持久化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性（Consistency）：最终的数据正确，所以说是通过 AID 这些手段来保证了 C 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="微服务" scheme="http://fwhyy.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="架构" scheme="http://fwhyy.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>三个人一台车自驾西藏</title>
    <link href="http://fwhyy.com/2022/07/three-people-and-one-car-driving-in-tibet/"/>
    <id>http://fwhyy.com/2022/07/three-people-and-one-car-driving-in-tibet/</id>
    <published>2022-07-26T00:20:20.000Z</published>
    <updated>2022-09-25T13:46:41.385Z</updated>
    
    <content type="html"><![CDATA[<p>一直都有去西藏的想法，去年换了坦克 300，自驾 318 便提上了日程。7 月小孩放暑假，同时领导也批准了我较长时间的请假。于是三个人，一台车，7 月 9 号开始了自驾之旅。</p><span id="more"></span><p>整个行程如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252113784.png"></p><h2 id="旅行前准备"><a href="#旅行前准备" class="headerlink" title="旅行前准备"></a>旅行前准备</h2><p>1、驾驶证、行驶证、身份证各种证件要带齐；</p><p>2、备少量的零钱即可，基本上所有地方都能扫码支付，但在山顶上手机可能没有信号；</p><p>3、之前看网上的攻略说即便是七八月份也需要带比较厚的衣服，但一路走来没有感觉到特别冷的时候，整个旅行中几乎都是短裤、短袖和拖鞋，一个薄外套是为了防晒；</p><p>4、各种药品（高反、肠胃、感冒等）还是需要备着，不一定用的上；</p><p>5、防晒相关一定要准备齐全，高原上的太阳太厉害了，第一天穿短袖开车，左手臂晒伤了；</p><p>6、食物有必要准备自热食品，有时吃饭的时间是在山上；</p><p>7、功能性饮料（红牛）很有必要，全程是我一个人在开车，每天一到两罐，没觉得困过。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252113916.png"></p><h2 id="关于防疫政策"><a href="#关于防疫政策" class="headerlink" title="关于防疫政策"></a>关于防疫政策</h2><p>1、疫情每天都在动态变化着，防疫政策是也在变化的，实时关注就好；</p><p>2、从湖北到重庆，需要申请渝康码，重庆下高速没人检查，直接就到了酒店，酒店入住需要扫场所码，并把绿码、行程码截图发给酒店；</p><p>3、到成都，需要注册四川天府健康通，下高速排队进行核酸检测，四川要求入川后完成三天两检；</p><p>4、第八天从巴塘到如美，出发一小时就会经过金沙江大桥，过桥就进入到西藏境内了。进入西藏需要提前申请藏易通，并进行报备，我们住的酒店老板人不错，主动帮我们报备；</p><p>5、从出发开始，每天都关注疫情的变化，第八天在巴塘的酒店醒来，就看到网上有关于成都疫情的消息，当时心情非常忐忑，做好了被劝返的心理准备继续前行；</p><p>6、过金沙江大桥会检查藏易通，幸好提前报备好了，很顺利通过。没走多久遇到检查是否成都高风险过来的，看了行程码并询问了几句也就放行了。最后就是昌都检查站做落地核酸，车上随行人员下车单独排队，这也是碰到检查最多的一天；</p><p>7、后面也遇到很多次随行人员需要单独下车排队检查，只需大人下车，小孩可以留在车上；</p><p>8、整体来说，对核酸的要求不高，为了避免不必要的麻烦，我们一直保持 48 小时内的核酸。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252113248.jpeg"></p><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>在旅游旺季出行，就得承受房价的暴涨，除了像如美这种没有连锁酒店的地方，大部分时候都是订的连锁酒店，主要原因是提供洗衣房。</p><p>能提前订就尽量提前，价格会便宜不少，因为担心疫情影响到行程，我们基本是提前一两天预定，价格在 300 多到 600 不等。</p><p>印象最深的是在波密住的民宿，价格 400 多，独栋的小木屋，女儿特别喜欢。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114732.png"></p><h2 id="堵车"><a href="#堵车" class="headerlink" title="堵车"></a>堵车</h2><p>现在是旅游旺季，堵车很正常，总体来说，在能接受的范围内，有下面几个原因会出现堵车：</p><p>1、检查站检查；</p><p>2、遇到修路，单边放行；</p><p>3、有不守规矩的车辆逆行，导致行驶缓慢。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114743.png"></p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><p>从武汉出发，经过恩施、重庆到达成都，老同学请吃了成都的串串，非常 nice，在成都的第二天去了宽窄巷子和熊猫基地，整个行程的第五天才从成都出发去康定。</p><p>原计划要去打卡泸定的铁索桥的，但下高速排了很长的队，绕了一圈又上了高速，就这样全程高速到了康定，在康定就一个感觉，人太多了，而且的士是拼车的形式，遇到的很多空的士都只有一个或两个空座，我们一家三口很难打到车，最终从康定广场到住的酒店等车花了一个多小时。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114611.png"></p><h3 id="第六天（康定-雅江）"><a href="#第六天（康定-雅江）" class="headerlink" title="第六天（康定-雅江）"></a>第六天（康定-雅江）</h3><p>从康定出发就没有高速了，本来应该直接走 318 的，但因折多山修路，便绕行 434 省道，翻越了 4400 米的雅拉山口，还去了塔公草原和墨石公园，从墨石公园返回路上，还玩了水，这是女儿最喜欢的活动了。  </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252116922.png"></p><p>至于高反，一家人表现都挺好，除了走快了有点气短，并无其他不适。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114171.png"></p><h3 id="第七天（雅江-巴塘）"><a href="#第七天（雅江-巴塘）" class="headerlink" title="第七天（雅江-巴塘）"></a>第七天（雅江-巴塘）</h3><p>一大早起来准备在雅江县人民医院做核酸，但雅江县区的路太复杂了，导航都搞不定，直接放弃，改到理塘做核酸了。 </p><p>途经了天路十八弯、剪子弯山和 4700 米的卡子拉山，终于在下午一点多到了天空之城理塘。<br>理塘做核酸收费 3.5，排队人不是很多，做完核酸，女儿有点不舒服，背着走了几百米，比跑个五公里还累，世界高城名不虚传。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114981.png"></p><p>从理塘到巴塘路上，女儿因吸了氧，在草原上又活蹦乱跳了。 </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114492.png"></p><p>晚上入住巴塘世纪主题酒店，老板人特别好，主动帮忙报备藏易通，很轻松就搞定了，这也为第二天过金沙江检查站节约了不少时间。</p><h3 id="第八天（巴塘-如美）"><a href="#第八天（巴塘-如美）" class="headerlink" title="第八天（巴塘-如美）"></a>第八天（巴塘-如美）</h3><p>早上一起床，看新闻知道成都出现疫情了，虽然不是我所在的区域，心情还是很忐忑，做好了被劝返的心理准备。  </p><p>7 点半左右从酒店出发，不到一个小时到了金沙江大桥，检查核酸和藏易通。没有报备的单独排队，已经报备的可以直接走。 </p><p>过了金沙江就到了西藏境内，没走多久又遇到检查，查核酸、藏易通，是否经过了成都高风险地区，也就询问了下便放行了，惊出一身冷汗。</p><p>接下来就是昌都检查站，主要检查藏易通和做落地核酸。这个检查站比较正规，车上随行人员下车单独排队，因为要做核酸，小孩也需要下车排队，司机开车过检查口时提供身份证和打开了藏易通的手机，很快就检查完了，随后就一路通畅到了如美。 </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252114717.png"></p><h3 id="第九天（如美-八宿）"><a href="#第九天（如美-八宿）" class="headerlink" title="第九天（如美-八宿）"></a>第九天（如美-八宿）</h3><p>很早就看网上说如美到八宿是最难走的一天，特别是觉巴山，搓衣板路比较多，还有炮弹坑。可能是提前有心里准备，实际走下来，没有网上说的那么恐怖，只有些弯道是搓衣板路，炮弹坑也不少，慢点开完全能避开。 </p><p>这几天对高海拔基本适应了，5100 米的东达山全家人都没有吸氧，感觉也还行。  </p><p>翻过东达山后，在路上又找了个玩水的地方，女儿自然是很喜欢了，一起在水里来来回回走了好多趟，准备的自热饭终于在这里用上了。 </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115163.png"></p><p>业拉山下来后因为修路，堵了一个多小时，奇怪的是，没有发现怒江 72 拐的观景台，直到看见怒江大桥才意识到已经拐下来了。</p><p>这一天的路程虽然没想象的那么难走，但也不轻松，早上 8 点就出发了，晚上 7 点多才到酒店。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115744.png"></p><h3 id="第十天（八宿-波密）"><a href="#第十天（八宿-波密）" class="headerlink" title="第十天（八宿-波密）"></a>第十天（八宿-波密）</h3><p>在酒店吃完早饭，去八宿县人民医院做核酸，很意外居然不用排队，可能在藏区是不检查核酸了，但保持 48 小时核酸还是更有安全感。  </p><p>除了两个检查站，没怎么堵车。两个检查站都需要乘客单独排队，小孩可以坐车上。</p><p>这个季节的然乌湖毫无特色，也就没有停留，过了然乌湖，进入波密境内后，汽车穿梭在大山的脚下，雪山就在眼前，路两边的树木也变多了，开着车窗、吹着风、听着音乐，非常舒服。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115655.png"></p><h3 id="第十一天（波密-林芝）"><a href="#第十一天（波密-林芝）" class="headerlink" title="第十一天（波密-林芝）"></a>第十一天（波密-林芝）</h3><p>原本以为今天会很轻松，10点才出发，没想到是最堵的一天，下午 3 点多才到鲁朗，吃了传说中的石锅鸡。  </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115174.png"></p><p>吃完石锅鸡，堵堵停停用了快两个小时才到色季拉山，很遗憾，没能看到南迦巴瓦峰的全貌。  </p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115572.png"></p><h3 id="第十二天（林芝-拉萨）"><a href="#第十二天（林芝-拉萨）" class="headerlink" title="第十二天（林芝-拉萨）"></a>第十二天（林芝-拉萨）</h3><p>花了五个多小时走全程高速终于到拉萨了，在酒店安顿好后开车去了布达拉宫，之前看过太多的介绍和照片，见到的时候并没有特别的震撼，但也觉得非常雄伟壮观。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115284.png"></p><p>布达拉宫离八廓街 1.5 公里，20 块钱感受了下拉萨的人力三轮车，在八廓街的一家餐厅吃了糌粑，喝了甜茶。</p><p>在拉萨的第二天，下着小雨，我们还是按照计划去了羊卓雍措，车子开出拉萨市后，雨就停了，虽然没有蓝天白云，也很知足。</p><p>羊湖的官方观景台需要 60 块钱，我们往前走了一段，有一个收费 5 元的观景台，也很不错，从观景台出来，继续往下走，可以车停在路边，人走到湖边，近距离感受羊湖。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252115868.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>十几天的旅行很快就结束了，羊湖回来的第二天把车子进行托运，坐火车到西宁，然后从西宁飞回武汉。7 月 23 号晚上顺利到家。</p><p>之所有选择火车到西宁，是因为没有时间开车从青藏线出来，在开火车上可以看看青藏线上不一样的风景。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202209252116293.png"></p><p>十几天的旅程还是很辛苦的，需要有好的心态，而且我我们的运气还不错，没有受到疫情的影响；大部分时间都是好的天气；也没有遇到大堵车的时候，还有什么不满足的呢？</p><p>对我个人而言，我很享受开着车，每天看到不一样的风景，辛苦也是值得的。</p><p>期待下一次的旅行。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直都有去西藏的想法，去年换了坦克 300，自驾 318 便提上了日程。7 月小孩放暑假，同时领导也批准了我较长时间的请假。于是三个人，一台车，7 月 9 号开始了自驾之旅。&lt;/p&gt;</summary>
    
    
    
    <category term="旅行" scheme="http://fwhyy.com/categories/%E6%97%85%E8%A1%8C/"/>
    
    
    <category term="旅行" scheme="http://fwhyy.com/tags/%E6%97%85%E8%A1%8C/"/>
    
    <category term="自驾" scheme="http://fwhyy.com/tags/%E8%87%AA%E9%A9%BE/"/>
    
    <category term="西藏" scheme="http://fwhyy.com/tags/%E8%A5%BF%E8%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>读《认知觉醒》</title>
    <link href="http://fwhyy.com/2022/07/read-cognitive-awakening/"/>
    <id>http://fwhyy.com/2022/07/read-cognitive-awakening/</id>
    <published>2022-07-04T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:10.583Z</updated>
    
    <content type="html"><![CDATA[<p>最近发的几篇文章是跟个人成长和工具相关，突然想起几个月前读的《认知觉醒》，这本书从内在和外在两个大的维度让我们在个人精进的道路上可以少走弯路。</p><p>后疫情时代，公司的活动少了，家庭的活动也少了，19 年后，没有自驾出过远门，每天家和公司两点一线，一天、一周、一个月过去，大脑没什么记忆点。日子像掉进了 for 循环一样，不断重复着，人就很容易产生疲态。</p><p>这本书可以给我们一些指引，让我们实际去做一些事情，丰富我们的生活。</p><span id="more"></span><p>作者 36 岁才开始探索，从混沌到警醒，从迷茫到清晰，知道了如何激发和保持自我提升的内在动力。所以，什么时候都不会晚，改变自己最好的时机，一个是十年前，另一个就是现在。</p><p>当我们不思考，每天按部就班的时候，不会产生焦虑。不过，不管主动还是被动，总有一天会觉醒，想在工作中得到晋升，想让自己能力得到提升，想让家庭都能过得幸福，这时就会焦虑，因为欲望大于能力了，想要的东西太多，会觉得时间不够用，觉得迷茫，很多事情想做不知道怎么开始。</p><p>作者认为焦虑的根源是：急于求成，想同时做很多事；避难趋易，想不怎么努力就立即看到效果。解决方法是首先要接受和承认焦虑，然后要有耐心，而且是长期有耐心。丁西坡写了一本书《长期有耐心》，讲的是美团的成长和进化，王兴也是靠着长期有耐心才从百团大战中走到了今天。</p><p>解决了焦虑的问题，作者从专注力、学习力、行动力、情绪力四个方面具体讲解怎样借力前行。</p><p>对书中关于专注力的一个小故事印象很深刻：</p><blockquote><p>一位行者问老和尚：“您得道前在做什么？”老和尚说：“砍柴、担水、做饭。”行者问：“那得道后呢？”老和尚说：“砍柴、担水、做饭。”行者又问：“那何谓得道？”老和尚说：“得道前，砍柴时惦记着挑水，挑水时惦记着做饭；得道后，砍柴即砍柴，担水即担水，做饭即做饭。”</p></blockquote><p>学习，作者分为三个区域：舒适区、边缘区、困难区，长期呆在舒适区，再勤奋只是低效的勤奋，目标设置太高到了困难区，容易打消积极性。需要在边缘区不断向外探索，使自己处在最佳承受范围，既保留了学习的成就感，也保证了学习的挑战性。</p><p>在学习过程中，为了督促自己，我们经常会到处打卡：朋友圈、各种打卡群等。作者认为打卡是打不出未来的，一件事若迟迟没有完成，心里就总是记挂，期盼着早点结束；此事一旦完成，做这件事的动机就会立即趋向于零。</p><p>这个观点我同意一半，我认为打卡还是有督促的作用，但需要长期地进行。去年 9 月我在朋友圈打卡坚持了 100 天每天五公里的挑战。结束后，人便放松下来，停跑了很长一段时间。今年我做了调整，依然打卡，但目标定为每个月 100 公里，1 个月内可以很灵活进行调整，最终达成就可以了。现在 2022 年已经过半，跑量已有 600 多公里。</p><p>和作者一样，我也曾被人说是一个行动力强的人，可能是因为看到我朋友圈坚持了 100 天的跑步打卡。除了跑步，我写公众号也坚持了几年。我很同意作者提到的一个成长中的悖论：想先看到结果再行动的人往往无法看到结果。</p><p>很多事情都是慢慢积累，便会水到渠成。在积累的过程中需要有思考和反馈，缺少思考，就不知道下一步的方向；缺少反馈，就少了下一步行动的动力。</p><p>至于情绪，每个人都会有，但通过不同的角度和立场去看待事物，结果会不一样，情绪也会发生变化。最近看到一个踏板效应的例子很好地解释了这个两面性：</p><blockquote><p>踏板效应是一个经济学术语。人们通常用「挤公交」的事例来解释这一现象：当拥挤的公交车在站台边停下时，车下的人会拼命的往车上挤，一边挤一边央求车上的人往里挪挪，好让自己挤上车；而一旦挤上之后，就会试图阻止车下还在往车上挤的人――「别挤了，车上已经没位子了，等下一趟车吧！」态度瞬间180度急转弯。这就是「踏板效应」，所说明的人们言行背后的行为逻辑――立场决定观点。</p></blockquote><p>所以，当有情绪时，暂停一分钟，进入到自己的思考角，多个角度想想问题，很可能在这个思考的过程中就已经释然了。</p><p>我比较喜欢这本书，还有个原因跟第八章有关，第八章讲了成本最低的成长之道，包含了：早起、冥想、阅读、写作、运动。除了冥想，其他几项我目前都有在做，并且坚持在做。</p><p>早起让我有了更多的时间，路上不堵车、不用花时间找车位、不用花时间等电梯，这些都能节约大量的时间；运动让我有更好的身体，也让我每天的工作生活中充满精力，纳瓦尔说过，他自己将个人健康排在所有事情的第一位；阅读和写作能扩展我的知识面并带来思考。</p><p>愿每个人都能在个人成长路上一帆风顺。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近发的几篇文章是跟个人成长和工具相关，突然想起几个月前读的《认知觉醒》，这本书从内在和外在两个大的维度让我们在个人精进的道路上可以少走弯路。&lt;/p&gt;
&lt;p&gt;后疫情时代，公司的活动少了，家庭的活动也少了，19 年后，没有自驾出过远门，每天家和公司两点一线，一天、一周、一个月过去，大脑没什么记忆点。日子像掉进了 for 循环一样，不断重复着，人就很容易产生疲态。&lt;/p&gt;
&lt;p&gt;这本书可以给我们一些指引，让我们实际去做一些事情，丰富我们的生活。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="认知" scheme="http://fwhyy.com/tags/%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian 一周使用心得（配置、主题和插件）</title>
    <link href="http://fwhyy.com/2022/06/obsidian-one-week-experience/"/>
    <id>http://fwhyy.com/2022/06/obsidian-one-week-experience/</id>
    <published>2022-06-27T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:12.025Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇 Obsidian 初体验 中介绍了为什么要开始使用 Obsidian 和我的一些基本用法，本文将继续讲解近一个星期以来的使用心得，包括配置、外观和插件。</p><p>对于工具类的软件，我一直的方式是先进行基本设置，使用起来，在使用过程中再慢慢发现一些高级用法，就像 Obsidian 这个软件，目的是能方便进行写作，如果花大量精力去研究功能、插件等，就有点本末倒置了。</p><span id="more"></span><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、语言设置，在「设置-&gt;关于」中进行语言的切换：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260916713.png"></p><p>2、删除文件设置，在「设置-&gt;文件与链接」中进行配置，我设置为移至软件回收站，这样删除的文件会在 Obsidian 的库目录下的一个隐藏目录中，如果发现误删还能找回来。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260916965.png"></p><p>3、新建笔记目录设置，在「设置-&gt;文件与链接」中进行配置，设置后，新创建的文件就在设置的目录中。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260916183.png"></p><p>4、图片目录设置，在「设置-&gt;文件与链接」中进行配置，设置后，在文章中粘贴的图片就会存储到设置的目录中。</p><p>不同的文章中粘贴的图片都会在这一个目录中，要是能像 Typora 根据文章名称生成子目录就更好了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260916804.png"></p><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>在 Obsidian 中，每个库都可以单独进行设置，我现在使用的是 Primary 主题，因为色系我很喜欢，从上面的截图中可以看到。另外 Blue Topaz 主题也不错，里面有丰富的设置，而且是中文界面。</p><p>在「设置-&gt;外观-&gt;主题」界面点击「管理」按钮，在弹出的界面中选择使用喜欢的主题即可。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260917689.png"></p><p>如果点击「管理」按钮，界面不能正常出来，可以尝试换下网络。</p><p>值得注意的是，网上很多教程中有写到主题的配置，但我在实际使用过程中却没有发现那些配置项，后来才发现需要安装 System Settings 插件，关于这个插件在下面的插件部分会讲到。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>在「设置-&gt;第三方插件」中进行插件的安装，点击「社区插件」后面的「浏览」按钮打开插件列表界面进行安装即可。安装插件前，需要先将安全模式的开关关闭。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260917926.png"></p><p>如果有些插件在线安装失败，可以在 <a href="https://ob.pory.app/">https://ob.pory.app/</a> 这个站点进行下载，进行手动安装，将下载的包解压后复制到目录：<code>库/.obsidian/plugins</code> 即可。</p><p>下面介绍几个我目前用到的插件：</p><p><strong>1、System Settings</strong></p><p>上面提到安装主题之后，需要配合 System Settings 插件才能使用，例如，如果安装的是 Blue Topaz 主题，设置界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260919971.png"></p><p>基本上这里的设置就够用了，真满足不了，还能自定义 CSS ，这里就不详细说了。</p><p><strong>2、Calendar</strong></p><p>之前使用 Notion 的时候，用的是 Notion 中的日历，使用方式是在日历的每天中创建一个或多个 Page ，这样有几个问题：</p><ul><li>页面层级深，想要找到当天的某个页面，需要先找到左边菜单的日历，然后找到当天，再打开对应的 Page ;</li><li>Page 本身没有状态，需要到里面进行待办的添加，又多了一个层级，比较麻烦。</li></ul><p>在 Obsidian 中默认就有日记的功能，在核心插件中开启就可以使用了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260923195.png"></p><p>通过 Calendar 组件，就能在右侧的面板中展示日历了，并且在 Calendar 组件设置中可以开启周显示：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260923280.png"></p><p>右侧面板中显示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260919306.png"></p><p>设置好当天日记的快捷键，不管现在是在写那篇文章，一个快捷键就能立即回到当天的日记当中，非常方便。</p><p>日记和周记都能设置存放目录和模板，但设置的地方不一样，日记因为是内置插件，在核心插件中设置，周记则是在 Calendar 插件中进行设置。</p><p>我的日记和周记模板如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260919427.png"></p><p><strong>3、rollover daily todos</strong></p><p>当天日记中的待办没处理完，第二天的日记中又要手动进行添加。</p><p>这个插件可以自动将前一天没有处理完的待办事项添加到新创建的日记中。还可以设置是否删除前一天没完成的事项。</p><p><strong>4、Image Auto Upload Plugin</strong></p><p>这个插件主要用来上传粘贴在文章中的图片，在上一篇《Obsidian 初体验》中有介绍。</p><p><strong>5、Obsidian Git</strong></p><p>现在我是使用 iCloud 来做 Obsidian 的备份和同步，但多一个备份源会更踏实，所以我在 GitHub 上创建了一个私有仓库，Obsidian Git 插件可以用来做自动备份 。</p><p>例如我设置 3 分钟同步一次：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260918141.png"></p><p>自动同步后的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260917673.png"></p><p>使用这个插件不仅仅是有备份的作用，还可以追踪历史版本。</p><p>最后说一个使用过程中发现的小技巧，在使用 iCloud 进行 PC 和移动端同步的过程中，经常发现 PC 端新增了内容后，移动端没能及时同步。这时只需要打开 Finder ，就可以看到 iCloud 云盘右边有一个小圆圈在转动，只要这个圆圈转完，移动端便会立即更新。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202206260918139.png"></p><p>卢曼说过：不写作，就无法思考，所以工具只是辅助，多写，多思考才能不断提升。</p><p>希望本文对您有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇 Obsidian 初体验 中介绍了为什么要开始使用 Obsidian 和我的一些基本用法，本文将继续讲解近一个星期以来的使用心得，包括配置、外观和插件。&lt;/p&gt;
&lt;p&gt;对于工具类的软件，我一直的方式是先进行基本设置，使用起来，在使用过程中再慢慢发现一些高级用法，就像 Obsidian 这个软件，目的是能方便进行写作，如果花大量精力去研究功能、插件等，就有点本末倒置了。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian 初体验</title>
    <link href="http://fwhyy.com/2022/06/how-do-techies-build-their-personal-brands/"/>
    <id>http://fwhyy.com/2022/06/how-do-techies-build-their-personal-brands/</id>
    <published>2022-06-20T00:20:20.000Z</published>
    <updated>2022-09-25T13:47:18.326Z</updated>
    
    <content type="html"><![CDATA[<p>对技术人来讲，个人品牌非常重要，个人品牌的建立是自我营销的一种方式，也是提升个人价值的一种方式。</p><p>那什么是品牌呢？一篇文章、一个视频火了，这个不算是品牌，如果提及某个领域，大家能想到你，这就是品牌了。</p><span id="more"></span><p>建立个人品牌的方式有很多种，比如：写博客、参加技术大会的演讲、出书、做公众号、视频号等，需要持续地产生有价值的内容，把自己推销出去。</p><p>在这些方式中，写博客是相对容易，门槛最低的。我很早就开始写博客，但当时没有个人品牌的概念和意识，只是觉得技术人对知识进行分享总是没错的。所以在个人品牌打造上我是比较迟钝，也比较失败。但从失败中得到的一些教训和产生的思考或许对刚入行的朋友有所帮助。</p><p>2006 年我在博客园写了第一篇博客，高峰时期排名 100 多，后来独立博客比较流行，又折腾独立博客，从 Wordpress 到 hexo 。现在想想，如果一直在博客园坚持到现在，肯定会是不一样的结果。</p><p>2009 年，那会工作压力不太大，下班后看书、看视频学习技术，然后就是逛 CSDN 论坛，学以致用，几个月时间，技术分积累了几万，当看到等级变成一个红色五角星时，还是很有成就感的，可惜只坚持了不到半年。后来看到很多比我晚混论坛的人通过坚持在全站有一个比较好的排名，就有点后悔没能坚持了。</p><p>坚持非常重要，但也需要在一个正确的方向上。下面几点是我认为对打造个人品牌比较重要的点，有些我也做的不是很好：</p><p>1、核心能力提升</p><p>一个程序员能完成日常的工作，会涉及到很多的技术：前端（JavaScript、各种前端框架）、后端（编程语言，各种中间件）、数据库（Mysql、SqlServer 等）。</p><p>在胜任日常工作的同时，一定要找一个自己感兴趣的方向，可以是编程语言、可以是数据库、也可以是中间件，深入研究，不断精进和优化自己这方面的能力，成为该领域的专家，做到在团队内部或者公司，一说到这个领域，第一个想到的就是你。</p><p>在你成为专家的这个过程你需要输入和消化大量的内容，当然也能输出大量的内容。</p><p>2、独特性</p><p>创建一个博客、开通一个公众号的成本很低，搜索 dotNET 关键字，能找到几百个相关的公众号，别人为什么要关注你，一定得有自己的独特性，区别与他人，形成自己的风格，才可能被人记住和关注。</p><p>独特性有很多种方式可以实践：</p><ul><li>苦练基本功和语言组织能力，能将一个复杂的技术深入浅出地表达出来，例如阮一峰的博客文章；</li><li>在文章形式上可以形成自己的风格，例如程序员小灰是以漫画的形式；跨界架构师的公众号封面图是一个黄色背景的模板加上相关的标题，让人印象深刻；</li><li>发布时间固定也能形成独特风格，阮一峰的公众号每周五准时推送，很多人留言开玩笑说：一看到他的推文立马想起今天是周五了。</li><li>除了专业技能，如果你在一些兴趣爱好上做的还不错，比如跑马很厉害、书法很厉害等，也容易被人记住，这些独特的兴趣爱好可以加强个人品牌的影响力。</li></ul><p>3、垂直</p><p>什么都想做，可能什么都做不好，所以在没有知名度的时候，在一个垂直的方向深挖，更容易扩大自己的品牌影响力。</p><p>程序员小灰最早写的都是算法相关，而且以漫画的形式，通俗易懂，比较新颖，收获了大量了粉丝；《极客时间》的创始人池建强的公众号 MacTalk ，最早是从写 Mac 技巧开始。</p><p>内容太垂直也会带来问题，就是受众相对较小，所以可以采取一个折中的方案，那就是出专栏，一段时间内只写一个主题相关的，十几篇或几十篇形成一个系列，当然这需要你对这个主题有深入的了解，达到了能将知识传授给他人的程度。</p><p>一开始，别人肯定是先从你的内容慢慢了解到你这个人，等品牌逐渐建立起来了，有一定影响力了，才会形成先关注人再关注内容的转变。</p><p>垂直的内容能够更容易获得第一批用户。</p><p>4、敢于交流分享</p><p>大多数人肯定做不到能在 Qcon 这种大型的技术会议上进行一场演讲，但团队内部、公司内部的技术交流和分享，只要你有意愿还是很容易实现的。</p><p>这是绝佳的锻炼和提升自己的机会，在这个过程中不断地改进自己的内容组织能力、演讲能力，内部人员因为比较熟悉，也能很好地给你反馈。</p><p>我们平时应该多沉淀、积累，并且积极主动争取一些分享的机会，就像跑步一样，穿什么不重要、什么时间跑也不重要，用跑步机还是路跑也不重要，重要的是迈出第一步，先跑起来。</p><p>李诞说每个人都能讲五分钟脱口秀，我也认为每个技术人员都能做好一场技术分享。</p><p>在一些高质量的技术群里，不要天天潜水观看，积极参与讨论有利于让更多人知道你，如果发现别人在激烈的讨论而自己插不上嘴，就是该充电的时候了。</p><p>5、强观点输出</p><p>什么是强观点？就是在沟通交流过程中有自己的坚定的立场，不会随风摇摆，并且有事实依据支撑，而不是说永远「正确」的话，或是正确的废话。</p><p>上学时在一个班级中，被人记住的是前几名和最后几名的学生。在打造个人品牌的过程中，如果你的输出都是中庸的，很难被人记住，所以大胆表达你的观点，即便是有争论，甚至是争吵也不要紧，很多新的思想、好的点子就是在这样激烈的争论中产生的。</p><p>6、良好的心理承受能力</p><p>文章开头说了，个人品牌的建立是自我营销的一种方式，自我营销就是将自己推销出去，让别人知道，知道的人越多，各种不同的评价就会越多，没有一个好的心态，很可能就会受到打击，一蹶不振。</p><p>好的评价听听就好，未必真的有那么好，不好的评价也不要不开心，这恰恰是值得我们反思的。</p><p>锻炼好的承受能力没有捷径，只能多经历，多在事上练。</p><p>以上，对自己的反思，与君共勉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对技术人来讲，个人品牌非常重要，个人品牌的建立是自我营销的一种方式，也是提升个人价值的一种方式。&lt;/p&gt;
&lt;p&gt;那什么是品牌呢？一篇文章、一个视频火了，这个不算是品牌，如果提及某个领域，大家能想到你，这就是品牌了。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="总结" scheme="http://fwhyy.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="思考" scheme="http://fwhyy.com/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="个人品牌" scheme="http://fwhyy.com/tags/%E4%B8%AA%E4%BA%BA%E5%93%81%E7%89%8C/"/>
    
  </entry>
  
</feed>
