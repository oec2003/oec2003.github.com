<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冯威的博客</title>
  
  <subtitle>公众号：不止dotNET | 临渊羡鱼不如退而结网</subtitle>
  <link href="http://fwhyy.com/atom.xml" rel="self"/>
  
  <link href="http://fwhyy.com/"/>
  <updated>2024-09-30T17:46:52.349Z</updated>
  <id>http://fwhyy.com/</id>
  
  <author>
    <name>oec2003</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>introduction-to-openai-o1</title>
    <link href="http://fwhyy.com/2024/09/introduction-to-openai-o1/"/>
    <id>http://fwhyy.com/2024/09/introduction-to-openai-o1/</id>
    <published>2024-09-25T00:44:38.000Z</published>
    <updated>2024-09-30T17:46:52.349Z</updated>
    
    <content type="html"><![CDATA[<p>1、OpenAI 在 9 月 13 日发布了 o1 的预览版。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241751659.webp"></p><p>2、o1 全称叫 OpenAI o1, 没有延续之前 GPT 系列，可见足够强大，当然也有一种说法是 o1 作为一个垂直基础模型为未来 GPT5 赋能。</p><p>3、o1 在推理方面变得更加强大了，特别擅长做数学题和写代码。在国际数学奥林匹克（IMO）资格考试中，GPT-4o 只正确解决了 13% 的问题，o1 的得分为 83%。</p><span id="more"></span><p>4、o1 分为两个版本：o1-preview 和 o1-mini，可能因为训练成本巨大或是其他原因（比如收集更高质量的问题），发布时 o1-preview 每周只能使用 30 次查询，o1-mini 是 50 次。GPT Plus 的付费用户才能使用。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241751431.webp"></p><p>5、9 月 17 号，OpenAI 发布消息，放宽了限额，o1-preview 现在为每周 50 次查询，o1-mini 改为每天 50 次查询。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241752377.webp"></p><p>6、o1 最特别的地方是能「思考」了，之前的版本都强调能快速给出结果，对 o1 来说「慢」是一种特点，当我们对 o1 提出问题时，内部会生成一个思维链来逐步推理问题，类似于人类解题时的思考过程，尝试不同的策略，并能认识到自己的错误。所以时间花的更长，通常几秒到几十秒不等。</p><p>7、o1 的慢和之前系列的快，就像丹尼尔·卡尼曼的《思考，快与慢》中写的快思考和慢思考：</p><ul><li>快思考：联想记忆，从已经训练的数据中快速获取，利用简化的决策规则解决问题，容易出现错误。</li><li>慢思考：有逻辑性，能对提的问题进行反复推敲，自我监督和矫正，正确率较高。</li></ul><p>8、正是因为 o1 能对问题进行推敲，就大大降低使用者的难度了，以前想要一个好的答案，需要写出好的提示词，现在 o1 经过推敲，更能理解提问者背后的意思。提升了易用性和效率。AI 发展太快，提示词工程师是不是刚要上岗就面临失业了呢？</p><p>9、和 GPT-4o 相比较，虽然推理能力强大很多，但功能还不算完善，比如不支持图像、不支持联网查询等，期待后续的版本。</p><p>10、对于编码来说，我们使用 o1-mini 就够了，因为 o1-mini 比 o1-preview 便宜 80%，每周有更多的查询次数，而且，编码仅需要推理不需要广泛的世界知识，非常适合 o1-mini。</p><p>11、我用 o1-mini，写了一个 License 生成工具，前端用 vue3、后端使用 .NET8，慢慢引导，从基本的功能到加上登录、加上鉴权等，周末一个上午时间就搞定了，基本没有出错，确实很强大。</p><p>12、AI 这么强大了，我们应该做更重要的事情。我觉得技术学习分为三层：</p><ul><li>架构层：架构层关注的是如何设计和构建系统的结构，确保系统的整体性和功能性，比如：单体、微服务、分布式、涉及模式、性能优化、扩展性、可维护性、安全性等。了解这些才能熟练驾驭 AI。</li><li>工具层：编程语言、框架使用等，这部分可以 AI 代替。</li><li>原理层：原理层是技术学习中最深入的一层，它关注的是底层原理和概念。了解这些，当 AI 抽风时不至于束手无策。</li></ul><p>重要的事情就是指架构层和原理层的学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、OpenAI 在 9 月 13 日发布了 o1 的预览版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241751659.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、o1 全称叫 OpenAI o1, 没有延续之前 GPT 系列，可见足够强大，当然也有一种说法是 o1 作为一个垂直基础模型为未来 GPT5 赋能。&lt;/p&gt;
&lt;p&gt;3、o1 在推理方面变得更加强大了，特别擅长做数学题和写代码。在国际数学奥林匹克（IMO）资格考试中，GPT-4o 只正确解决了 13% 的问题，o1 的得分为 83%。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
    <category term="OpenAI" scheme="http://fwhyy.com/tags/openai/"/>
    
  </entry>
  
  <entry>
    <title>忙碌的陷阱</title>
    <link href="http://fwhyy.com/2024/09/the-busy-trap/"/>
    <id>http://fwhyy.com/2024/09/the-busy-trap/</id>
    <published>2024-09-23T00:35:29.000Z</published>
    <updated>2024-09-30T17:47:21.504Z</updated>
    
    <content type="html"><![CDATA[<p>在一个公司中，当所有人都很「忙碌」时，常常被视为高效和生产力的象征，但如果项目还是不能按时上线、客户投诉比较多，满意度差，就需要思考：这种忙碌是真的高效吗？我们是不是陷入了忙碌的陷阱了呢？</p><span id="more"></span><p>通过近段时间的观察，发现有这么几个现象：</p><h2 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h2><p>在软件开发和项目管理中，信息不对称是一个普遍存在的问题。它不仅会导致团队成员之间的沟通不畅，更会让任务的执行出现偏差。</p><blockquote><p>比如，经理安排小王写一份文档，在经理看来已经跟小王交代了文档的要求和要点，小王整理后只需交给 AI 生成相关内容，然后进行校对就可以， 1 小时以内就能完成。但小王接到任务后，评估至少得半天到一天的时间才能完成，又因为手头有优先级更高的事情，就迟迟没能完成。</p></blockquote><p>这表面上看是工作量理解的问题，但本质上却是信息不对称引发的认知差异，经理和小王的理解出现了偏差：经理认为这项任务简单快速，而小王觉得需要投入更多的精力。这种偏差在项目实施过程中尤为常见，可能导致如下问题：</p><p>1、<strong>需求理解上的偏差</strong>：客户提出的需求是否准确传达给了项目团队？<br>2、<strong>任务分配上的偏差</strong>：项目经理布置的任务，团队成员是否真正理解其目标和要求？</p><p>小时候我们都学过盲人摸象。每个人只触摸到大象的一部分，就妄下结论。摸到腿的说大象像柱子，摸到尾巴的说大象像绳子。由于缺乏全局信息，每个人的理解都不完整。这正是信息不对称导致的理解偏差。</p><p>项目失败一个很重要的原因就是需求和任务分配时的理解偏差，最终导致产出的成果不是客户想要的。想要解决，其实也很简单，在团队内部需要建立有效的沟通机制：</p><p>任务安排者应详细说明任务的背景、目标、具体要求和截止日期，最好提供书面的任务说明文档，一些小任务没有正式文档，在即时通讯工具或邮件中写清楚也是可以的。任务接受者在接到任务后，应主动反馈自己的理解，最好能复述任务要求，确认双方理解的一致性。这种双向确认机制在敏捷开发中被广泛应用，通过每日站会和及时反馈，确保团队成员的理解与任务要求高度一致。</p><p>此外，定期的沟通和反馈也是必要的。在任务进行过程中，双方应保持交流，及时汇报进展和遇到的问题。这样可以及时发现偏差，进行纠正，避免在错误的道路上越走越远。</p><h2 id="方案与需求的混淆"><a href="#方案与需求的混淆" class="headerlink" title="方案与需求的混淆"></a>方案与需求的混淆</h2><p>另一类常见的问题是将解决方案与需求混为一谈。在需求调研时，客户很容易就直接给出了解决方案，这种情况很容易导致项目资源的浪费，因为开发团队可能会依据客户的「解决方案」进行开发，却发现最终实现的功能并不能真正解决客户的问题。</p><blockquote><p>比如，在一个项目中，客户要求在流程审批中设置中能动态添加抄送人，很明显这是一个解决方案。经过深入沟通后发现，客户真正的目的其实是当审批人超时没有处理时，就抄送给此人的领导。如果没有弄清目的，盲目就去开发，肯定会造成返工，然后整个团队就可以「忙碌」了。</p></blockquote><p>为了避免这种情况，我们需要在需求分析阶段与客户进行深入的沟通。通过提问和倾听，了解他们的业务流程、痛点和目标，不要急于给出解决方案，而是先理解问题的本质，更是要能分辨客户讲的是需求还是解决方案。</p><p>同时，公司可以加强对需求分析的培训，提高团队在需求分析时的敏感度和准确度。制定标准化的需求分析流程，将需求与方案明确区分开来。这不仅有助于减少项目开发中的返工成本，还能提升客户满意度，增强公司竞争力。</p><h2 id="主次不分"><a href="#主次不分" class="headerlink" title="主次不分"></a>主次不分</h2><p>在项目实施过程中，面对众多任务和需求时，优先级的判断至关重要。如果无法正确区分主次，项目团队很容易陷入无止境的处理细节中，忽视了项目最核心的目标。</p><blockquote><p>比如：项目A 开发的系统目标用户有管理层和基层人员，管理层关注报表、大屏看板，基层员工进行数据提报。项目经理每天和基层的业务人员在一起，恰巧这些业务人员想法很多，每天都提出很多优化建议和调整，项目经理勤勤恳恳做需求记录，安排加班处理。最后项目没有按时上线，复盘后，原因是管理层关注的某个看板没有完成。</p></blockquote><p>这是很典型的主次不分，基层人员提的很多需求有可能是伪需求，重点干系人提的需求有可能很小，但会决定整个项目的推进。</p><p>为了避免主次不分的问题，项目管理中必须建立清晰的优先级管理机制，确保团队集中资源处理最重要的任务。以下是几个有效的策略：</p><p>1、<strong>明确项目的核心目标</strong>：在项目启动阶段，就要与客户的干系人明确项目的核心目标和关键成功指标。例如，在上面的案例中，管理层的需求（如报表和大屏看板）应被视为高优先级任务，并与团队沟通清楚。</p><p>2、<strong>制定优先级矩阵</strong>：采用<strong>四象限法则</strong>（重要紧急矩阵）或 <strong>MoSCoW法则</strong>（Must, Should, Could, Won’t）等优先级管理工具，将任务分类处理。优先处理那些既重要又紧急的任务，确保在有限的时间内完成对项目成功至关重要的工作。团队成员也应定期检查和更新优先级，保证任务处理顺序符合项目的实际需求。</p><p>3、<strong>加强沟通和反馈机制</strong>：项目经理不仅要与基层员工沟通，还要保持与客户重点干系人的紧密联系，确保随时掌握高层的关键需求。定期的进度汇报和反馈能帮助团队及时调整工作重心，不至于偏离核心目标。</p><p>4、<strong>防止需求蔓延</strong>：项目经理应设置严格的需求变更控制机制，避免过度的需求膨胀。对于基层员工提出的优化建议，要进行严格筛选，只处理那些符合项目整体目标并且对最终交付有显著影响的需求。对于不符合项目核心目标的需求，可以进行延后处理或将其纳入后续版本中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>忙碌常常给人一种充实感，但忙碌并不等于高效。如果我们没有明确的目标和计划，只是一味地埋头苦干，可能会陷入「忙而无果」的境地。</p><p>低头做事，也得时常抬头看路，就像越野跑，当你发现前后都没有人的时候，不一定是落在最后了，也可能是跑错了方向，这时如果继续加速追赶，只会离目标越来越远。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个公司中，当所有人都很「忙碌」时，常常被视为高效和生产力的象征，但如果项目还是不能按时上线、客户投诉比较多，满意度差，就需要思考：这种忙碌是真的高效吗？我们是不是陷入了忙碌的陷阱了呢？&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="管理" scheme="http://fwhyy.com/tags/%E7%AE%A1%E7%90%86/"/>
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="思维" scheme="http://fwhyy.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>什么是 RAG？</title>
    <link href="http://fwhyy.com/2024/09/what-is-rag/"/>
    <id>http://fwhyy.com/2024/09/what-is-rag/</id>
    <published>2024-09-10T00:32:52.000Z</published>
    <updated>2024-09-30T17:56:31.566Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能技术飞速发展的今天，各种创新和应用层出不穷。其中，RAG（Retrieval-Augmented Generation，检索增强生成）作为一种新兴的技术方法，正逐渐成为 AI 2.0 时代的杀手级应用。</p><span id="more"></span><p>那么，什么是 RAG？它如何工作？以及它在实际场景中的应用有哪些？本文将为你详细解答这些问题。</p><h2 id="一、RAG-的定义"><a href="#一、RAG-的定义" class="headerlink" title="一、RAG 的定义"></a>一、RAG 的定义</h2><p>RAG，全称为 Retrieval-Augmented Generation，直译为「检索增强生成」。简单来说，RAG是一种结合了检索和生成的技术方法。它将传统的基于检索的问答系统和基于自然语言生成的技术相结合，提升了 AI 系统在回答自然语言问题时的准确性和可靠性。</p><p>传统的生成模型依赖于大量的训练数据，通过学习这些数据来生成回答。然而，这种方法有一个明显的局限性：大模型在面对从未见过的问题或新兴领域的知识时，会产生不准确或不合逻辑的回答。</p><p>而 RAG 通过引入检索机制，首先从大量外部知识库或企业内私有文档中检索出相关信息，然后再结合生成模型，生成更加准确、上下文相关的答案。这种方法既保留了生成模型的灵活性，又增强了其对领域知识的覆盖面和准确性。</p><h2 id="二、RAG-的工作原理"><a href="#二、RAG-的工作原理" class="headerlink" title="二、RAG 的工作原理"></a>二、RAG 的工作原理</h2><p>RAG 的核心思想是通过「检索-生成」双重机制来提高生成模型的表现。具体来说，它的工作流程可以分为以下几个步骤：</p><p>1、<strong>问题理解和检索阶段</strong>：首先，RAG 模型接收到用户的问题或请求。然后，模型利用检索模块，从预定义的知识库或文档集合中，找到与问题最相关的文本片段。这些片段可以是短语、句子、段落甚至是整个文档。</p><p>2、<strong>生成阶段</strong>：在获取了相关文本片段后，RAG 模型会将这些片段与原始问题结合，输入到生成模型（GPT、通义千问、文心一言等）中。生成模型根据输入内容生成最终的答案或文本输出。</p><p>3、<strong>输出优化</strong>：为了确保生成的答案是相关且准确的，RAG 模型通常会在生成阶段加入后处理步骤，如答案的置信度评估、多候选答案筛选等，以进一步提升生成结果的质量。</p><p>这种「检索-生成」的方式使得 RAG 模型不仅可以利用现有的大规模训练数据，还可以从企业私有知识库中获取最新、最相关的信息，确保其生成的内容始终是及时、准确的。</p><p>在实际落地会分为用户端和管理端，在管理端进行知识文件的上传，系统会对文档进行文本读取、分快、向量化，将结果存入向量数据库。</p><p>用户端在一个搜索框中进行提问，系统会对问题进行向量化处理，然后到向量数据库中进行相似度匹配，将匹配的结果、原始问题、提示词一起提交给大模型，等着大模型的返回结果就好。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409091849088.webp"></p><h2 id="三、RAG-的应用场景"><a href="#三、RAG-的应用场景" class="headerlink" title="三、RAG 的应用场景"></a>三、RAG 的应用场景</h2><p>RAG 技术的出现，使得许多传统的 NLP 任务得到了全新的解决方案。以下是几个 RAG 技术的典型应用场景：</p><p>1、<strong>智能问答</strong>：在客服、教育、医疗、企业内部知识库等领域，RAG 技术可以用于构建更为智能的问答系统。这类系统不仅可以回答常规问题，还能根据用户的特定问题实时检索相关信息，提供更加精准的答案。</p><p>2、<strong>内容生成</strong>：RAG 技术还可以用于内容创作领域，如新闻生成、技术文档编写等。通过结合检索到的最新信息，RAG 生成的内容不仅保持了连贯性，还能反映出当前的最新趋势和知识，甚至跟自己历史创作内容相结合，生成的内容可以更具有个人风格。</p><p>3、<strong>辅助决策</strong>：对于需要处理大量文档和信息的行业，如法律、金融等，RAG 技术可以帮助用户快速找到相关案例、法规或市场数据，辅助决策和研究工作。</p><h2 id="四、RAG-的技术优势"><a href="#四、RAG-的技术优势" class="headerlink" title="四、RAG 的技术优势"></a>四、RAG 的技术优势</h2><p>RAG 作为一种创新的技术方法，具有以下几大优势：</p><p>1、<strong>知识覆盖面广，更专业</strong> ：通过引入检索机制，RAG 可以访问私有领域知识库，这使得它在处理涉及专业领域问题时，依然能够生成准确的答案。</p><p>2、<strong>生成内容的准确性和上下文相关性增强</strong>：相比于传统的生成模型，RAG 生成的内容更加可靠，因为它可以借助检索到的相关信息，确保生成的文本与问题或上下文高度相关。</p><p>3、<strong>灵活性和扩展性强</strong>：RAG 模型可以灵活地应用于不同的领域和任务中，只需更换或扩展其检索库，便能适应新的应用场景。在企业内部，文档针对不同的智能部门有权限之分，RAG 的灵活性就可以很轻松满足这类需求。</p><h2 id="五、RAG-的发展前景"><a href="#五、RAG-的发展前景" class="headerlink" title="五、RAG 的发展前景"></a>五、RAG 的发展前景</h2><p>随着人工智能技术的不断进步，RAG 作为一种结合了检索和生成的混合技术方法，展示了其巨大的潜力。在未来，我们可以预见，RAG 将在更多的领域得到应用和发展，尤其是在需要大量信息处理和精准生成的场景中。</p><p>同时，随着知识库的扩展和生成模型的优化，RAG 的性能和应用广度将进一步提升。未来的 RAG 模型或许将不再局限于文本生成，还可能扩展到多模态生成，如图像、音频等，为各行各业带来更加丰富和智能的解决方案。</p><p>例如：我们现在在开发零代码开发平台，有很多的特定行业的实践经验，现在要制作一个行业系统的宣传视频，需要先写文案，再在网上找素材，然后人工进行整合，往往一个视频做完需要一两周的时间，未来 RAG 结合企业内部的专业资料，此类视频就能瞬间完成了。</p><h2 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h2><p>RAG（Retrieval-Augmented Generation）作为 AI2.0 时代的杀手级应用，凭借其「检索-生成」双重机制，成功解决了传统大模型的诸多局限性。它不仅提升了生成内容的准确性和上下文相关性，还扩展了知识的覆盖范围。无论是在智能问答、内容生成还是知识发现等领域，RAG 都展现出了强大的应用潜力。</p><p>现在技术成熟度也非常完善，RAG 在企业落地已经不是遥不可及的事情了，后续会继续分享怎样进行 RAG 的落地。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在人工智能技术飞速发展的今天，各种创新和应用层出不穷。其中，RAG（Retrieval-Augmented Generation，检索增强生成）作为一种新兴的技术方法，正逐渐成为 AI 2.0 时代的杀手级应用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
    <category term="RAG" scheme="http://fwhyy.com/tags/rag/"/>
    
    <category term="机器学习" scheme="http://fwhyy.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在 .NET8 中获取 k8s 集群的 namespace id</title>
    <link href="http://fwhyy.com/2024/08/in-retrieve-the-namespace-id-of-the-k8s-cluster-in-net8/"/>
    <id>http://fwhyy.com/2024/08/in-retrieve-the-namespace-id-of-the-k8s-cluster-in-net8/</id>
    <published>2024-08-28T00:22:21.000Z</published>
    <updated>2024-09-30T16:23:34.006Z</updated>
    
    <content type="html"><![CDATA[<p>将程序和机器进行绑定是一种 License 校验的方法，需要能获取到机器的唯一标识，比如获取机器的 Mac 地址就是获取唯一标识的一种方式，命令如下：</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig |egrep &#x27;ether&#x27; |awk &#x27;&#123;&#123;print $2&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>但如果程序部署在 k8s 中，每次容器构建，使用上面命令获取的 Mac 地址就会发生变化，我使用 kubesphere 做测试发现的确如此。</p><p>那么在 k8s 环境中想要获取唯一标识应该怎么办呢？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、在 kubesphere 中，通常会以项目来进行组织，kubesphere 中的项目就是 k8s 中的 namespace，可以通过获取 namespace id 的方式来获取唯一标识。</p><p>2、.NET8 容器内部需要安装 kubectl 命令。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、构建 .NET8 底包镜像，供后面程序使用，Dockerfile 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:<span class="number">8.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 kubectl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -LO <span class="string">&quot;https://dl.k8s.io/release/<span class="subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line">chmod +x kubectl &amp;&amp; \</span><br><span class="line"></span><br><span class="line">mv kubectl /usr/local/bin/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 kubectl 已正确安装</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> kubectl version --client</span></span><br></pre></td></tr></table></figure><p>在 Dockerfile 所在目录执行下面命令进行镜像构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t net8-kube .</span><br></pre></td></tr></table></figure><p>2、编写示例程序获取 namespace id，获取 namespace id 的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace s2-test -o jsonpath=&#x27;&#123;.metadata.uid&#125;&#x27;</span><br></pre></td></tr></table></figure><p>创建一个 .NET8 的 WebAPI 项目，执行上面命令，并将结果输出，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);  </span><br><span class="line">  </span><br><span class="line">builder.Services.AddEndpointsApiExplorer();  </span><br><span class="line">builder.Services.AddSwaggerGen();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> app = builder.Build();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())  </span><br><span class="line">&#123;  </span><br><span class="line">    app.UseSwagger();  </span><br><span class="line">    app.UseSwaggerUI();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">app.UseHttpsRedirection();  </span><br><span class="line">  </span><br><span class="line">app.MapGet(<span class="string">&quot;/GetNamespaceId&quot;</span>, (<span class="built_in">string</span> name) =&gt;  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;id is empty&quot;</span>;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">string</span> cmd = <span class="string">&quot;kubectl get namespace &quot;</span>+name+<span class="string">&quot; -o jsonpath=&#x27;&#123;.metadata.uid&#125;&#x27;&quot;</span>;  </span><br><span class="line">            result= <span class="string">&quot;id is :&quot;</span>+ExecuteCommand(cmd);  </span><br><span class="line">        &#125;        catch (Exception ex)  </span><br><span class="line">        &#123;            Console.WriteLine(ex.Message);  </span><br><span class="line">        &#125;        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;)    .WithOpenApi();  </span><br><span class="line">  </span><br><span class="line">app.Run();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ExecuteCommand</span>(<span class="params"><span class="built_in">string</span> command</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">var</span> processInfo = <span class="keyword">new</span> ProcessStartInfo(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c \&quot;&quot;</span> + command + <span class="string">&quot;\&quot;&quot;</span>)  </span><br><span class="line">    &#123;        RedirectStandardOutput = <span class="literal">true</span>,  </span><br><span class="line">        RedirectStandardError = <span class="literal">true</span>,  </span><br><span class="line">        UseShellExecute = <span class="literal">false</span>,  </span><br><span class="line">        CreateNoWindow = <span class="literal">true</span>  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> process = <span class="keyword">new</span> Process &#123; StartInfo = processInfo &#125;;  </span><br><span class="line">    process.Start();  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">string</span> output = process.StandardOutput.ReadToEnd();  </span><br><span class="line">    process.WaitForExit();  </span><br><span class="line">    <span class="keyword">return</span> output.Trim();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、将程序发布，并在 publish 目录中创建 Dockerfile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> net8-kube:latest </span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app  </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;namespaceid.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在 publish 目录中执行 <code>docker build -t namespace-id-test .</code>  命令进行测试程序的镜像构建。</p><p>4、在 kubesphere 中创建一个 test 项目，在该项目中创建无状态负载部署示例程序，调用程序中的示例接口，发现 namespace id 并没有获取到，日志中有报错信息：</p><blockquote><p>Error from server (Forbidden): namespaces is forbidden: User “system:serviceaccount:test:default” cannot list resource “namespaces” in API group “” at the cluster scope</p></blockquote><p>这个错误表明，当前在容器内执行 <code>kubectl</code> 命令的用户（<code>system:serviceaccount:test:default</code>）没有足够的权限在集群范围内列出命名空间（<code>namespaces</code>）。这个问题通常与 k8s 中的角色绑定（RoleBinding）或集群角色绑定（ClusterRoleBinding）配置有关。</p><p>可以使用下面命令来查看对应账户是否有权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl auth can-i list namespaces --as=system:serviceaccount:test:default</span><br></pre></td></tr></table></figure><p>结果返回 yes 说明该 <code>ServiceAccount</code> 有权限，返回 no 说明没有权限。</p><p>一种简单的解决方法就是将账户绑定到管理员角色上，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding test-admin-binding \ --clusterrole=cluster-admin \ --serviceaccount=test:default</span><br></pre></td></tr></table></figure><p>但 cluster-admin 权限过大，在生产环境中不太安全，下面是用另一种方法来解决，在服务器中创建一个 <code>namespace_reader.yaml</code> 的文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">namespace-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;namespaces&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用下面命令执行后就创建了一个名为 <code>namespace-reader</code> 的角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f namespace_reader.yaml </span><br></pre></td></tr></table></figure><p>角色创建成功后，就可以将 <code>ServiceAccount</code> 绑定到这个只读角色了，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding test-namespace-reader-binding \</span><br><span class="line">--clusterrole=namespace-reader \</span><br><span class="line">--serviceaccount=test:default</span><br></pre></td></tr></table></figure><p>5、<code>ServiceAccount</code> 权限绑定后，再调用接口进行测试，会发现已经可以正常获取 namespace id 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将程序和机器进行绑定是一种 License 校验的方法，需要能获取到机器的唯一标识，比如获取机器的 Mac 地址就是获取唯一标识的一种方式，命令如下：&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term=".net8" scheme="http://fwhyy.com/tags/net8/"/>
    
    <category term="k8s" scheme="http://fwhyy.com/tags/k8s/"/>
    
    <category term="namespace" scheme="http://fwhyy.com/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>对提升项目效率的一点思考</title>
    <link href="http://fwhyy.com/2024/08/some-thoughts-on-improving-project-efficiency/"/>
    <id>http://fwhyy.com/2024/08/some-thoughts-on-improving-project-efficiency/</id>
    <published>2024-08-20T00:17:14.000Z</published>
    <updated>2024-09-30T16:20:00.962Z</updated>
    
    <content type="html"><![CDATA[<p>在一个软件企业中，项目实施效率非常重要，它关乎企业的竞争力，影响项目交付的速度和质量，关系到企业的盈利能力，甚至决定着企业的生死。</p><span id="more"></span><p>但当项目交付出现问题时，很多时候会粗暴地归结到人的能力上，要么人多了，要么人差了，那是不是两个差的换一个好的就能解决问题呢？</p><p>我觉得未必，有问题得找原因，找到原因，才能对症下药。</p><h2 id="效率低下的根源在哪里？"><a href="#效率低下的根源在哪里？" class="headerlink" title="效率低下的根源在哪里？"></a>效率低下的根源在哪里？</h2><p>在解决问题之前，我们必须先分析出其根源，否则改进措施很可能会事倍功半、南辕北辙。为此，我们需要问自己以下几个关键问题：</p><p>1、项目合同金额是否合理？ 下面一些情况是不合理的：</p><ul><li>新销售为了首次开单，故意压低价格</li><li>为了某个战略客户，低价中标占坑</li><li>报价时没有考虑到产品研发的成本</li></ul><p>金额低，没有钱赚，分不了项目奖金，积极性自然就不高。</p><p>2、说开发效率低到底指的是什么？ 这一问题往往有多个方面的因素，包括：</p><ul><li>研发人员技术能力的不足</li></ul><ul><li>流程与制度的不完善</li><li>团队沟通与协作的不顺畅</li><li>任务分配的不合理</li><li>实施方案的不是最优解</li><li>员工积极性的不足</li><li>工作量评估的误差</li><li>频繁的需求变更</li></ul><p>3、管理层的决策与执行是否到位？ 从部门负责人到项目经理，是否都能以客户价值为导向，并以降低公司成本为目标？</p><h2 id="数据驱动的根因分析"><a href="#数据驱动的根因分析" class="headerlink" title="数据驱动的根因分析"></a>数据驱动的根因分析</h2><p>有效的分析离不开数据支撑。我们需要从以下几个方面收集数据：</p><ul><li>项目的合同金额与投入成本，包括上线前的开发成本及验收前的调整成本</li><li>项目成员的具体工作内容</li><li>每个项目的盈亏情况</li><li>重点成本因素，如差旅、需求反复、特定需求的工作量评估超出预期等</li></ul><p>只有掌握了这些数据，才能科学地分析出问题的根源，并制定有针对性的应对措施。</p><h2 id="应对措施：流程、资源、工具"><a href="#应对措施：流程、资源、工具" class="headerlink" title="应对措施：流程、资源、工具"></a>应对措施：流程、资源、工具</h2><h3 id="1、优化流程与制度"><a href="#1、优化流程与制度" class="headerlink" title="1、优化流程与制度"></a>1、优化流程与制度</h3><p>流程和制度是保障项目顺利进行的关键。通过回顾过去的项目，尤其是那些曾暴露出问题的项目，我们可以识别出流程中的薄弱环节，并加以优化。此外，通过与同行分享经验，吸取教训，也能有效提升流和改进现有流程。</p><p>严格遵守公司流程，对公司来说可以减少很多低级错误的出现；对个人来说，是一种强有力的后盾，起到保护自己的作用。</p><h3 id="2、最佳实践"><a href="#2、最佳实践" class="headerlink" title="2、最佳实践"></a>2、最佳实践</h3><p>我们现在做的低代码平台进过这么多年的沉淀，能力变得越来越强，同时功能点也非常多，会导致达到同样一个目的会有很多种不同的路径。如果只是让项目经理或开发独自去完成，就有可能受限于他们的经验。</p><p>在长期的项目实践中，会积累了大量的经验和最佳实践。然而，在具体的项目中，由于个体经验的差异，可能导致不同的实现路径。如果缺乏集体讨论和经验分享，就可能错失效率提升的机会。因此，在项目需求调研后，进行一次集中讨论会，以确定最优的实现方案是非常必要的。</p><h3 id="3、改进项目管理模式"><a href="#3、改进项目管理模式" class="headerlink" title="3、改进项目管理模式"></a>3、改进项目管理模式</h3><p>举个例子：软件开发周期分为很多的步骤，有两个大的步骤是需求调研和代码开发。需求分析师调研完成后，形成需求文档，开发根据文档进行开发。这个过程看着就像是生产线上的两个环节，上下游直间定义好输入输出标准，就可以无缝对接。</p><p>按照上面的逻辑，一个部门专门和客户沟通，产出需求文档，一个部门专门做开发，是不是效率就高了呢？还真不一定，特别对于中小软件企业。</p><p>1、文档的颗粒度太粗，会导致沟通成本巨大，颗粒度太细，就会增加产出需求文档的时间成本，甚至出现开发等需求的情况。</p><p>2、对一些中小软件企业来说，一些不大的项目，项目经理、需求、开发、运维都是一个人就搞定了，分成多个部门后，小型项目也需要涉及到多人，效率是降低的。</p><p>所以说，现有的项目管理模式是否最优？是值得思考的一个问题。</p><h3 id="4、有效应对需求变更"><a href="#4、有效应对需求变更" class="headerlink" title="4、有效应对需求变更"></a>4、有效应对需求变更</h3><p>我一直以为客户不会故意为难我们，之所以我们感觉客户总是在进行变更。一个原因是没有解决用户的痛点问题。</p><blockquote><p>某项目的项目经理每天收集到很多的优化调整，项目经理按客户提出的逐一记录，并加班加点按时处理这些优化，最后却迟迟不能上线，因为客户领导最关注的一个页面没有完成。</p></blockquote><p>以这个例子来说，感觉上有很多的变更，但如果分清主次，把领导最关注的事情完成好，肯定是能顺利上线，至于业务提出的各种优化可能有很多是伪需求，是不需要处理的。</p><p>需求变更是项目过程中非常常见。我们需要明确客户的核心需求，避免在次要需求上浪费过多时间和资源。只有解决了用户的关键痛点，才能真正减少不必要的变更，提高项目上线效率。</p><h3 id="5、加强团队沟通与协作"><a href="#5、加强团队沟通与协作" class="headerlink" title="5、加强团队沟通与协作"></a>5、加强团队沟通与协作</h3><p>1、有的技术人员过于“独立思考”了，其实我认为独立思考和反馈、沟通是不冲突的。</p><p>2、团队成员平时都在忙于各个项目，如果团队或公司又没有组织团建活动，成员之间很多都不熟悉，在需要寻求帮助时，第一时间肯定是身边熟悉的人。</p><p>对此，有几个建议：</p><p>1、项目内部定期讨论会，听取团队成员的反馈和建议，再忙，一周一个小时总是能挤出来的。</p><p>2、不同项目之间可以定期分享，每个人在参与项目过程中总有自己的理解和感悟，分享出来对自己是一种锻炼，对其他人肯定也有帮助，再忙，一两个月半天时间总是有的，关键是能持续去做。</p><p>3、说服老板，多在工作日组织一些团建活动。</p><h3 id="6、工具化"><a href="#6、工具化" class="headerlink" title="6、工具化"></a>6、工具化</h3><p>当项目出现事故时，最终归因都是人的原因，是人的能力不行导致。整体效率不高也归因于人的能力。</p><p>一种简单的方式就是换人，还有一种方法就是工具化。很多时候，工具比人要稳定和可靠。</p><p>1、重复的、有规律可循的操作理论上都能工具化。我们的低代码平台在早期的时候，平台升级或发布应用时，部分操作需要手动执行 SQL。现在开发了专门的运维工具，里面包含应用发布、平台升级等功能，可以提升发布效率，也可以规避一些低级错误。</p><p>2、在项目实施过程中应该也有很多的场景可以进行工具化，来提升效率。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>人、公司在变、客户也在变，效率的提升我觉得是一个长期持续的事情，需要不断进行思考、发现问题、分析问题、找解决措施、实践。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个软件企业中，项目实施效率非常重要，它关乎企业的竞争力，影响项目交付的速度和质量，关系到企业的盈利能力，甚至决定着企业的生死。&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="思考" scheme="http://fwhyy.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>读《华为项目管理之道》</title>
    <link href="http://fwhyy.com/2024/08/read-the-way-of-huawei-project-management/"/>
    <id>http://fwhyy.com/2024/08/read-the-way-of-huawei-project-management/</id>
    <published>2024-08-07T00:11:47.000Z</published>
    <updated>2024-09-30T16:13:30.060Z</updated>
    
    <content type="html"><![CDATA[<p>在《软技能》一书中，提到将自己当作一个企业来思考，这其中的一个关键点就是要学会换位思考。做项目也是一样，需要换位思考，同时我们也能将很多事情都能理解为一个项目，例如：写系列文章、组织一次自驾游、产品开发等等，只不过这些项目的甲方可以是自己、家属、老板等。</p><span id="more"></span><p>不同类型的项目应该都能找到共同之处，在管理上也能采用相同的方法。最近读了《华为项目管理之道》，书中提到了很多的认知模型和能力模型 (比如：HEROS 模型、BEST 模型、SOBEST 模型等)，属于大而全，而我们只需要结合自身情况，灵活使用，不管对个人成长还是对管理项目，相信都能受益匪浅。</p><p>书中把项目的管理分为了八个大的章节，分别是：发展之道、交付之道、用将之道、治理之道、数智之道、文化之道、价值之道、未来之道。我结合书中的知识和自己的理解来谈谈项目管理。</p><h2 id="什么是软件项目？"><a href="#什么是软件项目？" class="headerlink" title="什么是软件项目？"></a>什么是软件项目？</h2><p>谈到项目一般会涉及甲乙双方，甲方的相关人提出诉求，乙方的以软件的形式进行交付，来满足甲方相关人的利益，给甲方带来价值。</p><p>这里面甲方的相关利益人叫干系人，乙方为了能交付软件，需要有一系列的角色和过程来确保项目的顺利进行。这就形成了项目的团队和管理制度。</p><p>其中甲方的干系人非常关键，在《有效需求分析》一书中也有大量的篇幅讲解干系人的重要性，这是项目是否能成功的一个很关键的因素。</p><h2 id="项目的目标"><a href="#项目的目标" class="headerlink" title="项目的目标"></a>项目的目标</h2><p>书中一直在强调项目存在的唯一价值就是坚定不移为客户创造价值，同时实现自己的价值。甚至有一个大的章节站门来阐述。</p><p>怎样来给客户带来价值？最重要的就是把控进度、提升质量。也就是书中提到的进度目标和质量目标。</p><ul><li>进度目标：任何一个项目都必须有明确的目标，有了明确的目标才能够制订清晰的项目计划，各项工作才能有序开展。</li><li>质量目标：项目质量目标包括可交付软件的质量、项目管理质量和客户满意度。</li></ul><p>举个例子：</p><p>一个核心业务系统对客户来说，稳定性是至关重要的。这时客户提出了新增和优化需求，当这些需求在新版本的产品中已经提供支持的时候，有两种选择：</p><p>1、将系统升级到最新的版本；</p><p>2、在原有版本中进行需求的开发。</p><p>第一直觉给出的方案通常是第二种，因为可以使用最新版本、后期可能会更容易维护、现阶段也能做更少的开发。</p><p>但如果目标是给客户提供价值，可以尝试提出一些问题？</p><ul><li>客户很关注系统是否是新版本吗？</li><li>除了客户提出的优化需求，新版本中其他的功能客户是否有兴趣？</li><li>新版本中 UI 的调整是否符合用户的习惯？</li><li>客户目前版本和最新版本是否存在较大差异？升级是否会带来不稳定？</li><li>升级是否能做到无缝？是否需要​更长时间的停机？</li></ul><p>好好思考这些问题，想想客户究竟需要什么？最终的答案可能还是升级到最新版本，但也能做到心里有底，知道这就是一个正确的方案。</p><h2 id="项目管理的流程"><a href="#项目管理的流程" class="headerlink" title="项目管理的流程"></a>项目管理的流程</h2><p>项目的流程通常分为：项目启动、项目规划、项目执行、项目监控、项目关闭。在书中谈到了在这整个周期内如何 「做正确的事、正确地做事、把事做正确」的典型模型、套路和方法，简称项目管理「十八般武艺」。</p><p>流程规范不是只在大公司适用，中小公司更应该进行规范，只是相比较大公司而言可以做适当的裁剪。而这恰恰是中小公司容易忽视的。小的乙方面对大的甲方，本来就处于弱势，而制定的这些流程规范就是在面对乙方时强有力的后盾。</p><p>所以说这十八般武艺非常值得参考和借鉴。</p><h2 id="项目管理的模式"><a href="#项目管理的模式" class="headerlink" title="项目管理的模式"></a>项目管理的模式</h2><p>项目管理模式有以前传统的瀑布型、也有后来流行的敏捷型，随着互联网的发展，低代码、零代码平台的兴起，管理模式变成了增量型。</p><p>比如：依靠 aPaaS 平台的能力快速构建出第一个版本，然后甲乙双方共同来完善系统，甲方在使用过程中可以不断提出优化点，乙方借助平台能力能够快速响应。最终以统计工作量的方式进行结算。</p><p>对甲方来说，前期可以快速上线进行验证，中期可以随时调整，以迭代的方式不断演进。这种方式可以更好地持续实现企业价值。</p><h2 id="需求优先级"><a href="#需求优先级" class="headerlink" title="需求优先级"></a>需求优先级</h2><p>客户想要的远比你能给的多的多。这时就需要分优先级了。书中介绍了项目需求管理的 BAS 分析：</p><ul><li>B（basic）：基本需求（核心业务功能和特性）</li><li>S（satisfied）：满意度需求（增值或附加业务）</li><li>A（attractive）：兴奋型需求（少数特定场景的需求）</li></ul><blockquote><p>在项目启动时，「人」和「事」是重中之重。干系人管理回答了「人」的问题，项目范围管理的对象就是「事」，它是对项目所期望的最终产品和可交付成果，以及为实现可交付成果所需的各项具体工作的简明描述。</p></blockquote><p>我觉得能把 B 做好就非常不容易了，所以需要按照 BSA 模型对需求进行分类排序，给该客户提交了分批次交付的计划。重点是需要能对需求进行识别，并按照 B、S、A 进行排序，分清主次。最怕的就是辛辛苦苦做了一堆功能，最后客户重点关注的功能却没有实现。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>书中的内容远不止上面谈到的这些，上面内容是一些印象深刻并且有共鸣的地方，可能一段时间后再翻翻这本书又会有新的感受。</p><p>好的书跟做项目一样，需要不断迭代，看完，写写笔记，一段时间后，再翻翻，再写写，这应该就是常读常新吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在《软技能》一书中，提到将自己当作一个企业来思考，这其中的一个关键点就是要学会换位思考。做项目也是一样，需要换位思考，同时我们也能将很多事情都能理解为一个项目，例如：写系列文章、组织一次自驾游、产品开发等等，只不过这些项目的甲方可以是自己、家属、老板等。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="项目管理" scheme="http://fwhyy.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    <category term="项目管理之道" scheme="http://fwhyy.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B9%8B%E9%81%93/"/>
    
    <category term="华为" scheme="http://fwhyy.com/tags/%E5%8D%8E%E4%B8%BA/"/>
    
  </entry>
  
  <entry>
    <title>崇礼168越野赛 MTC 70 公里完赛复盘</title>
    <link href="http://fwhyy.com/2024/07/chong-168-off-road-race-mtc-70-km-final-round-recap/"/>
    <id>http://fwhyy.com/2024/07/chong-168-off-road-race-mtc-70-km-final-round-recap/</id>
    <published>2024-07-24T00:12:53.000Z</published>
    <updated>2024-09-30T16:04:29.280Z</updated>
    
    <content type="html"><![CDATA[<p>在《我的人生首野——大岩山萧绍古道 30 公里》文章的最后写道：“下一站：2024 年崇礼 168 越野赛70 公里。”</p><p>这个目标在上个周末轻松实现了。</p><span id="more"></span><h2 id="赛事介绍"><a href="#赛事介绍" class="headerlink" title="赛事介绍"></a>赛事介绍</h2><p>崇礼 168 超级越野赛是一项在河北省张家口市崇礼区举办的大型群众参与型越野跑赛事。自 2017 年创立以来，已经成为华北地区乃至全国组别最多、规模最大、影响力最强的赛事之一。也有人说是亚洲最大的越野赛事。</p><p>2024 年的赛事进行了进一步的优化和升级，共设置 7 个组别，覆盖从 168 公里的超长距离到 10 公里的短距离，以满足不同跑者的需求。我比较关注的 70 公里组别也做了优化，距离只有 66.9 km，爬升 3000 左右，难度比 23 年有所下降。</p><h2 id="海拔"><a href="#海拔" class="headerlink" title="海拔"></a>海拔</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232040588.webp"></p><p>崇礼的海拔平均 1000 多，70 公里赛道的最低海拔 1200 ，起点 1600 多，最高有 2000 多。记得之前听到有人分享跑兰州马拉松，因为海拔原因，和平原上相比，心率更高、体感更累。</p><p>到了崇礼后，并没有什么特别的感觉，心率呼吸都比较正常，比赛时，不管是夜里还是第二天白天，也都没有不适，反倒是因为比较低的温度，跑起来感觉非常舒服。</p><h2 id="气候"><a href="#气候" class="headerlink" title="气候"></a>气候</h2><p>赛前很多人跟我说过，崇礼的晚上是很冷的，而且，海拔高，气候多变，如果遇上下雨，很容易导致失温。我自认为不算很怕冷，但对崇礼的冷还是多了一份敬畏。</p><p>除了晚上气温低，最担心的就是下雨，然而就在赛前的一两天，在选手群里得知崇礼不光下雨，还下了冰雹，雷阵雨那更是时不时就会来一阵。</p><p>7 月 12 号坐在从武汉去北京的火车上，在手机上看着崇礼168 越野赛 100 公里比赛的直播，终于见识到了崇礼天气的多变。</p><p>13 号下午达到崇礼后又是艳阳高照，领物时衣服都全汗湿了，幸运的是这种好天气一直持续到了比赛结束。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232001206.webp"></p><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><p>1、2024 年截止到比赛前有将近 1800 公里的跑量，平均一个月 250+ ，这些跑量是基础，也是因为有这些跑量，才让我有信心完成比赛。</p><p>2、吸取了去年 12 月份大岩山 30 公里越野的教训，在赛前的一两个月有刻意训练爬坡，6 月份的跑步爬升有 4000 多，加上爬楼梯，应该有 5000 左右。</p><p>3、准备了足够多的补给、12 根能量胶、将近 30 颗盐丸、3 颗醒力速、3 条能量棒，另外强制装备也是只多不少，足足有十来斤重，跑完腿还行，肩膀特别酸痛。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232003111.webp"></p><h2 id="群友见面"><a href="#群友见面" class="headerlink" title="群友见面"></a>群友见面</h2><p>13 号下午到达领物现场，在终点的摄影区域找到了南哥，南哥百忙之中还过来合了张影。领物后找了一个钟点房休息，5 点多从酒店出来走向庆典广场，半路上，身上穿的跑着日历 T恤被佳凝认出来了，我一抬头发现是佳凝，还有 Lin、小腾、曼、葱神等，赶紧自报家门。所有人一起站在终点的通道旁为到完赛的选手加油。</p><p>很快，大K、累累、Chris 也达到了庆典广场和大部队汇合了，等他们领完物，我们一起去吃了铁锅炖，这时天空下起了小雨，好在只是很短暂的一阵雨。</p><p>作为超级 I 人的我，平时跑步都是一个人，很少经历这种场面，这么多人，除了 Chris ，其他都是初次见面，但却是十分熟悉的感觉。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232010140.webp"></p><h2 id="星光之旅，准备出发"><a href="#星光之旅，准备出发" class="headerlink" title="星光之旅，准备出发"></a>星光之旅，准备出发</h2><p>晚饭后我和大K回酒店收拾东西，准备出发去起点，起点在雪如意。大K 是唯一和我一起跑 70 公里的群友。</p><p>将近 9 点，从酒店出发，去庆典广场坐摆渡车，还和公司跑 ETC 组别的同事叮叮在广场见了个面，最后很幸运赶上了最后一班摆渡车。半个多小时就到了雪如意。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232012799.webp"></p><p>这时离 11 点半起跑还有两个多小时，正好有时间拍照、合影，期间还接受了佳凝和南哥的采访。后来还意外发现了很早关注的跑步博主：陈刚和高哈哈，也实现了第一次和名人合影。</p><p>很快，主持人就开始指导大家打开 GPS、做热身运动，因为马上就要鸣枪起跑了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232018471.webp"></p><h2 id="初次夜跑"><a href="#初次夜跑" class="headerlink" title="初次夜跑"></a>初次夜跑</h2><p>我很喜欢在黑夜里跑步，所以我喜欢冬天的早晨，从黑夜跑到黎明，路上几乎碰不到一个人，只能听到自己的呼吸声和脚步声。</p><p>之前看过轲影像拍摄的 2023 年 MTC 组别的视频，非常震撼，一条由头灯组成的巨龙在山野中蔓延。没想到此刻，我正站在 MTC 的起跑线上。</p><p>11 点 30 分，准时发枪起跑，一开始我和大K 还是在一起，我知道自己的爬坡能力很弱，在一个下坡的时候，我跟大K 说，我先跑，一会儿上坡我就慢了。果不其然，下一个上坡的时候，大K 就追上了我，并且超过了我，这也是我在赛道上最后一次见到大K。</p><p>夜晚的崇礼，或许是因为没有下雨的缘故，没有想象的冷，上面穿一件长袖的羊毛 T，下面压缩裤加上腿套，感觉刚刚好。我很容易出汗，几公里后，衣服已经湿透，在山上吹着风感觉很舒服，并不觉得冷。</p><p>14 号凌晨两三点，这时已经跑了 3 个小时了，但并不觉得困，还是停下来吃了一颗醒力速，含到最后嘴里有一种很奇怪的感觉，好一会才缓过来。</p><p>由于没有经验，选择的头灯没有黄光，在大雾的夜晚能见度不是很好，好在人很多，不管速度快与慢，100 米范围内肯定会有很多的炮友一起。</p><p>4 点多，天空渐渐泛白，仍然没有一丝困意，收起头灯，继续前行。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232024386.webp"></p><h2 id="阿那亚的私补"><a href="#阿那亚的私补" class="headerlink" title="阿那亚的私补"></a>阿那亚的私补</h2><p>跑到阿那亚，就意味着完成了 55 公里、意味着只剩下 12 公里就到终点了、意味着剩余的爬升只有 500 多米。</p><p>在我快达到阿那亚的时，南哥、佳凝正在阿那亚给跑者日历的朋友进行私补。进站之前发现路边有水龙头，于是过去把脸洗了洗，所以见到南哥、佳凝时，他们感觉我状态还可以。</p><p>喝了几杯椰子水，南哥给拍了几张照片就进站了，后来才知道佳凝一直在拍着视频。进站后碰到了累累、简单聊了几句，当时 9 点 50 多，我说一会 10 点再出发吧，然后就去补水吃西瓜，找椅子坐下抹防晒，刚准备玩会手机，累累就过来说，时间到了，该出发了。</p><p>哎，这也太严格了，内心其实想再歇十分钟的，但还是起身和累累一起出发了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232030517.webp"></p><h2 id="永远到不了的星芒"><a href="#永远到不了的星芒" class="headerlink" title="永远到不了的星芒"></a>永远到不了的星芒</h2><p>累累太拼了，从阿那亚出来的一段平路直接干到了 5 分配，我勉强跟上，后来到了上坡阶段，实在跟不上，就让她先走了。</p><p>阿那亚到星芒是整个赛道最难的一段，6 公里，500 多的爬升。</p><p>整个爬升分为两大段，第一段很陡，我几乎是爬了 20 米爬升就得站在一边休息休息，最幸福的就是遇到 “大堵车”，有充分的休息时间。第一段到顶就能看见对面山顶的星芒餐厅了。总算是有一个目标，但星芒餐厅看着这么近，却那么远。</p><p>接着就是下山、经历一段长的防火道、又继续上山、翻过几个山头，星芒餐厅时不时闪现一下，但距离并没有拉近，似乎我在走，星芒也在以同样的速度走着。</p><p>最后花了两个多小时才到达星芒餐厅，星芒餐厅的西瓜和可乐让人记忆深刻。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232033977.webp"></p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>1、因为大雾，没能看到崇礼的日出，等雾散去，已经艳阳高照了。</p><p>2、终点前碰到了车老板，合影时手机没电关机了，要知道作为一个 I 人，主动去合影是非常不容易的。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232034275.webp"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>1、平时的训练多一分努力，赛道上就少一分痛苦。</p><p>2、跑越野，爬坡训练非常重要，楼梯或爬楼机效果非常显著，如果上坡能快走不停，平路和下坡跑一跑，就已经是高手了。</p><p>3、补给尽可能吃自然食物，能量胶作为补充。</p><p>4、盐丸非常重要，特别对于易出汗人群，这次跑完没有抽筋，除了跑量作为基础，盐丸起了很大的作用。</p><p>5、越野跑确实比马拉松要好玩，就像纸巾老湿说的：“你跑的时候是赛道，停下来的时候就是风景”。</p><p>6、对大自然要充满敬畏，不行就退，站在起跑线上的那一刻就已经很牛逼了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407232037321.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在《我的人生首野——大岩山萧绍古道 30 公里》文章的最后写道：“下一站：2024 年崇礼 168 越野赛70 公里。”&lt;/p&gt;
&lt;p&gt;这个目标在上个周末轻松实现了。&lt;/p&gt;</summary>
    
    
    
    <category term="跑步" scheme="http://fwhyy.com/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
    <category term="跑步" scheme="http://fwhyy.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
    <category term="越野跑" scheme="http://fwhyy.com/tags/%E8%B6%8A%E9%87%8E%E8%B7%91/"/>
    
    <category term="崇礼" scheme="http://fwhyy.com/tags/%E5%B4%87%E7%A4%BC/"/>
    
    <category term="MTC" scheme="http://fwhyy.com/tags/mtc/"/>
    
    <category term="70公里" scheme="http://fwhyy.com/tags/70%E5%85%AC%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>Mac环境下的vi工具，我选择NvChad</title>
    <link href="http://fwhyy.com/2024/07/i-choose-nvchad-as-the-vi-tool-for-mac-environment/"/>
    <id>http://fwhyy.com/2024/07/i-choose-nvchad-as-the-vi-tool-for-mac-environment/</id>
    <published>2024-07-04T15:57:02.000Z</published>
    <updated>2024-09-30T15:59:02.461Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器中操作一些文本时，经常会用到 vi 工具，否则就得把文件拷贝到本地，修改完再传到服务器，非常麻烦。</p><p>那么在 Mac 中 vi 有什么用呢？我并不追求将每一种工具都打造成全能的 IDE 。尽管对于编写代码，我们有像 VS Code、Rider、IntelliJ IDEA 这样成熟且功能丰富的集成开发环境，但若只是为了查看代码，我发现 <code>vi</code> 依然是一个非常便利的选择。</p><span id="more"></span><p>一折腾发现，vi 并不只是 vi，又有 Vim、Neovim、NvChad 等，下面先看看这些都是什么？有什么区别？</p><p>1、<strong>vi</strong>：是 Unix 和类 Unix 系统中最传统的文本编辑器之一，在 Mac 中也默认提供。由 Bill Joy 在 1970 年代末为 BSD Unix 开发。它是一个模式化的编辑器，具有多种模式，如普通模式、插入模式等。</p><p>2、<strong>Vim</strong>：代表 “Vi IMproved”，是一个由 Bram Moolenaar 开发的文本编辑器，它是 vi 的一个增强版。<code>vim</code> 增加了很多特性，比如语法高亮、标签页、窗口分割、宏录制、正则表达式支持等，使其成为程序员和开发者广泛使用的编辑器。</p><p>3、<strong>Neovim</strong>：是 Vim 的一个重构版本，致力于成为 Vim 的超集。Neovim 和 Vim 配置文件采用相同的语法，所以 Vim 的配置文件也可以用于 Neovim。Neovim 的第一个版本在2015年12月发行，并且能够完全兼容 Vim 的特性。</p><p>相比于 Vim，Neovim 的主要改进在于其支持异步加载插件。此外，Neovim 的插件可以用任意语言编写，而 Vim 的插件仅能使用 Vimscript 进行编写。</p><p>4、<strong>NvChad</strong>：是一个基于 <code>Neovim</code> 的配置，给我们提供一个开箱即用的、高度可定制的开发环境。它集成了许多插件和工具，以提供类似于 IDE 的功能，但仍然保持了 <code>Neovim</code> 的轻量级和灵活性。和 NvChad 同类的工具还有 LazyVim 、LunarVim 等，选择 NvChad 是因为 NvChad 的官网比较好看：<a href="https://nvchad.com/">https://nvchad.com/</a></p><p>简单来说，<code>Vim</code> 是 <code>vi</code> 的改进版，而 <code>Neovim</code> 是对 <code>Vim</code> 的现代化重构。<code>NvChad</code> 则是基于 <code>Neovim</code> 的一个配置，提供了一套丰富的插件和工具集，以增强用户体验。</p><p>下面就开始来安装了。</p><h2 id="NvChad-安装"><a href="#NvChad-安装" class="headerlink" title="NvChad 安装"></a>NvChad 安装</h2><h3 id="1、安装-Neovim"><a href="#1、安装-Neovim" class="headerlink" title="1、安装 Neovim"></a>1、安装 Neovim</h3><p>因为 NvChad 是基于 Neovim，所以首先安装 Neovim，Neovim 的官网地址是：<a href="https://neovim.io/%EF%BC%8C%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%E4%B9%9F%E4%BB%A5%E5%90%8E%E5%BE%88%E5%A4%9A%E7%A7%8D%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%EF%BC%9Ahttps://github.com/neovim/neovim/blob/master/INSTALL.md">https://neovim.io/，安装方式也以后很多种，可以参考：https://github.com/neovim/neovim/blob/master/INSTALL.md</a> 。</p><p>我是使用下面命令进行安装的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install neovim</span><br></pre></td></tr></table></figure><h3 id="2、安装-Nerd-Font"><a href="#2、安装-Nerd-Font" class="headerlink" title="2、安装 Nerd Font"></a>2、安装 Nerd Font</h3><p>安装这个字体主要目的是显示一些图标，比如文件树中的文件夹图标和不同文件的类型图标等。在《Mac中的常用 shell工具》中也有介绍到。</p><ul><li>官网：<a href="https://www.nerdfonts.com/">https://www.nerdfonts.com/</a></li><li>Github地址：<a href="https://github.com/ryanoasis/nerd-fonts.git">https://github.com/ryanoasis/nerd-fonts.git</a></li></ul><p>我使用的是 Github 方式进行安装，首先将 git 代码拉到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ryanoasis/nerd-fonts.git --depth 1</span><br></pre></td></tr></table></figure><p>进入 nerd-fonts 目录，执行 <code>./install.sh</code> 进行安装，安装完后，可以在 iTerm2 的设置中进行字体设置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407040818604.webp"></p><h3 id="3、安装-NvChad"><a href="#3、安装-NvChad" class="headerlink" title="3、安装 NvChad"></a>3、安装 NvChad</h3><p>使用下面命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/NvChad/starter ~/.config/nvim &amp;&amp; nvim</span><br></pre></td></tr></table></figure><p>参考：<a href="https://nvchad.com/docs/quickstart/install">https://nvchad.com/docs/quickstart/install</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407040818919.webp"></p><h2 id="NvChad-配置和使用"><a href="#NvChad-配置和使用" class="headerlink" title="NvChad 配置和使用"></a>NvChad 配置和使用</h2><h3 id="1、配置快捷方式"><a href="#1、配置快捷方式" class="headerlink" title="1、配置快捷方式"></a>1、配置快捷方式</h3><p>使用命令 <code>vi ~/.zshrc </code> 编辑配置文件，在最后添加下面代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias vi=nvim</span><br></pre></td></tr></table></figure><p>保存后，执行 <code>source  ~/.zshrc</code> 生效。设置后，直接输入 vi filename 就是直接使用 Neovim 打开。效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407040822102.webp"></p><h3 id="2、主题切换"><a href="#2、主题切换" class="headerlink" title="2、主题切换"></a>2、主题切换</h3><p>首先切换到 vi 的普通模式，然后输入 <code>空格+th</code> 就会出现下图界面，可以鼠标上下移动看预览效果，选择喜欢的回车确认即可。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407040819367.webp"></p><h3 id="3、呼出左侧文件树"><a href="#3、呼出左侧文件树" class="headerlink" title="3、呼出左侧文件树"></a>3、呼出左侧文件树</h3><p>切换到 vi 的普通模式，输入 <code>ctrl+n</code> ，就可以打开文件树，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202407040819763.webp"></p><h2 id="vi-基本知识"><a href="#vi-基本知识" class="headerlink" title="vi 基本知识"></a>vi 基本知识</h2><p>之前使用 vi ，因为只是偶尔在服务器上进行文件编辑，是会一些简单的操作，例如：</p><ul><li>dd 删除一整行</li><li>:q 退出</li><li>:x 保存退出</li></ul><p>但实际 vi 功能非常强大，如果能熟练使用，效率会大大提升。</p><h3 id="vi-的常见模式"><a href="#vi-的常见模式" class="headerlink" title="vi 的常见模式"></a>vi 的常见模式</h3><p>1、<strong>普通模式（Normal Mode）</strong>：</p><ul><li>这是 Vim 启动时的默认模式。在这个模式下，你可以移动光标、复制、粘贴、删除文本，但不能直接输入文本。</li><li>按下 <code>Esc</code> 键可以进入或返回普通模式。</li></ul><p>2、<strong>插入模式（Insert Mode）</strong>：</p><ul><li>在这个模式下，可以插入文本。</li><li>在普通模式下按 <code>i</code>、<code>I</code>、<code>a</code>、<code>A</code>、<code>o</code>、<code>O</code>等键可以进入插入模式。</li></ul><p>3、<strong>命令行模式（Command-line Mode）</strong>：</p><ul><li>用于输入命令，如查找、替换、保存文件等。</li><li>在普通模式下按 <code>: </code>进入命令行模式。</li></ul><p>4、<strong>可视模式（Visual Mode）</strong>：</p><ul><li>允许你选择文本块，然后对选中的文本执行操作，如复制、删除或替换。</li><li>快捷键：按下 <code>v</code> 进入可视模式，选择字符；<code>V </code>进入可视行模式；<code>Ctrl+V </code>进入可视块模式。</li></ul><h3 id="Normal-模式操作"><a href="#Normal-模式操作" class="headerlink" title="Normal 模式操作"></a>Normal 模式操作</h3><ul><li>hjkl：上下左右</li><li>gg：调到第一行</li><li>G：调到最后一行</li><li>ctrl+u：往上翻一页</li><li>ctrl+d：往下翻一页</li><li>{lineno}+gg：跳转到指定行，lineno 为指定行的行号</li></ul><p>从 Normal 进入 Insert 模式：</p><ul><li>i：表示 insert ，从当前光标之前开始输入</li><li>a：表示 append，从当前光标之后开始输入</li><li>o：下方插入新的一行，然后开始输入</li><li>s：删除当前光标的字符，然后开始输入</li><li>I：大写 i，在本行的开头开始输入</li><li>A：在本行的末尾开始输入</li><li>O：上方插入新的一行，然后开始输入</li><li>S：删除当前行，然后开始输入</li></ul><h3 id="Command-模式操作"><a href="#Command-模式操作" class="headerlink" title="Command 模式操作"></a>Command 模式操作</h3><p>在 Normal 模式下输入西文冒号进入 Command 模式</p><ul><li>:w：保存当前文件</li><li>:q：退出</li><li>:q!：放弃当前更改，然后退出</li><li>:wq：保存当前更改，然后退出，还有一个简洁的命令 :x 也是相同的作用</li><li>:h {command}：显示关于命令的帮助</li><li>按 Esc 回到 Normal 模式</li></ul><h3 id="Visual-模式操作"><a href="#Visual-模式操作" class="headerlink" title="Visual 模式操作"></a>Visual 模式操作</h3><p>在 Normal 模式下按 v 进入可视模式</p><ul><li>进入可视模式后可以用 Normal 模式下的移动命令选择文本</li><li>可视模式下，x/y ：剪切/复制；回到 Normal 模式下按 p 进行粘贴</li><li>Normal 模式下按 V 进入行可视模式，一次选中一整行</li><li>按 Esc 回到 Normal 模式</li></ul><h3 id="其他高效光标移动"><a href="#其他高效光标移动" class="headerlink" title="其他高效光标移动"></a>其他高效光标移动</h3><p>在 Normal 模式下使用 hjkl 可以进行简单的光标移动，这种移动不太高效，下面介绍几种高效的移动：</p><ul><li><p>w：表示 word，跳转到下一处单词的开头</p></li><li><p>b：表示 back，跳转到上一处单词的开头</p></li><li><p>e：表示 end ，跳转到下一处单词的结尾</p></li><li><p>ge：e 的反向版本，跳转到上一处单词的结尾</p></li><li><p>^/$ ：跳转到本行的开始/结尾</p></li><li><p>%：跳转到匹配的配对符号（括号等），这个在浏览代码时很有用</p></li></ul><h3 id="几个-vim-学习的网站"><a href="#几个-vim-学习的网站" class="headerlink" title="几个 vim 学习的网站"></a>几个 vim 学习的网站</h3><p><a href="https://vim.nauxscript.com/">https://vim.nauxscript.com/</a></p><p><a href="https://dofy.gitbook.io/learn-vim/zh-cn">https://dofy.gitbook.io/learn-vim/zh-cn</a></p><p><a href="https://vim.is/#exercise">https://vim.is/#exercise</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Vim 的使用，如果一直都只用几个常用命令，那还不如去使用 vs code 或其他的编辑器，使用 Vim 就得深入用起来，强迫自己使用各种高效的操作方式，直到这些操作变成肌肉记忆。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在服务器中操作一些文本时，经常会用到 vi 工具，否则就得把文件拷贝到本地，修改完再传到服务器，非常麻烦。&lt;/p&gt;
&lt;p&gt;那么在 Mac 中 vi 有什么用呢？我并不追求将每一种工具都打造成全能的 IDE 。尽管对于编写代码，我们有像 VS Code、Rider、IntelliJ IDEA 这样成熟且功能丰富的集成开发环境，但若只是为了查看代码，我发现 &lt;code&gt;vi&lt;/code&gt; 依然是一个非常便利的选择。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="mac" scheme="http://fwhyy.com/tags/mac/"/>
    
    <category term="nvchad" scheme="http://fwhyy.com/tags/nvchad/"/>
    
    <category term="nvim" scheme="http://fwhyy.com/tags/nvim/"/>
    
    <category term="vi" scheme="http://fwhyy.com/tags/vi/"/>
    
    <category term="vim" scheme="http://fwhyy.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2 会话管理以及其他常用设置</title>
    <link href="http://fwhyy.com/2024/06/iterm2-session-management-and-other-commonly-used-settings/"/>
    <id>http://fwhyy.com/2024/06/iterm2-session-management-and-other-commonly-used-settings/</id>
    <published>2024-06-20T00:53:37.000Z</published>
    <updated>2024-09-30T15:54:54.999Z</updated>
    
    <content type="html"><![CDATA[<p>在《我在 Mac 中试过用的那些 shell 工具》中最后介绍 iTerm 的安装以及基本使用，但有一个很重要的功能没有介绍，那就是会话管理。</p><p>本文介绍 iTerm2 的会话管理以及一些其他配置。</p><span id="more"></span><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>iTerm2 的会话管理没有那么直观，但功能很强大。下面介绍两种方式的会话：直连和跳板机</p><h3 id="直连"><a href="#直连" class="headerlink" title="直连"></a>直连</h3><p>1、在 .ssh 目录中创建文件 iterm2login.sh ，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"></span><br><span class="line">set timeout 10</span><br><span class="line"></span><br><span class="line">set ip &quot;111.22.33.44&quot;</span><br><span class="line">set port &quot;12345&quot;</span><br><span class="line">set username &quot;root&quot;</span><br><span class="line">set password &quot;abc\$123&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh -p $port $username@$ip</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;yes/no&quot; &#123;send &quot;yes\r&quot;;exp_continue;&#125;</span><br><span class="line">  &quot;*password:*&quot; &#123; send &quot;$password\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interact</span><br></pre></td></tr></table></figure><ul><li>上面的 ip 、port、username、password 为定义的变量，并且赋值给了变量，这种方式是将这些值固定在脚本文件中，当然，也可以以接收参数的方式</li><li>使用变量的时候使用 $ 加上变量名，例如：$ip</li><li>正因为使用时前面加上了 $ 符号，如果用户名或密码中包含 $ 时，需要进行转义，例如：密码为 abc$123，设置时为 <code>set password &quot;abc\$123&quot;</code></li></ul><p>2、输入 <code>Command+,</code> 打开 iTerm2 的设置界面，如下图，点击加号添加一个新的 Profile ：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191534177.webp"></p><p>3、进行配置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191534240.webp"></p><ul><li>Shortcut key 配置，可以配置一个快捷键，在需要的时候直接输入快捷键就能进入远程服务器</li><li>Command 选择 Login Shell</li><li>因为上面的 iterm2login.sh 是没有参数的，所以 Send text as start 直接配置这个文件名即可</li></ul><h3 id="跳板机"><a href="#跳板机" class="headerlink" title="跳板机"></a>跳板机</h3><p>有一种场景是一台外网服务器作为跳板机，先远程到外网服务器，再从外网服务器连接到内网服务器。通过配置可以实现，直接通过跳板机登录到内网。</p><p>1、在 .ssh 目录中创建文件 iterm2login_inner.sh ，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line"></span><br><span class="line">set timeout 10</span><br><span class="line"></span><br><span class="line">set ip &quot;111.22.33.44&quot;</span><br><span class="line">set port &quot;12345&quot;</span><br><span class="line">set username &quot;root&quot;</span><br><span class="line">set password &quot;abc\$123&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从命令行参数获取内网服务器的IP、用户名和密码</span></span><br><span class="line">set internal_ip [lindex $argv 0]</span><br><span class="line">set internal_username [lindex $argv 1]</span><br><span class="line">set internal_password [lindex $argv 2]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录跳板机</span></span><br><span class="line">spawn ssh -p $port $username@$ip</span><br><span class="line"></span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;yes/no&quot; &#123;send &quot;yes\r&quot;;exp_continue;&#125;</span><br><span class="line">  &quot;*password:*&quot; &#123; send &quot;$password\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录内网</span></span><br><span class="line">expect &quot;# &quot; &#123;send &quot;ssh  $internal_username@$internal_ip\r&quot;&#125;</span><br><span class="line">expect &#123;</span><br><span class="line">  &quot;yes/no&quot; &#123;send &quot;yes\r&quot;;exp_continue;&#125;</span><br><span class="line">  &quot;*password:*&quot; &#123; send &quot;$internal_password\r&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>外网服务器的地址直接配置在文件中</li><li>internal_ip、internal_username、internal_password 为三个命令行参数变量，有了变量，多个服务器就能复用一个模板，传递不同的参数就行</li></ul><p>2、profile 的配置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191534028.webp"></p><ul><li>在文件名后按照参数的顺序分别填 ip、username、password，以空格隔开</li><li>密码中如果有 $ 符号，需要进行转义</li></ul><h2 id="安装-bat"><a href="#安装-bat" class="headerlink" title="安装 bat"></a>安装 bat</h2><p>在 iTerm2 中查看一些文件的内容，会使用 cat 命令，如果是查看一些代码文件，如果没有语法高亮就不太方便阅读。</p><p>使用 bat 工具有三种功能：</p><ul><li>语法高亮</li><li>git 集成</li><li>输出看不见的符号</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在 iTerm2 中执行下面命令就可以安装，详细可以参考 Github 地址：<a href="https://github.com/sharkdp/bat">https://github.com/sharkdp/bat</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install bat</span><br></pre></td></tr></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>执行下面命令进行别名设置，设置后使用熟悉的 cat 命令就可以了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;alias cat=&#x27;bat --paging=never&#x27;&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="语法高亮"><a href="#语法高亮" class="headerlink" title="语法高亮"></a>语法高亮</h3><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191534621.webp"></p><h3 id="git-集成"><a href="#git-集成" class="headerlink" title="git 集成"></a>git 集成</h3><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191534303.webp"></p><h3 id="输出看不见的符号"><a href="#输出看不见的符号" class="headerlink" title="输出看不见的符号"></a>输出看不见的符号</h3><p>使用命令 <code>cat main.js -A</code>就可以看到，空格、换行等都能显示，如果有中文还会转为 Unicode 编码：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191535964.webp"></p><h2 id="开启滚轮"><a href="#开启滚轮" class="headerlink" title="开启滚轮"></a>开启滚轮</h2><p>之前使用 Termius ，使用 vi 打开一个文件时，可以使用触模板或者鼠标的滚轮进行快速浏览文件内容，但在 iTerm2 中默认是没有开启的，可以按照下面设置进行开启：</p><p>1、打开设置界面，切换到 Advanced 页签，然后在搜索框中输入 mouse 进行过滤：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191535307.webp"></p><p>2、找到下图红框位置的配置项，分别配置为<code>/j</code> 和 <code>/k</code></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406191535709.webp"></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li><code>Cmd + ,</code> ：打开 iTerm2 的偏好设置</li><li><code>Cmd + T </code>：新建一个标签页</li><li><code>Cmd + W</code> ：关闭当前标签页</li><li><code>Cmd + Shift + [</code> ：切换到左侧的标签页</li><li><code>Cmd + Shift + ]</code> ：切换到右侧的标签页</li><li><code>Cmd + 1</code> 到 <code>Cmd + 9</code> ：直接切换到特定编号的标签页</li><li><code>Cmd + N</code> ：新建一个 iTerm2 窗口</li><li><code>Cmd + F</code> ：在当前标签页中打开查找框</li><li><code>Cmd + K</code> ：清除从光标位置到屏幕底部的所有内容</li><li><code>Cmd + D</code> ：垂直分屏</li><li><code>Cmd + Shift + D</code> ：水平分屏</li><li><code>Ctrl + Cmd + F</code> ：切换到全屏模式</li><li><code>Cmd + Q</code> ：退出 iTerm2</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在《我在 Mac 中试过用的那些 shell 工具》中最后介绍 iTerm 的安装以及基本使用，但有一个很重要的功能没有介绍，那就是会话管理。&lt;/p&gt;
&lt;p&gt;本文介绍 iTerm2 的会话管理以及一些其他配置。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="iTerm2" scheme="http://fwhyy.com/tags/iterm2/"/>
    
    <category term="配置" scheme="http://fwhyy.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="技巧" scheme="http://fwhyy.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Mac中的常用 shell工具</title>
    <link href="http://fwhyy.com/2024/06/common-shell-tools-in-mac/"/>
    <id>http://fwhyy.com/2024/06/common-shell-tools-in-mac/</id>
    <published>2024-06-13T00:51:25.000Z</published>
    <updated>2024-09-30T15:52:43.287Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候我们需要使用命令行进行一些操作，在 Mac 中有自带的终端（Terminal）可以使用，但功能比较简单，其他的一些工具也使用过不少，下面就简单介绍下我在 Mac 中用过的一些命令行工具。</p><span id="more"></span><h2 id="Termius"><a href="#Termius" class="headerlink" title="Termius"></a>Termius</h2><p>Termius 的功能很全面，支持SSH、SFTP、Telnet、Mossh、串行端口和远程桌面协议。使用也很方便，而且还支持中文，目前是我的主要 shell 工具，不过功能虽然强大我也只是用到了 ssh ，SFTP 我用的另一个工具 Transmit 。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121710914.webp"></p><h2 id="Tabby"><a href="#Tabby" class="headerlink" title="Tabby"></a>Tabby</h2><p>Tabby 是一款开源的终端工具，Github地址是：<a href="https://github.com/Eugeny/tabby">https://github.com/Eugeny/tabby</a> ，它提供了一个现代化的界面和丰富的功能集，颜值和功能非常不错，之前也用过一段时间，偶尔有卡顿，后来还是回到了 Termius 。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121710277.webp"></p><h2 id="Warp"><a href="#Warp" class="headerlink" title="Warp"></a>Warp</h2><p>Warp 是一款现代化的终端工具，以其智能命令行界面和丰富的功能获得用户青睐。它支持多种 Shell  环境，提供智能命令补全、历史命令搜索、多标签管理、内联图片和表情支持等特性。Warp 还集成了 AI 辅助功能（有次数限制）。同时支持协作功能，允许团队成员共享终端会话。刚用时很惊艳，但不太符合我的使用习惯。Warp 的 GitHub 地址为：<a href="https://github.com/warpdotdev/Warp">https://github.com/warpdotdev/Warp</a> 。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121710078.webp"></p><h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>iTerm2 是 Mac 中一款免费的 shell 工具，功能强大，可定制性高，刚安装看着很普通，和系统自带的终端没什么区别，但如果有一颗折腾的心，可以使 iTerm2 变得很惊艳。</p><p>端午节期间，研究了下 iTerm2 ，最终配置出了比较满意的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121711460.webp"></p><h3 id="1、安装-iTerm2"><a href="#1、安装-iTerm2" class="headerlink" title="1、安装 iTerm2"></a>1、安装 iTerm2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install iTerm2  </span><br></pre></td></tr></table></figure><p>可以使用命令进行安装，也可以直接在官网进行下载：<a href="https://iterm2.com/downloads.html">https://iterm2.com/downloads.html</a></p><h3 id="2、安装-On-My-Zsh"><a href="#2、安装-On-My-Zsh" class="headerlink" title="2、安装 On My Zsh"></a>2、安装 On My Zsh</h3><p>On My Zsh 为 zsh 提供很多增强功能，比如插件、主题等。On My Zsh 的 Github 地址为：<a href="https://github.com/ohmyzsh/ohmyzsh">https://github.com/ohmyzsh/ohmyzsh</a> 。</p><p>输入下面命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="3、zsh-设置"><a href="#3、zsh-设置" class="headerlink" title="3、zsh 设置"></a>3、zsh 设置</h3><p>Mac 上默认有 zsh 工具，可以用下面的命令进行检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121712999.webp"></p><p>使用命令 <code>echo $SHELL</code> 可以查看 zsh 是不是默认环境，如果不是，可以使用下面命令进行切换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h3 id="4、安装-NERD-FONTS-字体"><a href="#4、安装-NERD-FONTS-字体" class="headerlink" title="4、安装 NERD FONTS 字体"></a>4、安装 NERD FONTS 字体</h3><p>因为后面使用的主题中有的会有一些小图标，默认的字体可能会不支持，导致图标位置出现乱码：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121712916.webp"></p><p>安装 NERD FONTS 字体：</p><ul><li>官网：<a href="https://www.nerdfonts.com/">https://www.nerdfonts.com/</a></li><li>Github地址：<a href="https://github.com/ryanoasis/nerd-fonts.git">https://github.com/ryanoasis/nerd-fonts.git</a></li></ul><p>我使用的是 Github 方式进行安装，首先将 git 代码拉到本地：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ryanoasis/nerd-fonts.git --depth 1</span><br></pre></td></tr></table></figure><p>进入 nert-fonts 目录，执行 <code>./install.sh</code> 进行安装，安装完后，可以在 iTerm2 的设置中进行字体设置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121712091.webp"></p><h3 id="5、安装以及配置-Powerlevel10k"><a href="#5、安装以及配置-Powerlevel10k" class="headerlink" title="5、安装以及配置 Powerlevel10k"></a>5、安装以及配置 Powerlevel10k</h3><p>On My Zsh 安装之后，默认在 <code>~/.oh-my-zsh</code> 目录，进入这个目录进行 Powerlevel10k 的安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.oh-my-zsh/themes</span><br><span class="line">git clone  https://github.com/romkatv/powerlevel10k.git</span><br></pre></td></tr></table></figure><p>修改配置：</p><p>vi ~/.zshrc 设置如下内容 使用 p10k 主题 ZSH_THEME=“powerlevel10k/powerlevel10k”</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121712980.webp"></p><p>输入下面命令生效，第一次输入下面命令会直接弹出 Powerlevel10k 的配置向导，根据自己的喜好进行设置即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121712304.webp"></p><p>如果你对配置不满意，可以输入下面命令重新进行配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p10k configure</span><br></pre></td></tr></table></figure><h3 id="6、安装插件"><a href="#6、安装插件" class="headerlink" title="6、安装插件"></a>6、安装插件</h3><p>目前就安装了语法高亮和自动补全插件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 高亮</span><br><span class="line">cd ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line"># 自动补全</span><br><span class="line">cd ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>输入 vi ~/.zshrc 编辑配置，在 plugins 后面的括号中添加插件，插件之间空格隔开，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121712438.webp"></p><p>编辑完配置执行 <code>source ~/.zshrc</code> 生效。</p><h3 id="7、安装-iTerm2-Color-Schemes"><a href="#7、安装-iTerm2-Color-Schemes" class="headerlink" title="7、安装 iTerm2 Color Schemes"></a>7、安装 iTerm2 Color Schemes</h3><p>iTerm2 Color Schemes 是 iTerm2 的一份宝贵资源，收集了大量的颜色主题，让你的命令行工作环境更加美观。</p><p>执行下面命令从 Github 拉取代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/mbadolato/iTerm2-Color-Schemes</span><br></pre></td></tr></table></figure><p>在 iTerm2 的设置中进行导入，导入选择的目录为 iTerm2-Color-Schemes/schemes/：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121713891.webp"></p><p>导入完成后，就可以选择自己喜欢的配色方案了，我选择的是 Obsidian 。</p><h3 id="8、设置状态栏"><a href="#8、设置状态栏" class="headerlink" title="8、设置状态栏"></a>8、设置状态栏</h3><p>在 iTerm2 的设置中启动状态栏：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121713900.webp"></p><p>点击 Configure Status Bar 按钮进行设置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121713656.webp"></p><h3 id="9、设置背景"><a href="#9、设置背景" class="headerlink" title="9、设置背景"></a>9、设置背景</h3><p>iTerm2 可以设置背景和窗口透明、毛玻璃效果，我尝试后决定只设置一个背景比较好看，背景选择的强风吹拂动漫的一张图。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121713741.webp"></p><h3 id="10、关闭单击选框"><a href="#10、关闭单击选框" class="headerlink" title="10、关闭单击选框"></a>10、关闭单击选框</h3><p>iTerm2 更新 3.5.0 版本后，点击窗口出现紫色框，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121713061.webp"></p><p>因为我设置了背景，这样选中后就变得非常难看，可以在设置中进行关闭：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121713472.webp"></p><h3 id="11、设置右键粘贴"><a href="#11、设置右键粘贴" class="headerlink" title="11、设置右键粘贴"></a>11、设置右键粘贴</h3><p>选中复制，右键粘贴这是我使用 shell 时的个人习惯，当然在 iTerm2 中也可以进行右键粘贴的设置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406121714991.webp"></p><ul><li>顶部页签选择 Pointer 后，下面的二级页签选择 Bindings</li><li>添加一个新的绑定，按照上图的配置即可</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多时候我们需要使用命令行进行一些操作，在 Mac 中有自带的终端（Terminal）可以使用，但功能比较简单，其他的一些工具也使用过不少，下面就简单介绍下我在 Mac 中用过的一些命令行工具。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="mac" scheme="http://fwhyy.com/tags/mac/"/>
    
    <category term="shell" scheme="http://fwhyy.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB密码设置</title>
    <link href="http://fwhyy.com/2024/06/mongodb-password-setting/"/>
    <id>http://fwhyy.com/2024/06/mongodb-password-setting/</id>
    <published>2024-06-06T00:49:13.000Z</published>
    <updated>2024-09-30T15:50:14.308Z</updated>
    
    <content type="html"><![CDATA[<p>给 MongoDB 设置密码有两种情况：</p><p>1、给创建的 MongDB 容器添加密码。</p><p>2、给现有的无密码的 MongoDB 容器进行密码设置。</p><p>在设置密码之前，先说说 MongoDB 的版本，之前一直使用 5.0.2 和 5.0.14 版本比较多，然而这两个版本都是有安全漏洞的，所以大版本如果选择 5 ，可以选择 5.0.24 。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406051625025.webp"></p><h2 id="新创建容器设置密码"><a href="#新创建容器设置密码" class="headerlink" title="新创建容器设置密码"></a>新创建容器设置密码</h2><p>1、在 CentOS 服务器中创建目录 mongodb_pwd ，目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406051625451.webp"></p><p>2、使用下面命令给 mongo-init.js 文件添加执行权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x mongo-init.js</span><br></pre></td></tr></table></figure><p>3、mongo-init.js 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">print(&#x27;create user start #################################################################&#x27;);</span><br><span class="line"></span><br><span class="line">db = db.getSiblingDB(&quot;oec2003_db&quot;);</span><br><span class="line"></span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  user: &quot;oec2003&quot;,</span><br><span class="line">  pwd: &quot;Aa12345678&quot;,</span><br><span class="line">  roles: [</span><br><span class="line">    &#123;</span><br><span class="line">      role: &quot;readWrite&quot;,</span><br><span class="line">      db: &quot;oec2003_db&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">db.createCollection(&#x27;oec2003&#x27;);</span><br><span class="line"></span><br><span class="line">print(&#x27;create user end #################################################################&#x27;);</span><br></pre></td></tr></table></figure><ul><li>加上 print 为了更好地查看容器日志。</li><li><code>getSiblingDB()</code> 是 MongoDB shell 提供的一个方法，它允许你切换到另一个数据库，而不需要重新连接到MongoDB实例。这个方法返回一个新的 <code>DB</code> 对象，意思是数据库不存在会新创建一个。</li><li>db.createCollection(‘oec2003’)：在用户创建完成后，创建了一个名为 oec2003 的 collection ，默认创建一个 collection 是为方便测试，因为没有任何内容的库，使用 show dbs 或者客户端连上是看不见新创建的数据库 oec2003_db 。</li></ul><p>4、docker-compose.yml 文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:5.0.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;37017:27017&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_USERNAME:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">MONGO_INITDB_ROOT_PASSWORD:</span> <span class="string">Aa123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo-data:/data/db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mongo-data:</span></span><br></pre></td></tr></table></figure><ul><li>environment 环境变量设置根账户的用户名和密码，可以理解为超级管理员账号</li><li>volumes 中映射的 mongo-init.js 文件在 MongoDB 容器第一次运行的时候会被执行，是否被执行可以通过执行 <code>docker logs -f mongodb</code> 命令查看日志：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406051625831.webp"></p><p>如果没有出现上图中的日志，需要检查下 mongo-init.js 文件是否有执行权限。</p><p>5、进入容器，使用 mongo 进入 MongoDB 的 shell 模式，会发现可以正常进入，但如果执行一些命令会出现没有权限的提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongodb bash</span><br><span class="line">mongo</span><br><span class="line">&gt; use admin</span><br><span class="line">&gt; db.getUsers()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406051625837.webp"></p><p>所以，在加了密码的 MongoDB 中需要使用下面命令进行登录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo -u root -p Aa123456 --authenticationDatabase &quot;admin&quot;</span><br></pre></td></tr></table></figure><ul><li>用户名和密码为 docker-compose.yml 文件中 environment 中定义的。</li></ul><p>6、使用用户名密码登录后，在进行用户的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongodb bash</span><br><span class="line">mongo -u root -p Aa123456 --authenticationDatabase &quot;admin&quot;</span><br><span class="line">&gt; use oec2003_db</span><br><span class="line">&gt; db.getUsers()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406051625948.webp"></p><h2 id="给现有容器进行密码设置"><a href="#给现有容器进行密码设置" class="headerlink" title="给现有容器进行密码设置"></a>给现有容器进行密码设置</h2><p>1、原始构建容器的脚本可能是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:5.0.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;47017:27017&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo-data:/data/db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mongo-data:</span></span><br></pre></td></tr></table></figure><p>2、网上看到很多设置密码的方式，直接进入 MongoDB 的 shell 模式，针对数据库进行账号密码的添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">use oec2003_db</span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  user: &quot;oec2003&quot;,</span><br><span class="line">  pwd: &quot;Aa12345678&quot;,</span><br><span class="line">  roles: [</span><br><span class="line">    &#123;</span><br><span class="line">      role: &quot;readWrite&quot;,</span><br><span class="line">      db: &quot;oec2003_db&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但只是针对库加了用户和密码，会发现，客户端工具，不使用密码一样可以登录，并且能操作库里的内容。</p><p>3、这时，修改 docker-compose.yml 文件 ，添加 auth认证：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongodb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:5.0.24</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongodb</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;47017:27017&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mongo-data:/data/db</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--auth</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mongo-data:</span></span><br></pre></td></tr></table></figure><p>重新构建容器，这时用客户端访问数据库，或者 collection 就会出现如下提示：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202406051626019.webp"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>1、新创建的时候 yml 文件没有添加 –auth ，也是需要使用用户名密码才能使用，但对现有无密码容器进行修改，必须添加 –auth ，还不知道原因（可能是我操作问题 。</p><p>2、对现有无密码容器进行修改时，不管是在 environment 中添加根密码，还是手动进入 shell 中添加，只要没有添加 –auth ，一样可以无密码登录。</p><p>3、按照上面步骤进行配置，是可以达到密码保护的作用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;给 MongoDB 设置密码有两种情况：&lt;/p&gt;
&lt;p&gt;1、给创建的 MongDB 容器添加密码。&lt;/p&gt;
&lt;p&gt;2、给现有的无密码的 MongoDB 容器进行密码设置。&lt;/p&gt;
&lt;p&gt;在设置密码之前，先说说 MongoDB 的版本，之前一直使用 5.0.2 和 5.0.14 版本比较多，然而这两个版本都是有安全漏洞的，所以大版本如果选择 5 ，可以选择 5.0.24 。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MongoDB" scheme="http://fwhyy.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Kubesphere 使用实践</title>
    <link href="http://fwhyy.com/2024/05/kubesphere-usage-practice/"/>
    <id>http://fwhyy.com/2024/05/kubesphere-usage-practice/</id>
    <published>2024-05-29T00:45:33.000Z</published>
    <updated>2024-09-30T15:47:03.313Z</updated>
    
    <content type="html"><![CDATA[<p>容器化部署，尤其是利用 Docker 技术，已成为现代软件部署的标配。我们可以通过简单的命令如 <code>run</code> 直接启动容器，或者使用编排工具如 <code>docker-compose</code> 和 <strong>Kubernetes</strong>（简称 <strong>k8s</strong>）等来简化操作。</p><span id="more"></span><p><strong>Kubernetes</strong> 是一个开源的容器编排平台，最初由 Google 设计开发，目前由 <strong>Cloud Native Computing Foundation</strong>（CNCF）维护。它旨在简化容器化应用的部署、扩展、管理和自动化，帮助用户更高效地构建、交付和运行应用程序。虽然 Kubernetes 功能强大，但其复杂性对一些用户来说是个挑战。</p><p>接下来，让我们引入本文的主角——<strong>KubeSphere</strong>。</p><h3 id="KubeSphere-介绍"><a href="#KubeSphere-介绍" class="headerlink" title="KubeSphere 介绍"></a>KubeSphere 介绍</h3><p><strong>KubeSphere</strong> 可以理解为 Kubernetes 的扩展和增强，它提供了更多功能和解决方案，以简化和优化 Kubernetes 的使用。KubeSphere 提供了丰富的工具和服务，包括 DevOps、多租户管理、服务网格、存储、日志监控等，帮助用户轻松构建、部署和管理云原生应用。</p><p>KubeSphere 能在 Kubernetes 基础上构建的更完整的云原生全栈解决方案，它进一步简化和增强了 Kubernetes 的功能，提供更广泛的支持和服务。</p><p>以下是 KubeSphere 官网对其的定义：</p><blockquote><p>KubeSphere 的愿景是打造一个以 Kubernetes 为内核的云原生分布式操作系统。它的架构支持第三方应用与云原生生态组件的即插即用（plug-and-play）集成，实现多云与多集群环境下云原生应用的统一分发和运维管理。</p></blockquote><p>更多关于 KubeSphere 的信息，请访问其官方网站：<a href="https://kubesphere.io/zh/">KubeSphere 官网</a>。</p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>对于刚接触 KubeSphere 并想快速上手该容器平台的用户，All-in-One 安装模式是最佳的选择，它能够帮助您零配置快速部署 KubeSphere 和 Kubernetes 。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>CentOS：7.4.1708/7.9，8 GB 内存、4 核 CPU </li><li>Docker：23.0.5</li><li>Kubernetes：1.22.12</li><li>KubeSphere：3.4.0</li></ul><h3 id="节点要求"><a href="#节点要求" class="headerlink" title="节点要求"></a>节点要求</h3><p>1、节点必须能够通过 SSH 连接。<br>2、节点上可以使用 sudo/cur1/openss1 命令。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281458084.webp"></p><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装  Docker"></a>安装  Docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --enable docker-ce-edge</span><br><span class="line"></span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"></span><br><span class="line">systemctl start docker</span><br><span class="line">chkconfig docker on</span><br></pre></td></tr></table></figure><p>安装完成  docker  后，需要对  docker  进行配置，执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后执行：systemctl restart docker ，重启  docker  让配置生效。</p><h3 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h3><p>Kubekey 是用 Go 语言开发的一款全新的安装工具，代替了以前基于 ansible 的安装程序。KubeKey 为用户提供了灵活的安装选择，可以分别安装 KubeSphere 和 Kubernetes 或二者同时安装，既方便又高效。</p><p>KubeKey 可以将 Kubernetes 和 KubeSphere 一同安装。针对不同的 Kubernetes 版本，需要安装的依赖项可能有所不同。</p><p>执行下面命令安装相关依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install socat conntrack ebtables ipset</span><br></pre></td></tr></table></figure><h3 id="网络和-DNS-要求"><a href="#网络和-DNS-要求" class="headerlink" title="网络和 DNS 要求"></a>网络和 DNS 要求</h3><p>1、请确保 /etc/resolv.conf 中的 DNS 地址可用，否则，可能会导致集群中的 DNS 出现问题。使用命令：cat /etc/resolv.conf 查看：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281459221.webp"></p><p>也可以使用命令  nslookup <a href="http://www.baidu.com/">www.baidu.com</a> 进行测试，出现下图说明正常：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281459706.webp"></p><p>2、关闭防火墙。</p><p>先用命令 firewall-cmd –state 查看防火墙的状态，如果是  running ，就使用下面命令进行关闭：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>3、检查 SELinux 是否关闭，输入命令 sestatus 进行查看：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281459949.webp"></p><p>上图中是开启状态，编辑配置文件：vi /etc/selinux/config ：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281459501.webp"></p><p>修改完成后，重启服务器生效。</p><h3 id="下载-kubekey"><a href="#下载-kubekey" class="headerlink" title="下载  kubekey"></a>下载  kubekey</h3><p>k8s 和 kubesphere 的安装是使用  kubekey  这个工具，所以先安装  kubekey 。不管你是否能访问 Github 和 Google ，先执行下面命令切换区域，会省去很多麻烦：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export KKZONE=cn</span><br></pre></td></tr></table></figure><p>从 GitHub Release Page 下载 KubeKey 或直接使用以下命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sfL https://get-kk.kubesphere.io | VERSION=v3.0.13 sh -</span><br></pre></td></tr></table></figure><p>成功后如下图，并在当前目录中有一个绿色的  kk  目录：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281459590.webp"></p><p>如果  kk  目录的权限不够，需要使用下面命令进行授权：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x kk</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、在  root 目录中输入 ./kk ，可以看到一些常用的命令和不同的安装方式说明：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281459038.webp"></p><p>2、下面命令是同时安装  k8s  和 kubesphere，安装前会先进行环境的检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kk create cluster --with-kubernetes v1.22.12 --with-kubesphere v3.4.0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281500944.webp"></p><p>安装中：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281500256.webp"></p><p>最后的安装  kubesphere  要等待很久：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281500263.webp"></p><p>关键是等了很长的时间，也没有得到安装成功的提示，查询后得知可能是 CentOS 系统版本中的依赖跟 KubeKey 有冲突导致，我使用的是：CentOS Linux release 7.4.1708 (Core) ，**建议使用 CentOS 7.9 **。</p><p>3、创建新的虚拟机，安装 CentOS 7.9 系统，我是在 Mac 上使用 Parallels 进行虚拟机的安装，安装过程中出现下面问题：</p><ul><li><p>红屏</p></li><li><p>Not asking for VNC because we don’t have a network 提示的错误信息</p></li></ul><p>可以通过下面设置解决：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281500854.webp"></p><p>4、CentOS 7.9 安装好后，按照上面的步骤重新安装了一遍，这一次安装成功，kubesphere 的访问地址和用户名密码都会在安装成功的提示中输出：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281500157.webp"></p><p>5、登录后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281501179.webp"></p><p>6、特别注意，虚拟机的配置至少 4 核、8gb 内存，我一开始只给了 2 核（默认），运行后，监控中的有些节点是不能正常启动的，当调整为 4 核后，就都正常了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281505331.webp"></p><h2 id="KubeSphere-使用"><a href="#KubeSphere-使用" class="headerlink" title="KubeSphere 使用"></a>KubeSphere 使用</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 查看哪些 pod 启动了，使用 -A 参数表示获取所有命名空间下的 Pod</span><br><span class="line">kubectl get pod -A </span><br><span class="line"># 详细描述指定命名空间中特定 Pod 的信息</span><br><span class="line">kubectl describe pod pod名称 -n 命名空间</span><br><span class="line"># 获取指定命名空间（这里是 kube-system 命名空间）中的所有 Pod 列表</span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"># 获取 Kubernetes 集群中所有节点（Node）的列表</span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><h3 id="创建工作负载"><a href="#创建工作负载" class="headerlink" title="创建工作负载"></a>创建工作负载</h3><p>1、在工作负载中添加有状态副本集，填写基本信息：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281624747.webp"></p><p>2、进行容器设置，首先选择容器，可以直接输入 mysql 进行搜索，然后选择需要安装的数据库版本：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281624575.webp"></p><p>3、设置环境变量，时区、root 密码等：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281624605.webp"></p><p>4、配置存储挂载：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281625187.webp"></p><p>5、挂载配置文件：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281626873.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281626700.webp"></p><p>6、使用前需要创建服务，当我们创建一个有状态的副本集后，默认创建了一个服务：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281626894.webp"></p><p>默认是集群内部访问，在容器的控制台使用 DNS 名称，可以进行登录：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281626782.webp"></p><p>7、如果需要外部访问，需要创建一个服务，选择指定工作负载：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281627474.webp"></p><p>8、按照下图所示找到有状态副本集进行指定：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281628907.webp"></p><p>9、配置服务名称和端口：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281629934.webp"></p><p>10、设置访问模式：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281630531.webp"></p><p>11、外部访问，注意服务创建后，会生成一个外部访问的端口</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281630064.webp"></p><p>12、使用客户端工具连接：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405281631262.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;容器化部署，尤其是利用 Docker 技术，已成为现代软件部署的标配。我们可以通过简单的命令如 &lt;code&gt;run&lt;/code&gt; 直接启动容器，或者使用编排工具如 &lt;code&gt;docker-compose&lt;/code&gt; 和 &lt;strong&gt;Kubernetes&lt;/strong&gt;（简称 &lt;strong&gt;k8s&lt;/strong&gt;）等来简化操作。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Kubernetes" scheme="http://fwhyy.com/tags/kubernetes/"/>
    
    <category term="Kubesphere" scheme="http://fwhyy.com/tags/kubesphere/"/>
    
    <category term="DevOps" scheme="http://fwhyy.com/tags/devops/"/>
    
    <category term="CI/CD" scheme="http://fwhyy.com/tags/ci-cd/"/>
    
    <category term="K8S" scheme="http://fwhyy.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>读《强风吹拂》</title>
    <link href="http://fwhyy.com/2024/05/read-strong-wind-blows/"/>
    <id>http://fwhyy.com/2024/05/read-strong-wind-blows/</id>
    <published>2024-05-23T00:42:19.000Z</published>
    <updated>2024-09-30T15:47:25.742Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405221638731.webp"></p><p>《强风吹拂》是日本作家三浦紫苑创作的长篇小说。该小说讲述了宽政大学宿舍「竹青庄」的十名舍友凑成杂牌长跑队，在队长清濑灰二的魔鬼训练下，从零开始向日本历史最悠久的长跑接力赛「箱根驿传」挺进的故事。</p><span id="more"></span><p>我是先在 B 站上看了动画，然后又在得到上看的电子书。下面说说对这部作品的感受吧。</p><h2 id="箱根驿传介绍"><a href="#箱根驿传介绍" class="headerlink" title="箱根驿传介绍"></a>箱根驿传介绍</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405221649965.webp"></p><p>先说说箱根驿传这个比赛，在看这个作品之前，我是不知道箱根驿传的，看了这部作品后，在去年元旦还追着看过箱根驿传的直播比赛，十分热血。</p><p>箱根驿传，全称为“东京箱根间往复大学驿传竞走”，是日本历史最悠久的长跑接力比赛。这项赛事由日本的马拉松之父金栗四三等人于 1920 年创办 ，每年 1 月 2 日至 3 日举办。箱根驿传不仅是日本大学生体育比赛的盛事，也吸引了全球跑步爱好者的关注。</p><p>箱根驿传的参赛门槛非常高，要求参赛选手曾经取得 17 分钟内完成5公里的纪录赛正式记录，后调整为 16 分钟 30 秒内完成5公里或 34 分钟内完成 10 公里。参赛队伍共有 21 支全男生队伍，分别来自经选拔产生的 20 所大东京地区高校，其中有十支为前一年箱根驿传成绩排名前十的种子校，另外十支队伍则在前一年十月通过预选会选出。</p><p>每支队伍至多可以有 16 人，最终只有 10 人被教练选中上阵，每人出战一个赛段。每支队伍的每位参赛选手至少要跑 20 公里。路线是从读卖新闻东京本社前出发，至箱根芦之湖后折返，去程有 5 个区间，回程同样有 5 个区间，合计 10 个区间总长约 217 公里。</p><h2 id="小说和动画的差异"><a href="#小说和动画的差异" class="headerlink" title="小说和动画的差异"></a>小说和动画的差异</h2><p>我印象最深刻的差异有两点：</p><p>1、叶菜子的出场顺序，叶菜子是作品中唯一的女性角色，动画中出场比较早，小说则到了夏天去白桦湖集训时才出现。</p><p>2、在动画中灰二花费了很大的精力才说服竹青庄的成员参到田径队，小说中貌似很容易。</p><p>我感觉在动画中让女主提前出场，可能会让这个描述跑步的作品不会显得那么枯燥吧。灰二在动画中想出各种办法去说服每个人，也是看点之一。</p><h2 id="优秀项目经理灰二"><a href="#优秀项目经理灰二" class="headerlink" title="优秀项目经理灰二"></a>优秀项目经理灰二</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405221650119.webp"></p><p>清濑灰二绝对是一名优秀的项目经理。</p><p><strong>目标明确</strong>：梦想就是组建一支队伍，参加箱根驿传的比赛，尽管困难重重，但目标坚定。</p><p><strong>成员组成</strong>：我觉得灰二心中有一杆秤，那些人为什么会出现在竹青庄，我觉得应该是经过筛选的。尼古虽然抽烟，但有参加过田径队的经验；阿雪高中时期是剑道部成员，下肢力量强大，这也是最后为啥跑 6 区的下坡；双胞胎兄弟喜欢踢足球，有很好的运动基础；穆萨是非洲人，天选的长跑选手，尽管他自己不承认；King 高中时期也待过足球部；阿走就不用说了，高中时期就是长跑明星选手；即便是漫画宅王子，也不能小瞧，他有着精英的身材和对漫画那种执着的精神。</p><p><strong>个性化管理</strong>：灰二很懂人性的弱点，了解到每个人的诉求和痛点，在说服他们加入的时候逐个击破，不服不行。在这里也体现出了灰二有超强的沟通能力。</p><blockquote><p>清濑会依照每个人的个性，不着痕迹地给予个别指导。例如，既然神童以达成练习目标为乐，清濑就为他一个人拟定更详细的训练表；为了让学究派的阿雪心服口服，清濑欣然和他一起讨论训练方法；城太只要受人夸奖就越练越来劲，因此清濑在练习中不忘帮他灌点迷汤；至于城次，不去管他，他也自己跑得很起劲，清濑根本不用刻意去指导他。<br>基本上，清濑会让大家照自己喜欢的方式去跑。他做的只有两件事，就是向大家仔细交代练习方针，以及在必要时提供一些建议。他这么做，反而巧妙地挑起所有人的干劲，而这看在阿走眼里，有如一场精彩的魔术秀。他不用强迫的手段，也不设定罚则，只是执着地等待这些顽石点头、出于真心想跑。阿走从来不知道，原来也有这种的训练法。</p></blockquote><p><strong>时间管理</strong>：平时的吃饭、训练、测试赛、正式比赛，安排的明明白白，需要用多长时间达到什么样的目标，非常清晰，严格执行计划，最终才让所有人都顺利达标。</p><p><strong>以身作则</strong>：灰二也很有长跑天赋，但腿部有伤，尽管如此，还是在坚持训练，给了团队很大的激励。</p><p><strong>战略规划</strong>：在比赛时，他能够制定有效的战略和计划，使队伍在比赛中取得优势。测试赛的手势传递、正式赛打电话让房东传话都有一种灰二已经掌控全局的感觉。</p><h2 id="进步神速的王子"><a href="#进步神速的王子" class="headerlink" title="进步神速的王子"></a>进步神速的王子</h2><p>对王子印象极为深刻，特别是动画中王子的跑姿。其实王子挺快的：</p><ul><li>王子第一次 5 公里测试成绩：33 分 13 秒</li><li>记录赛 5 公里跑出了 16 分 58 秒</li><li>夏训结束后 10 公里成绩：35 分 38 秒</li><li>正式比赛中王子是第一区，书中有这样的描写：“赛况正如清濑所预料，以较慢的步调展开。众选手望着左手边的东京车站，一边跑过和田仓门。观众发出的欢声雷动与大楼间隙吹出的风，都被抛向后方。选手群维持着一横列，踏着微湿的路面前进。<strong>每公里 3 分 07 秒，这样的速度王子也跟得上。</strong>”</li></ul><p>所以说，王子进步是巨大的，动画中的跑姿实在是有点过于夸张。王子之所以进步神速，我认为有三点原因：</p><p>1、一开始王子就能完成 5 公里，其实是不容易的，也说明是有一定天赋的，我要是一段时间不跑步，两公里都会感觉很累。</p><p>2、王子体重很轻，跑步经济会很好，而且也不容易受伤。</p><p>3、书中多次描写王子练到呕吐、晕倒，这不是说王子很菜，而是说明王子的训练强度很大，在不受伤的前提下，用最大的强度来练，受益肯定会大，何况灰二还是非常科学的训练方法。</p><h2 id="超凡毅力的神童"><a href="#超凡毅力的神童" class="headerlink" title="超凡毅力的神童"></a>超凡毅力的神童</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405221651113.webp"></p><p>我对神童的感觉就是人非常好，小时候在山区长大，每天走 10 公里的山路往返家和学校。跑 5 区的绝佳人选。</p><p>一开始，我还畅想着神童应该能破一个 5 区的记录，万万没想到，神童在比赛前感冒了，最后是发着高烧跑完的 5 区。</p><p>书中有一个细节，神童在赛前一直将自己裹得严严实实，就是担心自己的感冒传染给队友了，在这么紧张的比赛前夕、在自己身体这么难受的情况下，还不忘照顾他人的感受。</p><p>太喜欢神童了。</p><h2 id="什么是强？"><a href="#什么是强？" class="headerlink" title="什么是强？"></a>什么是强？</h2><p>什么是强，这是阿走一直思考的。以前别人都是让他跑的更快，直到遇到灰二，是让他变强而不是变快。</p><p>阿走一直都在寻找答案，直到神童完成了五区的赛段，记录、结果都已经不重要了，神童达到了更高的境界。阿走这时觉得，灰二说的强，或许就是这个意思，再怎么痛苦也要向前的一种力量，以及持续和自己战斗的勇气，还有一次又一次超越自我极限的毅力。</p><p>没有这些，神童坚持不到终点。</p><p>书中的每个角色在追逐梦想的过程中，都实现了自我超越。例如：阿走重新找回了跑步的意义；王子从一个跑步初学者成长为箱根选手，其他人也在不同程度上克服了自己的弱点。每个人都在灰二的带领下变强了。</p><p>对我自己来说，跑步或者一件想要去做的小事，能持续坚持下去就是强。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405221651583.webp"></p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>一部看了就想出去跑跑的作品，看了动画，又看了书，现在想再去把动画重温一遍。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405221638731.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;《强风吹拂》是日本作家三浦紫苑创作的长篇小说。该小说讲述了宽政大学宿舍「竹青庄」的十名舍友凑成杂牌长跑队，在队长清濑灰二的魔鬼训练下，从零开始向日本历史最悠久的长跑接力赛「箱根驿传」挺进的故事。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="跑步" scheme="http://fwhyy.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="小说" scheme="http://fwhyy.com/tags/%E5%B0%8F%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>迁移Wordpress到Docker</title>
    <link href="http://fwhyy.com/2024/05/migrating-wordpress-to-docker/"/>
    <id>http://fwhyy.com/2024/05/migrating-wordpress-to-docker/</id>
    <published>2024-05-14T00:40:00.000Z</published>
    <updated>2024-09-30T15:41:07.785Z</updated>
    
    <content type="html"><![CDATA[<p>很多年前我的个人博客是部署在 Linode 的服务器，后来又给女儿弄了一个博客记录女儿的成长，使用的是 Wordpress ，老婆执笔。现在我的博客早已迁移到了 github ，女儿也长大了，博客好几年没有更新，准备停掉 linode 服务器，将女儿博客迁移到本地。</p><span id="more"></span><p>迁移有三个步骤：</p><p>1、备份原博客数据；</p><p>2、本地部署 wordpress；</p><p>3、还原。</p><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>1、将服务器 wwwroot 目录中的文件拷贝到本地。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405131556894.webp"></p><p>2、将 mysql 数据库进行备份。</p><h2 id="本地部署-wordpress"><a href="#本地部署-wordpress" class="headerlink" title="本地部署 wordpress"></a>本地部署 wordpress</h2><p>本地部署 wordpress 采用 docker-compose 的方式，wordpress 使用的是最新版本，mysql 和之前 linode 服务器使用的同一版本，docker-compose.yml 文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"> <span class="attr">wp_net:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">  <span class="attr">ipam:</span></span><br><span class="line">   <span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">   <span class="attr">config:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">172.88</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;13306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=Aa123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=wordpress</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=wpadmin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=Aa123456</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mysqld</span> <span class="string">--character-set-server=utf8</span> <span class="string">--collation-server=utf8_general_ci</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="attr">wp_net:</span></span><br><span class="line">      <span class="attr">ipv4_address:</span> <span class="number">172.88</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">wp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;12000:80&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./wordpress/:/var/www/html</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORDPRESS_DB_HOST=db:3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORDPRESS_DB_USER=wpadmin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORDPRESS_DB_PASSWORD=Aa123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WORDPRESS_DB_NAME=wordpress</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="attr">wp_net:</span></span><br><span class="line">      <span class="attr">ipv4_address:</span> <span class="number">172.88</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">db_data:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">wordpress_data:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>在 docker-compose.yml 所在目录执行 <code>docker-compose up -d </code> 进行容器构建，构建完成后，就可以在浏览器输入 <a href="http://localhost:12000/">http://localhost:12000</a> 进行访问：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405131556737.webp"></p><p>按照向导进行博客的初始化：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405131556583.webp"></p><h2 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h2><p>因之前部署的 wordperss 版本和现在最新的版本差异很大，所以没有使用完全覆盖的方式。</p><p>1、在构建的数据库中创建一个名为 wordpress_bak 的库，将备份的数据库还原到这个库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp backup.sql 78fdd98f5834:/</span><br><span class="line">docker exec -it 78fdd98f5834 bash</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">mysql -uroot -pAa123456 wordpress &lt; backup.sql</span></span><br></pre></td></tr></table></figure><p>2、构建成功后，默认的 wordpress 库中的表有些示例数据，使用下面语句将示例数据删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> wp_posts</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> wp_terms</span><br></pre></td></tr></table></figure><p>3、备份 wordpress_bak 库中的 wp_posts 表，发现备份时提示错误：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202405131556515.webp"></p><p>原因是还原的数据库日期类型的字段有不符合要求的默认值，将 wp_posts 表中的日期字段的默认值去掉即可。</p><p>4、使用下面语句将 wp_posts 表中 post_content 字段中内容的域名进行替换，这一步骤是将文章中的图片地址替换为本地地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update wp_posts set post_content = REPLACE(post_content,&#x27;http://xxxx.me&#x27;,&#x27;http://localhost:12000&#x27;)</span><br></pre></td></tr></table></figure><p>5、将 wordpress_bak 库中的 wp_posts、wp_terms 两个表的数据同步到 wordpress 库。同步完后，可以在浏览器访问：<a href="http://localhost:12000/">http://localhost:12000</a> ，可以看到所有的文章列表，但点击去后图片不能显示。</p><p>6、将备份的 wwwroot 中的 /wp_content/uploads 目录复制到新安装的 wordpress/wp_content 目录中，这时图片就能正常访问了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多年前我的个人博客是部署在 Linode 的服务器，后来又给女儿弄了一个博客记录女儿的成长，使用的是 Wordpress ，老婆执笔。现在我的博客早已迁移到了 github ，女儿也长大了，博客好几年没有更新，准备停掉 linode 服务器，将女儿博客迁移到本地。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="http://fwhyy.com/tags/docker/"/>
    
    <category term="WordPress" scheme="http://fwhyy.com/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>效率工具：Reader和Arc浏览器新功能</title>
    <link href="http://fwhyy.com/2024/04/new-features-for-reader-and-arc-browsers/"/>
    <id>http://fwhyy.com/2024/04/new-features-for-reader-and-arc-browsers/</id>
    <published>2024-04-24T00:37:08.000Z</published>
    <updated>2024-09-30T15:38:26.685Z</updated>
    
    <content type="html"><![CDATA[<p>Arc 浏览器和 Readwise Reader 是我在 Mac 上很喜欢的两款工具，这两款工具最近推出的一些功能能极大提升效率。哦不，功能推出有一阵子了，我最近才开始使用。</p><p>本文简单介绍下这些新功能。</p><span id="more"></span><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>1、在 Reader 中阅读文章时，右边栏会有 summary 对文章进行总结，不过之前的版本总结很差，几乎没法用，要么是英文、要么很简短。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733752.webp"></p><p>2、现在的版本中推出了一个 Ghostreader prompts 的功能，可以自定义提示语，点击下图 Customize 进行设置。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733339.webp"></p><p>3、点击下图中的 Edit prompt 进行提示词的编辑。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733763.webp"></p><p>4、编辑的内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;#- 简体中文摘要与重点提取 -#&#125;</span><br><span class="line"></span><br><span class="line">&#123;#- 下面的 Prompt 会将文档缩减成一个 500 字内的摘要，并根据你的 highlight 进行重点摘要。-#&#125;</span><br><span class="line"></span><br><span class="line">请使用 500 字以内，以简体中文总结以下文本：</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">标题：&#123;&#123; document.title &#125;&#125;</span><br><span class="line">作者：&#123;&#123; document.author &#125;&#125; </span><br><span class="line">来源：&#123;&#123; document.domain &#125;&#125;</span><br><span class="line"></span><br><span class="line">另外，在阅读此文章时，我对以下部分进行了高亮，认为这些是文章的重点，给你学习参考：</span><br><span class="line"></span><br><span class="line">&#123;% for highlight in document.highlights %&#125;</span><br><span class="line">- &#123;&#123; highlight.content &#125;&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">&#123;#- 下面的 if-else 逻辑检查文档的长度。如果文档较长，它将使用关键句子以避免超出 GPT 提示窗口的限制。我们强烈建议除非您知道自己在做什么，否则不要更改此设置。-#&#125;</span><br><span class="line"></span><br><span class="line">&#123;% if (document.content | count_tokens) &gt; 2000 %&#125;</span><br><span class="line">&#123;&#123; document.content | central_sentences | join(&#x27;\n\n&#x27;) &#125;&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&#123;&#123; document.content &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">重要提示：请不要超过 500 字。每句话应该简洁易读；关于中文的排版原则：在中文和英文或数字之间，要有一个半角空白，例如：Apple 手机；3 个 AI 工具。</span><br><span class="line"></span><br><span class="line">另外，在文章总结下方换行后，基于本文重点，请创建 3 个有关问题及其答案。每个问题应能帮助深入理解文章的关键概念，并加强对重点的印象。请注意，在问题的这一行上，使用粗体的 markdown 格式，或者 &lt;strong&gt; 的 html 标签来更让文字显眼。</span><br><span class="line"></span><br><span class="line">&#123;#- 创建问答 -#&#125;</span><br><span class="line"></span><br><span class="line">**问题 1：&#123;# 基于重点内容构建的问题 #&#125;**</span><br><span class="line"></span><br><span class="line">答案：&#123;# 对应问题 1 的答案，应该包含对应的重点内容 #&#125;</span><br><span class="line"></span><br><span class="line">**问题 2：&#123;# 同上 #&#125;** </span><br><span class="line"></span><br><span class="line">答案：&#123;# 对应问题 2 的答案，应该包含对应的重点内容 #&#125;</span><br><span class="line"></span><br><span class="line">**问题 3：&#123;# 同上 #&#125;**</span><br><span class="line"></span><br><span class="line">答案：&#123;# 对应问题 3 的答案，应该包含对应的重点内容 #&#125;</span><br></pre></td></tr></table></figure><p>上面的提示语可以达到以下三个效果：</p><ul><li><p>根据文章内容生产 500 字以内的总结性文字。</p></li><li><p>可以将你在文章中划线部分进行重点参考。</p></li><li><p>针对文章内容提出 3 个问题，并给出答案。</p></li></ul><p>5、默认情况下使用的是 GPT-3.5 Turbo ,如果想要使用 GPT-4 ，需要使用自己的 API key 。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733211.webp"></p><p>6、下面找一篇文章来看看效果。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733940.webp"></p><h2 id="Arc-浏览器"><a href="#Arc-浏览器" class="headerlink" title="Arc 浏览器"></a>Arc 浏览器</h2><p>Arc 浏览器新退出的 AI 智能功能，只需要在设置中打开 Max 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733491.webp"></p><p>下面逐一介绍这几个功能。</p><h3 id="Tidy-Tabs"><a href="#Tidy-Tabs" class="headerlink" title="Tidy Tabs"></a>Tidy Tabs</h3><p>当开启了的页签数达到 6 个或以上时，上面会出现一个小扫帚的图标，点击这个图标，Arc 会根据网站的类型进行分类。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733059.webp"></p><p>下面是分类后的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231733883.webp"></p><h3 id="Instant-Links"><a href="#Instant-Links" class="headerlink" title="Instant Links"></a>Instant Links</h3><p>这个功能很有用，在 Arc 浏览器中搜索时（输入网页地址的框），直接按 Shift + Enter ，Arc 会根据输入的内容智能找到一个唯一结果页面并且打开，省掉了在搜索引擎中手动去过滤结果的步骤。</p><p>比如：搜索「dotnet8下载页面」或者「冯威博客」，按下  Shift + Enter ，会出现下图的提示文本：Searching the web for you… ，稍等一下，就会以新页签打开搜索结果。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734963.webp"></p><h3 id="Ask-on-Page"><a href="#Ask-on-Page" class="headerlink" title="Ask on Page"></a>Ask on Page</h3><p>我们使用 Arc 浏览网页一些文章时可以使用 Command+F 对网页进行提问：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734004.webp"></p><p>在回答中可以点击 Find on Page 找到原文的参考文本：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734619.webp"></p><p>这个功能可以大大提升浏览网页的效率。</p><h3 id="5-Second-Previews"><a href="#5-Second-Previews" class="headerlink" title="5-Second Previews"></a>5-Second Previews</h3><p>在 google 中进行搜索时，鼠标悬停到搜索结果的链接上，会自动总结这个链接的内容，以卡片的形式进行展示，不用在一个一个链接点击去看了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734981.webp"></p><h3 id="Tidy-Tab-Titles"><a href="#Tidy-Tab-Titles" class="headerlink" title="Tidy Tab Titles"></a>Tidy Tab Titles</h3><p>当把页签从临时区拖到固定区时，会自动对页签的标题进行重命名，如果不满意也可以双击进行修改，下面是 .NET 下载页面的标题前后对比：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734754.webp"></p><h3 id="Tidy-Downloads"><a href="#Tidy-Downloads" class="headerlink" title="Tidy Downloads"></a>Tidy Downloads</h3><p>在 Arc 浏览器中进行下载时，会自动重命名下载的文件名，让文件名更容易理解：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734566.webp"></p><h3 id="ChatGPT-in-the-Command-Bar"><a href="#ChatGPT-in-the-Command-Bar" class="headerlink" title="ChatGPT in the Command Bar"></a>ChatGPT in the Command Bar</h3><p>在地址栏输入「ChatGPT」，然后点击 Tab 键，会出现如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734234.webp"></p><p>输入问题：介绍下 vue 的基本使用，Arc 会进入到 ChatGPT 的回答页面：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404231734002.webp"></p><p>希望本文对您有所帮助！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Arc 浏览器和 Readwise Reader 是我在 Mac 上很喜欢的两款工具，这两款工具最近推出的一些功能能极大提升效率。哦不，功能推出有一阵子了，我最近才开始使用。&lt;/p&gt;
&lt;p&gt;本文简单介绍下这些新功能。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="效率工具" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Reader" scheme="http://fwhyy.com/tags/reader/"/>
    
    <category term="Arc浏览器" scheme="http://fwhyy.com/tags/arc%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>银河麒麟V10使用Docker方式部署应用</title>
    <link href="http://fwhyy.com/2024/04/galaxy-kirin-v10-deploys-applications-using-docker/"/>
    <id>http://fwhyy.com/2024/04/galaxy-kirin-v10-deploys-applications-using-docker/</id>
    <published>2024-04-16T00:28:08.000Z</published>
    <updated>2024-09-30T15:33:39.538Z</updated>
    
    <content type="html"><![CDATA[<p>现在越来越多的企业级应用需要运行在国产化环境中，而银河麒麟 V10 是目前我碰到的最常用的服务器，在银河麒麟上部署应用有两种方式：使用二进制文件编译部署和使用 Docker 。</p><span id="more"></span><p>关于使用二进制文件的方式，在《银河麒麟系统安装中间件》中有相关介绍。如果客户允许使用 Docker，那可以更方便和快速进行部署了。</p><p>本文将介绍使用 Docker 的方式在银河麒麟 V10 服务器进行应用的部署。</p><p>可以使用下面命令查看服务器环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">hostnamectl</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409302331534.webp"></p><h2 id="需要安装的组件"><a href="#需要安装的组件" class="headerlink" title="需要安装的组件"></a>需要安装的组件</h2><p>1、服务器已经安装 Docker ，还需要安装 docker-compose</p><p>2、中间件包括 Nginx、Redis、Mysql、Rabbitmq、MongoDB</p><p>3、.NET 8 的相关处理</p><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><p>在下面地址下载相应的安装包：</p><p><a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409302331260.webp"></p><p>将安装包放到服务器 /root 目录，然后执行下面命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp docker-compose-linux-aarch64  /usr/local/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>安装完后，执行 <code>docker-compose -v</code> 查看版本号，能正常显示说明安装成功。</p><h2 id="Redis、MySql、RabbitMQ"><a href="#Redis、MySql、RabbitMQ" class="headerlink" title="Redis、MySql、RabbitMQ"></a>Redis、MySql、RabbitMQ</h2><p>根据验证发现中间件的 Docker 镜像有的可以直接拉取就可以，有的需要使用 arm64 版本的镜像，比如：</p><ul><li>Redis、MySql、RabbitMQ 可以直接拉取</li><li>MongoDB、Nginx 需要用 arm64 版本</li></ul><p>Redis、MySql、RabbitMQ 在 docker-compose.yml 文件中的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s2mysql:</span></span><br><span class="line"> <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line"> <span class="attr">ports:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">&quot;13306:3306&quot;</span></span><br><span class="line"> <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=xxxxxx</span></span><br><span class="line"> <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">./config/mysql:/docker-entrypoint-initdb.d/</span></span><br><span class="line"> <span class="attr">command:</span> <span class="string">mysqld</span> <span class="string">--character-set-server=utf8mb4</span> <span class="string">--collation-server=utf8mb4_general_ci</span> <span class="string">--default-authentication-plugin=mysql_native_password</span></span><br><span class="line"> <span class="attr">networks:</span></span><br><span class="line">  <span class="attr">s2_net:</span></span><br><span class="line">   <span class="attr">ipv4_address:</span> <span class="number">172.66</span><span class="number">.9</span><span class="number">.2</span></span><br><span class="line">   </span><br><span class="line"><span class="attr">s2redis:</span></span><br><span class="line"> <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> <span class="attr">image:</span> <span class="string">redis:6.2.14</span></span><br><span class="line"> <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"> <span class="attr">volumes:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">./config/redis/redis.conf:/etc/redis/redis.conf</span></span><br><span class="line"> <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">/etc/redis/redis.conf</span></span><br><span class="line"> <span class="attr">networks:</span></span><br><span class="line">  <span class="attr">s2_net:</span></span><br><span class="line">   <span class="attr">ipv4_address:</span> <span class="number">172.66</span><span class="number">.9</span><span class="number">.9</span></span><br><span class="line"></span><br><span class="line"><span class="attr">s2mq:</span></span><br><span class="line"> <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> <span class="attr">image:</span> <span class="string">rabbitmq:3.8.2-management</span></span><br><span class="line"> <span class="attr">environment:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"> <span class="attr">networks:</span></span><br><span class="line">  <span class="attr">s2_net:</span></span><br><span class="line">   <span class="attr">ipv4_address:</span> <span class="number">172.66</span><span class="number">.9</span><span class="number">.8</span></span><br></pre></td></tr></table></figure><p>奇怪的是，这些中间件的镜像中都有提供 arm 的版本，拿 Redis 来说，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409302332493.webp"></p><p>可能直接使用 <code>docker pull redis:6.2.14</code> 拉取到的镜像是兼容版本，因为看镜像大小，直接拉取的又 146MB ，特定版本只有几十MB 。</p><h2 id="MongoDB、Nginx"><a href="#MongoDB、Nginx" class="headerlink" title="MongoDB、Nginx"></a>MongoDB、Nginx</h2><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p>以 Nginx 为例来看如何进行特定版本的拉取。</p><p>1、访问 <a href="https://hub.docker.com/_/nginx/tags?page=&amp;page_size=&amp;ordering=&amp;name=1.25.4">https://hub.docker.com/_/nginx/tags?page=&amp;page_size=&amp;ordering=&amp;name=1.25.4</a> ,进入到 Nginx 的 1.25.4 版本的页面。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409302332631.webp"></p><p>2、点击前面的链接进入详细页面。</p><p><img src="../../attachmenent/image-20240412172214604.png"></p><p>3、复制 index digest ,拼接到 docker pull 的后面，最终的拉取镜像的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:1.25.4@sha256:b72dad1d013c5e4c4fb817f884aa163287bf147482562f12c56368ca1c2a3705</span><br></pre></td></tr></table></figure><p>4、拉取下来的镜像是没有 tag 的。</p><p><img src="../../attachmenent/image-20240412172718249.png"></p><p>可以使用 docker tag 命令进行 tag 设置或直接使用镜像 ID ，前端构建的 Dockerfile 文件内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="number">070027</span>a3cbe0</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /usr/share/nginx/html/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>1、拉取特定版本镜像的方式和上面 Nginx 一样。</p><p>2、需要主要的是在银河麒麟V10 系统中，对 MongoDB 的版本是有要求的 ，一开始使用 MongoDB 5.0 镜像，容器运行失败，错误日志如下：</p><blockquote><p>WARNING: MongoDB requires ARMv8.2-A or higher, and your current system does not appear to implement any of the common features for that!<br>applies to all versions ≥5.0, any of 4.4 ≥4.4.19<br>see <a href="https://jira.mongodb.org/browse/SERVER-71772">https://jira.mongodb.org/browse/SERVER-71772</a><br>see <a href="https://jira.mongodb.org/browse/SERVER-55178">https://jira.mongodb.org/browse/SERVER-55178</a><br>see also <a href="https://en.wikichip.org/wiki/arm/armv8#ARMv8_Extensions_and_Processor_Features">https://en.wikichip.org/wiki/arm/armv8#ARMv8_Extensions_and_Processor_Features</a><br>see also <a href="https://github.com/docker-library/mongo/issues/485#issuecomment-970864306">https://github.com/docker-library/mongo/issues/485#issuecomment-970864306</a></p></blockquote><p>上面的意思指的是不能使用大于等于 5.0 的版本，如果是使用 版本 4 ，不能大于 4.4.19 。</p><p>3、最后拉取了 4.2.24 ，终于运行成功了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo:4.2.24@sha256:699d652ed67423d689258bad7b316cf005dfbb82b334118ec306f049042f3717</span><br></pre></td></tr></table></figure><p>4、MongoDB 的 docker-compose.yml 配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mongo:</span></span><br><span class="line"> <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"> <span class="attr">image:</span> <span class="string">97e328c342e0</span></span><br><span class="line"> <span class="attr">environment:</span> </span><br><span class="line">   <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line"> <span class="attr">networks:</span></span><br><span class="line">  <span class="attr">s2_net:</span></span><br><span class="line">   <span class="attr">ipv4_address:</span> <span class="number">172.66</span><span class="number">.9</span><span class="number">.7</span></span><br></pre></td></tr></table></figure><h2 id="NET-8"><a href="#NET-8" class="headerlink" title=".NET 8"></a>.NET 8</h2><p>正常情况下，拉取 .NET 8 对应的镜像用来做应用的基础镜像即可。.NET 8 的镜像地址如下：</p><p> <a href="https://hub.docker.com/_/microsoft-dotnet-aspnet/">https://hub.docker.com/_/microsoft-dotnet-aspnet/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409302332511.webp"></p><p>通过上图可以发现，.NET 6 和 .NET 7 都有支持 Debian 11 的版本，但 .NET 8 只有 Debian 12。银河麒麟 V10 的内核是 Debian 11 ,而你恰巧又用的是  .NET 8 ，那暂时还没有办法使用 Docker 的方式部署，只能直接在服务器上安装 .NET 8 环境。</p><p>1、安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gmp-devel mpfr-devel libmpc-devel -y</span><br></pre></td></tr></table></figure><p>2、执行下面命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.visualstudio.microsoft.com/download/pr/1e449990-2934-47ee-97fb-b78f0e587c98/1c92c33593932f7a86efa5aff18960ed/dotnet-sdk-8.0.204-linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line">mkdir -p /opt/dotnet</span><br><span class="line">tar -zxvf dotnet-sdk-8.0.204-linux-arm64.tar.gz -C /opt/dotnet</span><br><span class="line"></span><br><span class="line">ln -s /opt/dotnet/dotnet /usr/bin</span><br><span class="line">export DOTNET_ROOT=/opt/dotnet</span><br><span class="line">export PATH=$PATH:/opt/dotnet</span><br></pre></td></tr></table></figure><p>3、执行命令  dotnet –info 进行验证，出现下面结果表示安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">.NET SDK:</span><br><span class="line"> Version:           8.0.204</span><br><span class="line"> Commit:            c338c7548c</span><br><span class="line"> Workload version:  8.0.200-manifests.9f663350</span><br><span class="line"></span><br><span class="line">运行时环境:</span><br><span class="line"> OS Name:     kylin</span><br><span class="line"> OS Version:  V10</span><br><span class="line"> OS Platform: Linux</span><br><span class="line"> RID:         linux-arm64</span><br><span class="line"> Base Path:   /opt/dotnet/sdk/8.0.204/</span><br><span class="line"></span><br><span class="line">已安装 .NET 工作负载:</span><br><span class="line">没有要显示的已安装工作负载。</span><br><span class="line"></span><br><span class="line">Host:</span><br><span class="line">  Version:      8.0.4</span><br><span class="line">  Architecture: arm64</span><br><span class="line">  Commit:       2d7eea2529</span><br><span class="line"></span><br><span class="line">.NET SDKs installed:</span><br><span class="line">  8.0.204 [/opt/dotnet/sdk]</span><br><span class="line"></span><br><span class="line">.NET runtimes installed:</span><br><span class="line">  Microsoft.AspNetCore.App 8.0.4 [/opt/dotnet/shared/Microsoft.AspNetCore.App]</span><br><span class="line">  Microsoft.NETCore.App 8.0.4 [/opt/dotnet/shared/Microsoft.NETCore.App]</span><br><span class="line"></span><br><span class="line">Other architectures found:</span><br><span class="line">  None</span><br><span class="line"></span><br><span class="line">Environment variables:</span><br><span class="line">  Not set</span><br><span class="line"></span><br><span class="line">global.json file:</span><br><span class="line">  Not found</span><br><span class="line"></span><br><span class="line">Learn more:</span><br><span class="line">  https://aka.ms/dotnet/info</span><br><span class="line"></span><br><span class="line">Download .NET:</span><br><span class="line">  https://aka.ms/dotnet/download</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在越来越多的企业级应用需要运行在国产化环境中，而银河麒麟 V10 是目前我碰到的最常用的服务器，在银河麒麟上部署应用有两种方式：使用二进制文件编译部署和使用 Docker 。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="中间件" scheme="http://fwhyy.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="国产化" scheme="http://fwhyy.com/tags/%E5%9B%BD%E4%BA%A7%E5%8C%96/"/>
    
    <category term="银河麒麟V10" scheme="http://fwhyy.com/tags/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9Fv10/"/>
    
  </entry>
  
  <entry>
    <title>复盘石家庄全马（PB 80 分钟）</title>
    <link href="http://fwhyy.com/2024/04/reviewing-the-shijiazhuang-marathon/"/>
    <id>http://fwhyy.com/2024/04/reviewing-the-shijiazhuang-marathon/</id>
    <published>2024-04-09T00:24:34.000Z</published>
    <updated>2024-09-30T15:27:03.112Z</updated>
    
    <content type="html"><![CDATA[<p>马拉松是极限运动，尤其是全马。</p><p>我从 2016 年开始跑步，2017 年便初生牛犊不怕虎，连续跑了两个全马（武汉马拉松、北京马拉松）。在没有做好充足准备的情况下，痛苦地完成了北京马拉松。</p><span id="more"></span><p>到底有多痛苦呢？</p><ul><li>没有跑量和力量训练作为基础，导致半程的时候就开始抽筋，后半程基本靠走</li><li>因为跑的慢，耗时长，加上天气炎热，又没有任何防晒措施，导致整个颈部肩膀全部脱皮</li><li>腿部的疼痛一个多星期后才慢慢恢复</li></ul><p>自此之后，就再也没跑过全马了。直到上周的石家庄马拉松，石家庄最后的成绩是 335，比起首马的武汉马拉松提升了 80 分钟。</p><p>下面从训练、赛前准备、比赛来复盘下这次石家庄马拉松比赛。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404081817865.webp"></p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>去年听了一系列的跑步类博客（在《认真深入做一件事，从跑步开始》中详细描述），让我对跑步有了新的理解和认识，原来健康无伤的跑步和追求成绩并不冲突；原来跑步还能进行科学的训练，而不是穿上鞋迈开腿就行；原来冬天和夏天才是真正训练的好时候，春和秋是比赛季。</p><p>所以，23 年 12 月我参加了 PB 计划，开始了严肃训练，到 24 年 3 月底，月均跑量超过了 250 公里，每一次的训练课基本都是按要求完成。</p><p>4 个月的训练中，除了一次 30 公里的马配强度课跑完，右髋有些痛之外，没有任何伤病，这要是以前自己跑，想要不受伤是很困难的。所以说，如果对成绩有追求，必须要科学训练。</p><p>整个训练分为四个阶段：准备期、提高期、巅峰期、调整期。每个周期大概四周，侧重点都有所不同，再加上教练对课表的精心编排，让原本很枯燥的跑步变得很有意思，每个阶段结束都很期待下一阶段的课表。</p><p>3 月 31 号比赛前，跑了 3 个 30 公里的长距离，最后的一个长距离是使用马配 450 ，跑完信心大增，这就是赛前模拟比赛跑长距离的一个很重要的作用。</p><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><p>赛前准备有：目标赛事、装备、补给、饮食、睡眠。</p><h3 id="目标赛事"><a href="#目标赛事" class="headerlink" title="目标赛事"></a>目标赛事</h3><p>其实最想跑的还是武汉，因为首马就是武汉，时隔 7 年，如果能再次在武汉创造一个好成绩，是很有意义的。</p><p>其次是无锡，很有口碑的一个比赛。除了武汉和无锡，我还报名了郑开、石家庄，最后只中签了石家庄，可见现在参加马拉松的人数有多么庞大。</p><p>在石家庄上了四年学，现在回到这座城市跑一场马拉松，挺好。</p><h3 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h3><p>1、春节前买了一双索康尼的啡鹏3，赛前进行了将近 100 公里的磨合，很柔和的一双碳板鞋，没有感觉很强的推进感，但很舒适、稳定。</p><p>2、配了一副近视的 goodr 眼镜，这个眼镜真的是太值了。31 号的石家庄是一个大晴天，存包后我就一直戴的 goodr，直到比赛完才摘下来。摘下的那一刻，我被晃到了，很惊讶这么晒，我是怎么跑完的。如果不是有这眼镜，不敢想象。</p><h3 id="补给"><a href="#补给" class="headerlink" title="补给"></a>补给</h3><p>1、比赛前一天在超市买了一罐红牛。</p><p>2、一支 gu 的能量胶和 5 只 sis 能量胶。</p><p>3、8 颗盐丸。</p><h3 id="饮食和睡眠"><a href="#饮食和睡眠" class="headerlink" title="饮食和睡眠"></a>饮食和睡眠</h3><p>赛前的一两周是调整期，逐步减强度和量，因为量的减少，早上起床时间可以稍微晚点，就有了更充足的睡眠。</p><p>吃的方面，临近比赛的几天碳水吃的多了点，周六到石家庄后，中午跟同学一起吃的板面，晚上吃的驴肉火烧，这就是所有的吃的方面的准备了。</p><h2 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h2><p>我有一同学，也中签了石家庄马拉松，30 号（星期六）我从武汉，他从北京同时去往石家庄，在火车站汇合，然后去领物、入住酒店。</p><p>本来是想要同学带我的，但因他前一周的重庆马拉松，因为天气热，跑蹦了，石家庄想冲击下成绩，所以我们就各自分开跑了。</p><p>因为住的比较远（终点附近），时间很紧张，检录、存包，然后去排队上厕所，弄完后已经 7 点 20了。</p><p>发枪前的几分钟，可能是兴奋和紧张，站着不动心率都快 100 了，还是有点忐忑的，很担心一起跑，心率就控制不住了。</p><p>7 点 30 分，准时发枪，因为我是排在 B 区比较靠后的位置，过拱门的时候已经 5 分多钟了。起跑时候大概 10 度左右，还是非常舒适的，而且石家庄的路面也比较宽敞，没有出现很拥挤的情况，按照之前的计划，第一公里配速 5 分多点，第二公里就慢慢加到 450 左右，然后就一直 450 左右的配速巡航，当配速稳定在 450 左右时，心率 160 出头，这时就比较踏实了，按照平时的训练，只要前半程心率不超过 165 ，后面还能再加速顶到 170 左右。</p><p>过半程的时候，看了下时间，用时 1 小时 41 分，当时想跑进 330 应该稳了，到 30 公里时，看平均配速是 449 ，心里一阵高兴，因为 449 的配速还没使全力，一会还能再加加速，没准还能 325 完赛呢。</p><p>正想着，就到了 31 公里，小腿开始有反应了，有抽筋的感觉，就只能降速了，中间还停下来拉伸了两三次，不过这时还没有放弃，一直在算配速应该怎么控制才能跑进 330 。</p><p>但小腿一直没有好转，只要加速就会抽，眼看着手表上的平均配速从 449 慢慢降到 450、451 一直到 5 分开外，这时也到 38 公里左右了，发现跑进 330 已经没有希望，就将目标设定为 335 ，一下子就轻松了很多，进水站也不着急，慢慢喝完，再继续前行，腿也适当得到了休息，导致最后的 12 公里反倒是比前面的轻松。</p><p>最后过终点的时候手表显示 3 小时 35 分多，跟最终的净成绩差不多。虽然有遗憾，没能破 330，不过这个成绩还是非常满意的。也是一个冬训努力的结果。和 7 年前相比，PB了 80 分钟呢。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202404081817861.webp"></p><h2 id="比赛补给"><a href="#比赛补给" class="headerlink" title="比赛补给"></a>比赛补给</h2><p>比赛中补给是非常重要的，这次所带的补给基本都是按照计划完成的。</p><p>1、赛前半个小时喝了一罐红牛，吃了一根 gu 的能量胶。</p><p>2、比赛中带了 5 跟 sis 等渗能量胶，因为是等渗，可以不用水，直接吃，所以我是按照时间来吃的，40 分钟一支 。</p><p>3、每个水站都有进去补水，不能等感觉渴的时候才进。</p><p>4、盐丸需要使用水服用，所以在 10 公里、20 公里 、30 公里、35 公里都吃了两粒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、全程马拉松是极限运动，想要尝试，特别是有成绩的突破，一定要系统科学的训练。</p><p>2、跑量和力量是基础，我这四个月的跑量是够的，这也是 30 公里后，小腿虽然抽筋，但还能坚持跑的原因，肌肉力量不足也是导致抽筋的原因。</p><p>3、赛前长距离很重要，除了能了解到在 30 公里后的身体状况，还能提升自信心。</p><p>4、心态很重要，适当降低预期，会带来意想不到的效果。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;马拉松是极限运动，尤其是全马。&lt;/p&gt;
&lt;p&gt;我从 2016 年开始跑步，2017 年便初生牛犊不怕虎，连续跑了两个全马（武汉马拉松、北京马拉松）。在没有做好充足准备的情况下，痛苦地完成了北京马拉松。&lt;/p&gt;</summary>
    
    
    
    <category term="跑步" scheme="http://fwhyy.com/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
    <category term="马拉松" scheme="http://fwhyy.com/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
    <category term="跑步" scheme="http://fwhyy.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
    <category term="石家庄全马" scheme="http://fwhyy.com/tags/%E7%9F%B3%E5%AE%B6%E5%BA%84%E5%85%A8%E9%A9%AC/"/>
    
    <category term="PB" scheme="http://fwhyy.com/tags/pb/"/>
    
  </entry>
  
  <entry>
    <title>能更好集成容器的反向代理Traefik简单使用</title>
    <link href="http://fwhyy.com/2024/03/traefik-is-easy-to-use/"/>
    <id>http://fwhyy.com/2024/03/traefik-is-easy-to-use/</id>
    <published>2024-03-29T00:13:56.000Z</published>
    <updated>2024-09-30T15:15:31.258Z</updated>
    
    <content type="html"><![CDATA[<p>traefik 与 nginx  一样，也是一款优秀的反向代理工具，使用 go 语言开发，本文将介绍怎样用 traefik 来实现我的需求。</p><span id="more"></span><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>1、WebAPI 接口中有两大类业务，当然根据具体情况可以是若干类。例如：workflow 和 interface，分别代表流程平台和接口平台。</p><p>2、在集群部署模式下，可以根据不同的路由分配到不同的节点。例如：一共部署了 10 个节点，workflow 分布式到其中的 3 个节点，interface 分布式到其余的 7 个节点。</p><p>这种方式的好处就是对于只有单一技术栈的团队，在物理上可以将代码组织在一起，方便维护，但在逻辑上可以将不同的业务分开，实现动态扩展和弹性。</p><p>当然上面的需求使用 nginx 也可以很容易做到，但本文采用的是 Træfɪk ，先来看看 Træfɪk 和 nginx 的区别。</p><h2 id="Traefik-和-Nginx-的区别"><a href="#Traefik-和-Nginx-的区别" class="headerlink" title="Traefik 和 Nginx 的区别"></a>Traefik 和 Nginx 的区别</h2><p>Traefik 和 Nginx 都是反向代理工具，但它们在设计和使用场景上存在一些区别。下面简要比较一下这两者：</p><ul><li>Traefik 可以无须重启即可更新配置，Nginx 据说能做到（没有验证过）</li><li>Traefik 可以自动的服务发现与负载均衡，Nginx 需要借助一些第三方工具</li><li>Traefik 对  Docker、Kubernetes、Swarm 的支持更好</li><li>Traefik 有漂亮的 dashboard 界面</li><li>Traefik 在功能上没有 Nginx 丰富，网上资料、案例也比 Nginx 少</li><li>Traefik 性能比 Nginx 要差，但具体差别多大，还未验证</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Traefik：v3.0.0-rc2</li><li>操作系统：macOS13.0</li><li>Docker：20.10.13</li></ul><h2 id="Traefik-简单示例"><a href="#Traefik-简单示例" class="headerlink" title="Traefik 简单示例"></a>Traefik 简单示例</h2><p>1、Traefik 使用 docker-compose 进行部署，部署前先创建一个 docker 网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create traefik-net</span><br></pre></td></tr></table></figure><p>2、创建一个 traefik-demo 的目录，目录中创建 docker-compose.yml 文件，用来构建一个 Traefik 容器。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">traefik:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">traefik:v3.0.0-rc2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">    <span class="attr">command:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--api=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--api.dashboard=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--api.insecure=true&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--entrypoints.http.address=:80&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--providers.docker=true&quot;</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.traefik-dashboard.entrypoints=http&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.traefik-dashboard.rule=Host(`traefik.fw.com`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.traefik-dashboard.service=dashboard@internal&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.traefik-dashboard-api.entrypoints=http&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.traefik-dashboard-api.rule=Host(`traefik.fw.com`) &amp;&amp; PathPrefix(`/api`)&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.traefik-dashboard-api.service=api@internal&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">traefik-net</span></span><br><span class="line">      </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">traefik-net:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">traefik-net</span> </span><br></pre></td></tr></table></figure><ul><li><p>/var/run/docker.sock:/var/run/docker.sock：允许 Traefik 访问 Docker 守护进程，用于自动发现 Docker 服务，允许 Traefik 订阅 Docker 服务事件，来动态的添加或删除要对用户暴露的网络服务</p></li><li><p>–api=true：启用 Traefik API</p></li><li><p>–api.dashboard=true：启用 Traefik 的 Web UI</p></li><li><p>–api.insecure=true：允许不安全的 API 和 Web UI 访问</p></li><li><p>–entrypoints.http.address=:80：设置 HTTP 入口点在容器的 80 端口</p></li><li><p>–providers.docker=true：启用 Docker 作为服务提供者</p></li></ul><p>通过在 Docker Labels 中添加了声明式的路由，分别将 Dashboard 的网页（路由名称  traefik-dashboard ）和 API （路由名称 traefik-dashboard-api ）注册在了我们创建的 http 网络入口上，用户就可以通过我们设置的域名来访问服务了。</p><ul><li><p>traefik.http.routers.traefik-dashboard.entrypoints=http: 为 Traefik dashboard 设置入口点</p></li><li><p>traefik.http.routers.traefik-dashboard.rule=Host(traefik.fw.com)：设置访问 Traefik dashboard 的主机规则</p></li><li><p>traefik.http.routers.traefik-dashboard.service=dashboard@internal：指定 Traefik dashboard 使用内部服务</p></li><li><p>traefik.http.routers.traefik-dashboard-api.entrypoints=http：为 Traefik API 设置入口点</p></li><li><p>traefik.http.routers.traefik-dashboard-api.rule=Host(traefik.fw.com) &amp;&amp; PathPrefix(/api)：设置访问 Traefik API 的主机和路径前缀规则。</p></li><li><p>traefik.http.routers.traefik-dashboard-api.service=api@internal：指定 Traefik API 使用内部服务。</p></li></ul><p>3、上面的配置中有一个域名：traefik.fw.com ，这是我本地测试使用的域名，正式环境替换为真实域名即可。本地测试可以通过修改 hosts 文件的方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/</span><br><span class="line">sudo chmod 777 hosts</span><br><span class="line">vi hosts</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 traefik.fw.com</span><br></pre></td></tr></table></figure><p>4、在 traefik-demo 目中中执行 docker-compose up -d traefik 来构建 Traefik 服务，执行成功后，在浏览器中访问：traefik.fw.com ，可以看到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403281711102.webp"></p><p>可以看到 Services 有 10 个，其中包含了我本机上部署的其他的 docker 容器。</p><p>5、使用官方的测试容器来进行测试，修改 docker-compose.yml 文件，在下面添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">whoami:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">containous/whoami</span>    </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.whoami.rule=Host(`whoami.fw.com`)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.whoami.loadbalancer.server.port=80&quot;</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">traefik-net</span></span><br></pre></td></tr></table></figure><p>6、执行 docker-compose up -d whoami 进行构建，构建成功后，命令行执行：curl -H Host:whoami.fw.com <a href="http://127.0.0.1/">http://127.0.0.1</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403281711020.webp"></p><p>7、现在使用命令：docker-compose up -d –scale whoami=2 对 whoami 服务进行扩容，创建成功后，再使用：curl -H Host:whoami.fw.com <a href="http://127.0.0.1/">http://127.0.0.1</a> 进行测试，会发现已经在两个容器间进行负载了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403281711861.webp"></p><h2 id="使用-WebAPI-示例进行验证"><a href="#使用-WebAPI-示例进行验证" class="headerlink" title="使用 WebAPI 示例进行验证"></a>使用 WebAPI 示例进行验证</h2><p>1、使用 C# 编写 WebAPI 接口，创建两个 Controller 模拟两个不同的业务，InterfaceCenterController 和 WorkflowController ，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[ApiController]</span><br><span class="line">[Route(&quot;[controller]&quot;)]</span><br><span class="line">public class WorkflowController : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet()]</span><br><span class="line">    public string Test()</span><br><span class="line">    &#123;</span><br><span class="line">        string ip = Request.HttpContext.Connection.LocalIpAddress.MapToIPv4().ToString() + &quot;:&quot; +</span><br><span class="line">                     Request.HttpContext.Connection.LocalPort.ToString();</span><br><span class="line"></span><br><span class="line">        return $&quot;workflow server,&#123;ip&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[ApiController]</span><br><span class="line">[Route(&quot;[controller]&quot;)]</span><br><span class="line">public class InterfaceCenterController : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet()]</span><br><span class="line">    public string Test()</span><br><span class="line">    &#123; </span><br><span class="line">        string ip = Request.HttpContext.Connection.LocalIpAddress.MapToIPv4().ToString() + &quot;:&quot; +</span><br><span class="line">                  Request.HttpContext.Connection.LocalPort.ToString();</span><br><span class="line">        return $&quot;interfaceCenter server,&#123;ip&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、代码写好后，进行发布，在发布目录中创建 Dockerfile 文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="number">3.1</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;ApiDemo.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>3、执行下面命令进行镜像构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t apidemo .</span><br></pre></td></tr></table></figure><p>4、修改 traefik-demo 目录中的 docker-compose.yml 文件，在下面添加如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apidemo:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">apidemo</span> </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.apidemo.entrypoints=http&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.apidemo.rule=Host(`apidemo.fw.com`)  &amp;&amp; PathPrefix(`/workflow`)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.apidemo.loadbalancer.server.port=80&quot;</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">traefik-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apidemo-1:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">apidemo</span> </span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.enable=true&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.apidemo-1.entrypoints=http&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.routers.apidemo-1.rule=Host(`apidemo.fw.com`) &amp;&amp; PathPrefix(`/interfacecenter`)&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;traefik.http.services.apidemo-1.loadbalancer.server.port=80&quot;</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">traefik-net</span></span><br></pre></td></tr></table></figure><ul><li>在 apidemo 中配置了路由 PathPrefix(<code>/workflow</code>) 表示只接受工作流平台的业务</li><li>在 apidemo-1 中配置了路由 PathPrefix(<code>/interfacecenter</code>) 表示只接受接口平台的业务</li></ul><p>5、在上面 labels 的路由配置中使用了 apidemo.fw.com 的域名，同样，这个域名也需要配置到 hosts 文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 traefik.fw.com apidemo.fw.com</span><br></pre></td></tr></table></figure><p>6、执行下面的命令进行容器的构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d apidemo</span><br><span class="line">docker-compose up -d apidemo-1</span><br></pre></td></tr></table></figure><p>7、使用 Postman 进行测试：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403281711073.webp"><br><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403281710943.webp"></p><ul><li>当访问 workflow 路由时，返回的容器 IP 一直都是 172.18.0.2</li><li>当访问 interfacecenter 路由时，返回的容器 IP 一直都是 172.18.0.4</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;traefik 与 nginx  一样，也是一款优秀的反向代理工具，使用 go 语言开发，本文将介绍怎样用 traefik 来实现我的需求。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="http://fwhyy.com/tags/docker/"/>
    
    <category term="Kubernetes" scheme="http://fwhyy.com/tags/kubernetes/"/>
    
    <category term="Traefik" scheme="http://fwhyy.com/tags/traefik/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊云原生</title>
    <link href="http://fwhyy.com/2024/03/lets-briefly-talk-about-cloud-native/"/>
    <id>http://fwhyy.com/2024/03/lets-briefly-talk-about-cloud-native/</id>
    <published>2024-03-19T00:48:37.000Z</published>
    <updated>2024-09-30T13:50:14.653Z</updated>
    
    <content type="html"><![CDATA[<p>云原生，作为一种新兴的软件架构模式，目的在推动应用程序的敏捷开发、快速部署和可靠运行。虽然这一概念已经提出多年，但直至最近几年，云原生才逐渐引起了华中区客户的广泛关注和认知（不一定准确，从我的感觉和经验来看是这样的）。</p><p>本文结合我收集整理的资料、以及我的理解，来看看云原生是怎么回事？</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>要搞清一个技术，先从概念开始，跟云原生这个概念有关的主要有两个组织：Pivotal 和 CNCF 。</p><ul><li><p>Pivotal：Pivotal 成立于 2013 年 4 月，由 EMC、VMware 和 GE 投资成立，专注于帮助企业在数字化时代变革所需的 PaaS 云计算、大数据基础平台和平台上的极限编程。</p></li><li><p>CNCF：CNCF（Cloud Native Computing Foundation，云原生计算基金会）是 Linux 基金会旗下的基金会，可以理解为一个非盈利组织，成立于 2015 年 12 月 11 日。</p></li></ul><p>2015 年，来自 Pivotal 公司的技术产品经理 Matt Stine，首次提出了云原生的概念，认为云原生架构必须包含下面一些特性：</p><blockquote><p>符合十二要素、微服务、敏捷基础设施、基于 API 的协作、抗压性</p></blockquote><p>2017 年，Matt Stine 在接受 InfoQ 采访时，将云原生特性做了些调整：</p><blockquote><p>模块化、可观测性、可部署性、可测试性、可处理性、可替换性</p></blockquote><p>而现在的云原生涉及到的一些关键词有，原文可以参考：<a href="https://tanzu.vmware.com/cloud-native%EF%BC%9A">https://tanzu.vmware.com/cloud-native：</a></p><blockquote><p>微服务、DevOps、容器、服务网格、CI/CD、Serverless </p></blockquote><p>可见，云原生的定义是在不断演进的，不断会有新的东西加入。</p><p>再来看看 CNCF 的官方最早是怎么定义的： </p><blockquote><p>Cloud native computing uses an open source software stack to deploy applications as microservices, packaging each part into its own container, and dynamically orchestrating those containers to optimize resource utilization. </p><p>云原生使用一种开源软件技术栈来部署微服务应用，将每个组件打包到它自己的容器中，并且通过动态编排来优化资源的利用率。 </p></blockquote><p>2018 年，CNCF 推出了对云原生定义的 v1.0 版本，地址如下：</p><p><a href="https://github.com/cncf/toc/blob/main/DEFINITION.md">https://github.com/cncf/toc/blob/main/DEFINITION.md</a></p><blockquote><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API。</p><p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p><p>云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。</p></blockquote><h2 id="云计算和云原生的关系"><a href="#云计算和云原生的关系" class="headerlink" title="云计算和云原生的关系"></a>云计算和云原生的关系</h2><p>早些年，传统的企业软件开发是部署在企业的内部物理机中，为了让一个系统能正常运行，通常需要很多的机器，数据库、中间件、程序的前后端都需要进行单独部署。</p><p>后来有了虚拟化技术，通过在各种实体资源（CPU、内存、网络、存储等）之上构建一个逻辑层，从而摆脱物理限制的约束，提高物理资源的利用率。最直观的感受就是可以在一台物理机上快速运行多个虚拟机、意味着可以<strong>降低物理机的数量，节约成本。</strong></p><p>虚拟技术的成熟促成了云计算的出现。2006 年 Google 首次提出了云计算的概念。云计算出现之后，就慢慢出现了 XaaS ：</p><ul><li><strong>IaaS（基础设施即服务）</strong>：一种云计算服务类型，它按即用即付的方式按需提供必要的计算、存储和网络资源。这种服务模式帮助客户降低维护成本和硬件成本。</li><li><strong>PaaS（平台即服务）</strong>：云计算服务模式之一，它为开发人员提供了包括一系列开发工具、服务、应用程序接口（API）等资源的平台。它的目标是让开发者能够更快速、高效地构建、发布、扩展和维护应用，同时云服务商负责管理和提供开发环境。</li><li><strong>aPaaS（应用平台即服务）</strong>：是一类特定的 PaaS，重点在于为应用程序提供更快捷的构建服务，例如低代码能力。通常包括通过可视化操作减少原生代码使用、高效的数据处理、模块化的功能实现等，目的是为了让开发者更高效地搭建、运行、维护和扩展应用。</li><li><strong>DaaS（数据即服务）</strong>：将数据从静态资源转变为一种可通过网络获取的即时服务。用户可以方便地访问和使用数据，无需关心数据存储和管理的底层细节。数据通过平台进行集中化管理，提供规范化、标准化的数据访问和数据处理流程。</li><li><strong>FaaS（函数即服务）</strong>：是一种基于事件驱动的无服务器执行模式，在这种模式中，开发人员无需关心服务器的管理和维护，只需编写并上传业务函数代码。当触发特定事件时，这些代码由云服务商在全托管的环境中执行。</li><li><strong>SaaS（软件即服务）</strong>：一种云计算模式，在这种模式中，软件通常以网络浏览器的形式提供给用户。用户不需要在本地机器上安装或维护软件，所有的应用程序和数据库都位于云端的数据中心。这减少了用户在软件和硬件方面的投入和维护工作。</li></ul><p>云计算的兴起，一些企业将软件逐渐迁移到公有云，无需再关心网络、存储、服务器等，这些都由云厂商的 IaaS、PaaS 能力提供。</p><p>但是，也只能说是将应用迁移到了云端，只是软件运行的平台和运维体系发生了变化，软件的架构和业务形式并没有发生大的变化。部署到云端的应用并没有将云的特性展现出来，原因是因为这些应用大多都是传统的单体架构，在灵活性扩展性上都有很大的局限性。所以说，这还不是真正的云原生应用。</p><p>要做到真正的云原生应用，程序需要做一定的改造，要能适配容器化部署和编排；要能像微服务应用一样快速响应、动态伸缩；要能适配各种云端的中间件等。</p><p>云原生使用了云计算的能力，云计算提供了强大的基础设施和计算资源，为云原生的发展提供了基础，而云原生则通过优化应用程序的架构和管理方式，更好地利用云计算的优势。它们之间是相辅相成的。</p><h2 id="云原生的好处"><a href="#云原生的好处" class="headerlink" title="云原生的好处"></a>云原生的好处</h2><p>从上面的介绍中也可以看出，云原生终极目的就是可以省各种成本，比如：开发成本、运维成本、硬件成本、维护成本等。</p><p>之所以可以省成本，主要得益于以下几个方面的设计和实践：</p><ul><li><strong>容器化：</strong> 通过容器化应用程序，将应用程序及其依赖项打包成轻量级、可移植的容器，使得它们更易于部署和扩展。</li><li><strong>容器编排：</strong> 自动化部署和容器编排工具（如Kubernetes）可以快速、动态地调整应用程序实例的数量，为流量和负载的变化提供响应，从而提高了弹性和可伸缩性。</li><li><strong>微服务架构：</strong> 云原生架构通常采用微服务架构，它将应用程序拆分为一组小型的、独立部署的服务，使得每个服务都可以独立扩展和调整，为系统整体提供了更强的弹性。我理解的微服架构务并不一定是物理上的拆分，如果能实现逻辑上的拆分，即便物理上仍然是一个单体，也是具备可伸缩性、灵活性的。</li><li><strong>动态资源调度：</strong> 云原生架构允许动态调度资源，根据需求分配计算资源，以满足应用程序的需求，从而提高了资源利用率，同时提供了更好的弹性。</li><li><strong>快速交付和持续部署</strong>：云原生架构支持自动化的持续集成和持续交付（CI/CD）流程，能够使新功能、更新和修复迅速地交付给用户。这提高了开发团队的效率，缩短了产品上线周期，有助于企业更快速地响应市场变化。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我们在了解云原生概念、开发云原生应用的时候，一定要能真正去解决业务痛点，享受云原生带来的好处，比如说对程序进行微服务改造，那么我们是不是应该事先考虑下改造的成本、改造后带来的好处和带来的问题，综合权衡后再做决定。</p><p>InfoQ 上有篇文章就是一个反例，亚马逊 Prime Video 团队从微服务转变为单体，反倒成本降低 90% ，有兴趣的可以看看：<a href="https://www.infoq.cn/article/NU2Y3XiazG1cqiaNoXXa">https://www.infoq.cn/article/NU2Y3XiazG1cqiaNoXXa</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;云原生，作为一种新兴的软件架构模式，目的在推动应用程序的敏捷开发、快速部署和可靠运行。虽然这一概念已经提出多年，但直至最近几年，云原生才逐渐引起了华中区客户的广泛关注和认知（不一定准确，从我的感觉和经验来看是这样的）。&lt;/p&gt;
&lt;p&gt;本文结合我收集整理的资料、以及我的理解，</summary>
      
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="云原生" scheme="http://fwhyy.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>在.NET中动态执行Nodejs代码的另一种方法</title>
    <link href="http://fwhyy.com/2024/03/in-another-method-for-dynamically-executing-nodejs-code-in-dotnet/"/>
    <id>http://fwhyy.com/2024/03/in-another-method-for-dynamically-executing-nodejs-code-in-dotnet/</id>
    <published>2024-03-11T00:45:14.000Z</published>
    <updated>2024-09-30T13:47:22.657Z</updated>
    
    <content type="html"><![CDATA[<p>在低代码平台中，通常有业务逻辑编排的能力，在业务逻辑编排中有很多不同类型的节点，例如：逻辑判断、接口调用、数据更新等，但为了方便开发人员使用，如果添加代码块的节点，将会极大增加开发效率。</p><span id="more"></span><p>代码块节点可以使用 Node.js、Python 等解释型语言来处理逻辑，在《dotNet 5 中执行 Node.js》一文中，介绍了在 .NET 中通过 NodeServices 包来动态执行 Node.js 代码。但会有些局限。比如用户想要使用更多的 Node.js 包，就不太容易做到。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403102016732.webp"></p><p>所以本文介绍另一种思路了，其实非常简单，主要分三步：</p><p>1、编写 Node.js 服务，执行 js 代码</p><p>2、编写 .NET API 接口，调用 Node.js 服务</p><p>3、使用 Docker 进行部署</p><h2 id="Node-js-服务"><a href="#Node-js-服务" class="headerlink" title="Node.js 服务"></a>Node.js 服务</h2><p>1、使用 Node.js 的 express 框架来实现一个 Node.js 服务，首先用 npm init 进行初始化一个项目，初始化后，会产生一个 package.json ，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;api-demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用命令 <code>npm i express</code> 安装 express ，安装时可以会出现下面错误，这时可以切换不同的镜像源进行尝试：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403102016213.webp"></p><p>使用下面命令可以切换镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://npm.aliyun.com/</span><br></pre></td></tr></table></figure><p>如果还是不成功，可以尝试几个不同的镜像源，我是换到中科大就迅速安装成功了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">腾讯:http://mirrors.cloud.tencent.com/npm/</span><br><span class="line">华为：https://mirrors.huaweicloud.com/repository/npm/</span><br><span class="line">中科大镜像:https://registry.npmjs.org/</span><br><span class="line">淘宝镜像1：https://registry.npm.taobao.org</span><br><span class="line">淘宝镜像2：https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>3、使用 VS Code 打开 package.json 所在目录，并且添加 api.js 文件，文件内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(express.json())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3006</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;express 服务启动成功&#x27;</span>));</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&#x27;/execute&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = req.body</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(data &amp;&amp; data.Code)&#123;</span><br><span class="line">        <span class="keyword">var</span> code=data.Code;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> result=<span class="built_in">eval</span>(code);</span><br><span class="line">            res.json(&#123;result&#125;);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">            res.json(&#123;<span class="attr">error</span>:e.message&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.json(&#123;<span class="attr">error</span>:<span class="string">&#x27;Invalid request body&#x27;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>可以在命令行使用 <code>node api.js</code> 进行服务启动，启动后可以在浏览器用 3006 端口进行访问</li><li>上面代码中定义了一个路由为 execute 的 Post 接口</li><li>接口接受到需要执行的 js 代码，使用 eval 进行执行，然后返回结果</li></ul><h2 id="NET-调用"><a href="#NET-调用" class="headerlink" title=".NET 调用"></a>.NET 调用</h2><p>下面使用 .NET 8 的 Mini API ，创建一个接口来进行对 Node.js 服务的调用。</p><p>1、在 Rider 中创建一个 .NET 8 的 Web API 项目。</p><p>2、接口代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Net.Http.Headers;</span><br><span class="line">using Newtonsoft.Json;</span><br><span class="line">var builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line">builder.Services.AddEndpointsApiExplorer();</span><br><span class="line">builder.Services.AddSwaggerGen();</span><br><span class="line"></span><br><span class="line">builder.Services.AddHttpClient();</span><br><span class="line"></span><br><span class="line">var app = builder.Build();</span><br><span class="line"></span><br><span class="line">if (app.Environment.IsDevelopment())</span><br><span class="line">&#123;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI();</span><br><span class="line">&#125;</span><br><span class="line">app.UseHttpsRedirection();</span><br><span class="line"></span><br><span class="line">app.MapPost(&quot;/run&quot;, async (IHttpClientFactory clientFactory,CodeBlockInfo codeBlockInfo) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var client = clientFactory.CreateClient();</span><br><span class="line">    string uri = &quot;http://localhost:3006/execute&quot;;</span><br><span class="line">    </span><br><span class="line">    HttpContent context = new StringContent(JsonConvert.SerializeObject(codeBlockInfo));</span><br><span class="line">    context.Headers.ContentType = new MediaTypeHeaderValue(&quot;application/json&quot;);</span><br><span class="line"></span><br><span class="line">    var result = await client.PostAsync(uri,context);</span><br><span class="line">    string resultContent = result.Content.ReadAsStringAsync().Result;</span><br><span class="line">    return resultContent;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br><span class="line"></span><br><span class="line">public class CodeBlockInfo</span><br><span class="line">&#123;</span><br><span class="line">    public string Code &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>定义一个 CodeBlockInfo 实体用来传输需要执行的 js 代码</li><li>接口 run 中调用 Node.js 的服务，然后将执行的结果返回</li><li>关于使用 HttpClient 调用第三方接口，可以参考：<a href="https://learn.microsoft.com/zh-cn/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests">https://learn.microsoft.com/zh-cn/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests</a></li></ul><p>3、下面一段 js 代码是解析身份证号，从中提取出生日期和性别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> idcard = <span class="string">&#x27;420111202401011234&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> birthday = idcard.substr(<span class="number">6</span>, <span class="number">4</span>) + <span class="string">&#x27;-&#x27;</span> + idcard.substr(<span class="number">10</span>, <span class="number">2</span>) + <span class="string">&#x27;-&#x27;</span> + idcard.substr(<span class="number">12</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> sex = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (idcard.substr(<span class="number">16</span>, <span class="number">1</span>) % <span class="number">2</span> == <span class="number">1</span>) &#123; </span><br><span class="line">    sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">&#125;; </span><br><span class="line">output=&#123;<span class="string">&#x27;生日&#x27;</span>:birthday,<span class="string">&#x27;性别&#x27;</span>:sex&#125;</span><br></pre></td></tr></table></figure><p>4、运行 .NET 程序，使用 Postman 进行测试，上面的代码就是入参：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403102016851.webp"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>1、在目录中创建 Dockerfile 文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:latest</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3006</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;api.js&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>2、执行下面命令进行镜像构建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t node-execute-code-demo .</span><br></pre></td></tr></table></figure><p>3、执行下面命令运行容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3106:3006 --name node-execute-code-demo --restart=always node-execute-code-demo</span><br></pre></td></tr></table></figure><h3 id="NET-API"><a href="#NET-API" class="headerlink" title=".NET API"></a>.NET API</h3><p>1、对 API 项目进行发布，发布后的内容在 <code>bin/Release/net8.0/publish/</code> 目录中。</p><p>2、在 publish 目录中添加 Dockerfile 文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:<span class="number">8.0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5271</span>/tcp</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;Run-NodeJS-Demo.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>3、执行下面命令进行镜像构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t net-run-nodejs-demo .</span><br></pre></td></tr></table></figure><p>4、执行下面命令运行容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9090:8080 --name net-run-nodejs-demo --restart=always net-run-nodejs-demo</span><br></pre></td></tr></table></figure><p>需要注意的是，上面的代码示例中将 Node.js 的访问地址写死在了接口方法中，并且使用的是 localhost，如果部署到容器中会导致不能正常访问，正式环境需要使用服务器的 IP，并使用配置的方式。</p><h3 id="使用-Docker-Compose"><a href="#使用-Docker-Compose" class="headerlink" title="使用 Docker Compose"></a>使用 Docker Compose</h3><p>上面的两个步骤中已经创建了 Node.js 和 .NET API 的镜像，下面使用一个 Docker Compose 的方式来进行容器的管理。</p><p>1、创建一个 code-execute-demo 目录。</p><p>2、在目录中创建 docker-compose.yml 文件，文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"> <span class="attr">fw_net:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">  <span class="attr">ipam:</span></span><br><span class="line">   <span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">   <span class="attr">config:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">172.88</span><span class="number">.8</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"> <span class="attr">nodejs:</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">node-execute-code-demo:latest</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3106:3006&quot;</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">   <span class="attr">fw_net:</span></span><br><span class="line">    <span class="attr">ipv4_address:</span> <span class="number">172.88</span><span class="number">.8</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="attr">net-api:</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">net-run-nodejs-demo</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;9090:8080&quot;</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">   <span class="attr">fw_net:</span></span><br><span class="line">    <span class="attr">ipv4_address:</span> <span class="number">172.88</span><span class="number">.8</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><p>3、命令执行 <code>docker-compose up -d</code> 进行容器的构建，构建完成可以使用 <code>docker-compose ps</code> 来查看容器是否正常：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202403102016692.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在低代码平台中，通常有业务逻辑编排的能力，在业务逻辑编排中有很多不同类型的节点，例如：逻辑判断、接口调用、数据更新等，但为了方便开发人员使用，如果添加代码块的节点，将会极大增加开发效率。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term=".NET" scheme="http://fwhyy.com/tags/net/"/>
    
    <category term="Nodejs" scheme="http://fwhyy.com/tags/nodejs/"/>
    
  </entry>
  
</feed>
