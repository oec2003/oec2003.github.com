<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冯威的博客</title>
  
  <subtitle>公众号：不止dotNET | 临渊羡鱼不如退而结网</subtitle>
  <link href="http://fwhyy.com/atom.xml" rel="self"/>
  
  <link href="http://fwhyy.com/"/>
  <updated>2025-02-13T01:15:56.605Z</updated>
  <id>http://fwhyy.com/</id>
  
  <author>
    <name>oec2003</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>插件开发：实现 Obsidian 同步到 hexo</title>
    <link href="http://fwhyy.com/2025/02/plugin-development-implement-obsidian-synchronization-to-hexo/"/>
    <id>http://fwhyy.com/2025/02/plugin-development-implement-obsidian-synchronization-to-hexo/</id>
    <published>2025-02-13T00:37:00.000Z</published>
    <updated>2025-02-13T01:15:56.605Z</updated>
    
    <content type="html"><![CDATA[<p>近两年一直使用 Obsidian 进行最终文字的输出，除了发公众号，还会同步发布到博客中，博客使用的 hexo，现在发布博客的步骤是：</p><span id="more"></span><p>1、将文章标题在翻译软件中翻译为英文，并以横线隔开每个单词，作为 hexo 的文件名。</p><p>2、vs code 打开 hexo 的代码，执行 <code>hexo n &#39;英文的文件名&#39;</code> 。</p><p>3、将 Obsidian 中的文章内容复制到新创建的 md 文件中。</p><p>4、修改内容最上方的 Front Matter 信息，例如：categories、tags、date 等。</p><p>5、执行下面命令完成构建和发布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这个步骤还是有点繁琐，所以经常会忘记更新，忘记不是因为我懒，而是方式不是最优，最终影响到了执行。平时工作也是同样的道理，一件事情如果很繁琐，不顺利，就得停下来看看方法是不是用错了。</p><p>最近在尝试使用各类 AI 工具，就想着这个问题是可以写个 Obsidian 的插件来减少工作量的，于是花了一个晚上搞定了。</p><p>1、使用的工具是 Windsurf，模型还是用的 Cloude 3.5 sonnet ，之所以没用 DeepSeek，是因为通过这几天的试用，感觉 Windsurf 对 Cloude 3.5 sonnet 的调教更优一些（个人感觉）。</p><p>2、遵循一次性对话尽可能只让 AI 完成一件事的原则，我先让生成一个 Obsidian 插件的基础文件，核心逻辑在 main.ts 文件中：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502121650565.webp"></p><p>3、接着就按照我上面提到的步骤一步一步引导 Windsurf 来完成开发。</p><ul><li>获取文章标题调用翻译 API 转换为英文，并添加横线隔开，翻译 API 一开始使用的腾讯，几轮下来还是存在问题，换成百度的翻译 API 就运行成功了</li><li>将文章内容复制到 hexo 的 <code>_posts</code>  目录，获取 Obsidian 文章中的 tag 和 categories，自动转换为 hexo 需要的 Front Matter 格式</li><li>过程中如果遇到错误，可以打开 Obsidian-&gt;View-&gt;Toggle Developer Tools （和网页的 F12 一样），将错误信息提供，几轮下来基本都能解决</li></ul><p>4、代码写完，执行 <code>npm run build</code> 进行构建，构建完成后，会生成一个新的 main.js 文件，Obsidian 插件需要的是包含 main.js 在内的三个文件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502121651563.webp"></p><p>5、怎么安装到 Obsidian，具体步骤也可以在 Windsurf 中询问：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502121651705.webp"></p><ul><li>需要注意的是重新覆盖了 main.js 文件后，需要重新加载插件（禁用后重新启用）才能生效。</li></ul><p>6、首次安装后，在 Obsidian 的第三方插件中就可以看到自己开发的插件了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502121651842.webp"></p><p>7、因为使用了百度的翻译、又要将文章内容同步到 hexo 中，所以需要在插件的设置中配置相关参数：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502121651187.webp"></p><p>8、在文档中点击右键，菜单中选择「Publish to Hexo」就可以完成发布了。发布按钮可以放在以下位置，可以让 Windsurf 根据需要自行选择：</p><ul><li>左侧按钮栏</li><li>页面菜单项（Page Menu，也就是右上角的三个点菜单）</li><li>编辑器菜单项（Editor Menu，右键菜单）</li><li>命令面板（原有的位置，可以通过 Ctrl/Cmd + P 调出）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502121651893.webp"></p><p>9、文章内容同步到 hexo 后，在 hexo 的根目录执行 <code>hexo g hexo d</code> 便可发布了。</p><p>插件代码已经上传到 Github，地址如下：</p><p><a href="https://github.com/oec2003/obsidian-to-hexo-plugin">https://github.com/oec2003/obsidian-to-hexo-plugin</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近两年一直使用 Obsidian 进行最终文字的输出，除了发公众号，还会同步发布到博客中，博客使用的 hexo，现在发布博客的步骤是：&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="hexo" scheme="http://fwhyy.com/tags/hexo/"/>
    
    <category term="插件" scheme="http://fwhyy.com/tags/%E6%8F%92%E4%BB%B6/"/>
    
    <category term="obsidian" scheme="http://fwhyy.com/tags/obsidian/"/>
    
  </entry>
  
  <entry>
    <title>DeepSeek R1震撼登场：从介绍到使用</title>
    <link href="http://fwhyy.com/2025/02/deepseek-r1-makes-a-stunning-debut-from-introduction-to-use/"/>
    <id>http://fwhyy.com/2025/02/deepseek-r1-makes-a-stunning-debut-from-introduction-to-use/</id>
    <published>2025-02-08T08:31:00.000Z</published>
    <updated>2025-02-12T08:32:01.306Z</updated>
    
    <content type="html"><![CDATA[<p>春节期间，DeepSeek 掀起了一股热潮，成为了科技领域的热门话题。身边很多非圈内人士茶余饭后也在讨论 DeepSeek，足以见得其火爆程度。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>DeepSeek 全称：杭州深度求索人工智能基础技术研究有限公司，成立于 2023 年 7 月 17 日。由知名量化投资机构幻方量化创立并孵化。</p><p>幻方量化是中国顶尖的对冲基金公司，擅长利用 AI 算法优化金融交易策略。其强大的算力资源和技术积累为 DeepSeek 的研发提供了硬件支持和资金保障。</p><p>DeepSeek 的创始人梁文峰出生于 1985 年，17 岁考入浙江大学，拥有信息与电子工程学硕士学位。2023 年，梁文锋宣布进军通用人工智能（AGI）领域，创办了 DeepSeek，致力于开发真正人类级别的人工智能。</p><p>DeepSeek 近期发布了三个模型，分别是：24 年 12 月 26 的 DeepSeek V3、25 年 1 月 20 日发布了 DeepSeek R1、25 年 1 月 28 日发布的多模态模型 Janus-Pro 。</p><blockquote><p>V3：该模型是混合专家（MoE）架构，参数量达 6710 亿，激活参数为 370 亿，预训练数据量为 14.8 万亿 token。在百科知识（MMLU、GPQA）、长文本（DROP、LongBench v2）、代码（Codeforces）、数学（AIME 2024、CNMO 2024）等评测中超越主流开源模型（如 Qwen2.5-72B、Llama-3.1-405B），并与 Claude-3.5-Sonnet、GPT-4o 等闭源模型性能持平。<br> R1：专注于数学、代码、自然语言推理任务，性能对标 OpenAI o1 正式版，部分测试（如AIME 得分率 79.8% vs. o1 的 79.2% ）实现超越。API 调用成本仅为 OpenAI o1 的3.7%（输出 Token 每百万 16元），训练总成本约 550 万美元，算力需求显著低于同类模型<br> Janus-Pro：作为 DeepSeek 首款开源多模态模型，Janus-Pro 支持视觉、语言等多模态输入输出，填补此前 V3 模型仅限文本交互的局限。</p></blockquote><p>我是 DeepSeek 的早期用户，开始使用时，只有网页版，非常简陋，还没有历史记录，但回答问题的效果不错，特别是编程相关。给我的感觉是认真在做模型，在应用层面不太重视。即便是到现在，依然没有花哨的应用层功能，硬是靠强大的模型能力和创新火出圈了。</p><p>DeepSeek R1 的技术报告地址如下：</p><p><a href="https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf">https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf</a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="网页端"><a href="#网页端" class="headerlink" title="网页端"></a>网页端</h3><p>浏览器访问这个地址：<a href="https://chat.deepseek.com/">https://chat.deepseek.com/</a> ，手机号或者微信注册，登录后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071551961.webp"></p><p>深度思考后面括号里写的是 R1，说明使用的是 R1 模型，深度思考和联网搜索可以同时勾选，比如我让评价射雕的电影，可以看到 DeepSeek 先搜索网页，再进行深度思考，思考过程也会显示在页面中：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071552247.webp"></p><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p>DeepSeek 最近推出了移动端，网页版的左下角有下载二维码。抛开最近的稳定性不谈，可以免费在电脑和手机上使用 R1 模型，已经非常良心了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071552601.webp"></p><h3 id="本机部署"><a href="#本机部署" class="headerlink" title="本机部署"></a>本机部署</h3><p>可以使用 ollama 在本机进行 DeepSeek R1 模型的部署。</p><p>在 ollama 的网站上可以搜索到 DeepSeek R1 模型：<a href="https://ollama.com/search?q=DeepSeek">https://ollama.com/search?q=DeepSeek</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071553848.webp"></p><p>可以看到从 1.5b 到 671b 的都有。下面使用 <code>ollama run deepseek-r1:7b</code> 来运行 7b 的模型，使用 run 命令时如果本地没有这个模型会先自动进行下载。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071553258.webp"></p><p>虽然 7b 的模型知识储备还有点弱，但 R1 的思考能力已经具备了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071553750.webp"></p><h3 id="调用-API"><a href="#调用-API" class="headerlink" title="调用 API"></a>调用 API</h3><p>1、在 DeepSeek 官网（<a href="https://www.deepseek.com/%EF%BC%89%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E3%80%8CAPI">https://www.deepseek.com/）点击右上角的「API</a> 开放平台」：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071554630.webp"></p><p>2、登录后在左侧菜单「API Keys」中创建一个新的 key：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071555454.webp"></p><p>现在已经暂停了 API 服务的充值。</p><p>3、开始写代码调用 API，下面代码是将 DeepSeek 的文档地址 (<a href="https://api-docs.deepseek.com/zh-cn/">https://api-docs.deepseek.com/zh-cn/</a>) 给 Windsurf，让 Windsurf 完成的，Windsurf 最近版本更新的很快，已经集成了 DeepSeek R1 模型。</p><p>deepseek_client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeepSeekClient</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.client = OpenAI(</span><br><span class="line">            api_key=<span class="string">&#x27;sk-7d2fac93b6ee498ca5546f1ad59244fa&#x27;</span>,</span><br><span class="line">            base_url=<span class="string">&#x27;https://api.deepseek.com&#x27;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">chat_completion</span>(<span class="params">self, messages, model=<span class="string">&quot;deepseek-reasoner&quot;</span>, stream=<span class="literal">False</span></span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.client.chat.completions.create(</span><br><span class="line">            model=model,</span><br><span class="line">            messages=messages,</span><br><span class="line">            stream=stream</span><br><span class="line">        )</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>webapi.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, jsonify</span><br><span class="line"><span class="keyword">from</span> deepseek_client <span class="keyword">import</span> DeepSeekClient</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">client = DeepSeekClient()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/chat&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chat_endpoint</span>():</span></span><br><span class="line">    data = request.json</span><br><span class="line">    completion = client.chat_completion(</span><br><span class="line">        messages=data.get(<span class="string">&#x27;messages&#x27;</span>, []),</span><br><span class="line">        model=data.get(<span class="string">&#x27;model&#x27;</span>, <span class="string">&#x27;deepseek-reasoner&#x27;</span>),</span><br><span class="line">        stream=data.get(<span class="string">&#x27;stream&#x27;</span>, <span class="literal">False</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;response&#x27;</span>: completion.choices[<span class="number">0</span>].message.content&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pyproject.toml</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">&quot;^3.10&quot;</span></span><br><span class="line"><span class="attr">openai</span> = <span class="string">&quot;^1.12.0&quot;</span></span><br><span class="line"><span class="attr">flask</span> = <span class="string">&quot;^2.0.3&quot;</span></span><br></pre></td></tr></table></figure><p>4、在项目的根目录下执行下面命令启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">poetry install</span><br><span class="line">poetry run flask --app webapi run --debug </span><br></pre></td></tr></table></figure><p>5、在 postman 中调用的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071559285.webp"></p><p>因为我没有充值，提示余额不足，说明调用 DeepSeek API 是成功的。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>R1 模型虽然强悍，但随着春节期间的火爆，使用人数的突增（攻击），现在变得不太稳定，经常会出现“服务器繁忙，请稍后再试。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071600050.webp"></p><p>这种频繁的稍后重试体验非常不好，我们也可以采取一些其他措施：</p><p>1、kimi 也发布了 k1.5 长思考，可以和联网搜索一起使用。</p><p>2、秘塔 AI 搜索可以开启长思考-R1,这个 R1 就是采用 Deepseek R1 深度推理模型进行回答。</p><p>3、使用 ollama 自己部署，跟满血 R1 相比肯定有差距，而且也不能联网。</p><p>4、使用 chatbox 调用硅基流动的 R1 API 接口，硅基流动自己部署的 R1 模型，这个方案现在应该知道的人比较多，刚看到 R1 模型的介绍里添加了：2025 年 2 月 6 日起，未实名用户每日最多请求此模型 100 次。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202502071559589.webp"></p><p>5、在 Windsurf 中使用 DeepSeek 的 R1 模型。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;春节期间，DeepSeek 掀起了一股热潮，成为了科技领域的热门话题。身边很多非圈内人士茶余饭后也在讨论 DeepSeek，足以见得其火爆程度。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
    <category term="DeepSeek" scheme="http://fwhyy.com/tags/deepseek/"/>
    
  </entry>
  
  <entry>
    <title>2024 年终总结</title>
    <link href="http://fwhyy.com/2025/01/2024-yearend-summary/"/>
    <id>http://fwhyy.com/2025/01/2024-yearend-summary/</id>
    <published>2025-01-31T08:30:00.000Z</published>
    <updated>2025-02-12T08:31:07.697Z</updated>
    
    <content type="html"><![CDATA[<p>律转鸿钧，新元肇启。2024 已然过去，这一年有很多的变化，特别是 AI 的发展迅猛，变化是好事，意味着有会带来更多的机遇，关键是我们需要时刻做好准备才能抓住。</p><span id="more"></span><p>下面还是按照我的习惯方式给 2024 年做下总结。</p><h2 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h2><p>在这个 AI 飞速发展的时代，各种工具层出不穷，按说效率应该更高更快，但我并没有觉得变得轻松了，反倒是更累。因为我们接收的信息需要消化才能转化为自己的知识，而在 AI 时代，同等时间接收的东西更多了，需要消化的就更多了，如果消化能力没有提升，就会很累。</p><p>还发现了一个现象，现在很难沉下心来进行长文的阅读，阅读长文需要「慢」下来才行，在 AI 这个「快」的时代，慢下来很难，但也可能会收获更多。</p><p>信息的处理工具很多还在探索中，这个探索是没有期限的，但总的来说有四个方面：</p><ul><li>信息源：Follow、公众号、得到、小报童、读库</li><li>输入：flomo、get笔记</li><li>消化：暂无</li><li>输出：obsidian</li></ul><p>所以 2025 年，我的关键词是：慢、消化。</p><h2 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h2><p>2024 年立下的 Flag 基本达成：</p><ul><li>跑量 2000+</li><li>全马突破 330</li><li>跑一次 70 公里的越野（目标赛事：崇礼 168）</li></ul><p>2024 年总跑量 3000 整，虽然这个数字是凑出来的（最后几公里），但也体现了坚持的成果。11 月 17 日的光谷马拉松官方成绩是 3 小时 30 分 51 秒，算是勉强达成了目标。7 月去崇礼跑了 MTC 组别（70 公里），安全完赛，这是一个重要的突破。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501311215712.webp"></p><p>2024 年的跑步历程：</p><ul><li>3 月，PB 计划的训练结束，参加了石家庄马拉松，全马 PB 了 80 分钟</li><li>7 月，挑战 70 公里越野</li><li>11 月，全马又有小的进步</li></ul><p>整个 24 年一直没有停下脚步，也取得了一些成绩。非常感谢跑者日历四群的陪伴。</p><p>25 年，已经确定的比赛有 4 月份的云丘山越野，其他就看缘分了。比赛不是关键，关键是能一直健康跑下去。</p><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>24 年的国庆长假依旧选择了自驾出行，不过这次多了些不一样的体验。以前的老同事一家和我们一起同行，女儿也多了一个玩伴，使整个旅途充满了更多的乐趣。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501311215832.webp"></p><p>行程从武汉出发，途经池州、宣城、泾县、徽州、安庆，最后回到武汉。值得一提的是，出行的这些天，每天都坚持跑步，将运动和旅行完美结合。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501311216148.webp"></p><h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>因为始终坚持「为自己而写」的理念，今年的更新比较随性，一共只发布了 38 篇文章。</p><p>今年公众号的信息流策略发生了变化，推荐带来的阅读占比越来越大。比如最近写的《信创浪潮下的.NET困境与技术转型思考》就因为推荐获得了 6000 多的阅读量。</p><p>这个改变带来了几个影响：</p><ul><li>即便是晚上或凌晨发布文章，也不会被淹没</li><li>对大众有共鸣的选题或热点事件选题，更容易带来更高的阅读量</li><li>标题显得更重要了，当然内容更重要</li></ul><p>2025 年还会继续写作，可能更多、也可能更少，保持随性就好。</p><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年在公众号输出了三本书的读后感：《笔记的方法》、《强风吹拂》、《华为项目管理之道》。但实际的阅读量远不止这些，在得到电子书看了不少书籍，还有读库、follow 上的订阅和大量的公众号文章。</p><p>25 年想多看看「闲」书，避免自己掉进信息茧房。有时候，跳出专业领域的阅读，反而能带来意想不到的收获。</p><h2 id="播客"><a href="#播客" class="headerlink" title="播客"></a>播客</h2><p>Follow 中虽然可以订阅小宇宙的播客，但因为不能登录，无法记录播放时长和评论，所以使用频率不高，主要是看看 shownotes。所以播客主要还是在上下班途中和跑步时听。</p><p>除了跑步相关的播客，今年听了很多商业和 AI 相关的节目：</p><ul><li>《乱翻书》</li><li>《张小珺商业访谈录》</li><li>《硬地骇客》</li><li>《晚点聊 LateTalk》</li><li>《42 章经》</li><li>《十字路口》</li></ul><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>2024 年，部门在稳定支撑项目实施的基础上，完成了 13 个大版本的迭代，这是一个令人满意的成果。</p><p>展望 2025 年，有两个重要的变化需要应对：</p><ul><li>技术栈的调整将带来更大的挑战</li><li>部门的独立核算既是挑战也是机遇</li></ul><p>欣慰的是，我和团队的小伙伴们都已经做好了准备，相信能够在新的一年里继续保持进步。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;律转鸿钧，新元肇启。2024 已然过去，这一年有很多的变化，特别是 AI 的发展迅猛，变化是好事，意味着有会带来更多的机遇，关键是我们需要时刻做好准备才能抓住。&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="总结" scheme="http://fwhyy.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>为什么单线程的Redis也能如此高效？</title>
    <link href="http://fwhyy.com/2025/01/why-can-single-threaded-redis-be-so-efficient/"/>
    <id>http://fwhyy.com/2025/01/why-can-single-threaded-redis-be-so-efficient/</id>
    <published>2025-01-17T12:29:00.000Z</published>
    <updated>2025-02-12T08:30:04.120Z</updated>
    
    <content type="html"><![CDATA[<p>提起 Redis，一个印象就是速度很快的开源内存数据库，而且还是单线程的。</p><span id="more"></span><p>但印象有时会骗人：</p><p>1、redis 6.0 后采用了多线程</p><p>2、redis 7.4 之后修改了开源协议</p><h2 id="单线程为什么速度还很快？"><a href="#单线程为什么速度还很快？" class="headerlink" title="单线程为什么速度还很快？"></a>单线程为什么速度还很快？</h2><p>1、Redis 的客户端调用服务器经过三个过程：发送命令、执行命令和返回结果。在命令执行阶段，由于 Redis 处理命令是单线程的，在服务器上到达的所有命令不会立即被执行。所有命令都进入队列并按顺序执行。多个客户端发送的命令执行顺序不确定。但是可以确定的是两个命令不会同时执行，避免了并发问题。这是 Redis 的基本单线程模型。</p><p>2、Redis 完全基于内存，数据存储在内存中。大多数请求都是纯内存操作，所以速度非常快。与传统的磁盘文件数据存储相比，Redis 避免了通过磁盘 I/O 读取数据到内存的开销。</p><p>3、使用单线程可以节省很多上下文切换和 CPU 消耗的时间，没有竞争条件，不需要考虑各种锁定问题，并且不会因为死锁而导致性能开销。此外，它还允许使用各种「线程不安全」的命令，例如 Lpush。</p><p>4、需要注意的是，当我们强调单线程时，我们指的是使用一个线程来处理网络 I/O 和键值对读写。换句话说，一个线程处理所有网络请求。但 Redis 的其他功能，如持久性、异步删除和集群数据同步，实际上是由额外的线程执行。也就是说即便是在 6.0 之前的版本，也不是绝对的单线程。</p><p>5、Redis 虽然是纯内存操作，但仍然会涉及到网络 I/O 和磁盘 I/O（持久化操作），Redis 使用非阻塞 I/O 和 I/O 多路复用技术（如 <code>select</code>、<code>poll</code>、<code>epoll</code>）来处理大量的并发连接。这意味着一个线程可以同时监听多个客户端的连接请求，并在有数据可读或可写时进行处理。这种方式避免了线程在等待 I/O 操作完成时的阻塞，从而提高了系统的并发处理能力。</p><ul><li>非阻塞 I/O：允许程序在 I/O 操作未完成时继续执行其他任务。</li><li>I/O 多路复用：通过单线程监控多个 I/O 操作，提升高并发下的效率。</li></ul><p>6、官方对单线程的解释是：因为 CPU 不是 Redis 的瓶颈，最有可能的是机器内存或网络带宽。由于单线程易于实现，并且 CPU 不会成为瓶颈，采用单线程解决方案是有意义的。</p><h2 id="为什么-6-0-又采用了多线程？"><a href="#为什么-6-0-又采用了多线程？" class="headerlink" title="为什么 6.0 又采用了多线程？"></a>为什么 6.0 又采用了多线程？</h2><p>Redis 在 6.0 版本引入多线程支持，主要是为了应对现代硬件架构的变化和日益复杂的业务需求，同时解决单线程模型在高并发场景下的性能瓶颈。</p><h3 id="1、提升网络-I-O-性能"><a href="#1、提升网络-I-O-性能" class="headerlink" title="1、提升网络 I/O 性能"></a>1、提升网络 I/O 性能</h3><p>Redis 的主要性能瓶颈在于网络 I/O，尤其是在高并发场景下，单线程模型难以高效处理大量的网络请求。虽然 Redis 使用了 I/O 多路复用技术（如 <code>epoll</code>）来优化网络处理，但随着硬件性能的提升，单线程的网络 I/O 处理能力逐渐成为瓶颈。</p><p>通过引入多线程，Redis 可以将网络 I/O 操作（如读取客户端请求和写回响应）分配到多个线程并行处理，从而显著提升网络吞吐量和降低延迟。</p><h3 id="2、利用多核-CPU"><a href="#2、利用多核-CPU" class="headerlink" title="2、利用多核 CPU"></a>2、利用多核 CPU</h3><p>现在的服务器普遍配备多核 CPU，而 Redis 的单线程模型只能利用一个 CPU 核心，无法充分发挥硬件的性能潜力。通过引入多线程，Redis 可以将网络 I/O 任务分配到多个线程，充分利用多核 CPU 的计算能力，从而提高整体性能。</p><h3 id="3、保持核心逻辑的简单性和一致性"><a href="#3、保持核心逻辑的简单性和一致性" class="headerlink" title="3、保持核心逻辑的简单性和一致性"></a>3、保持核心逻辑的简单性和一致性</h3><p>Redis 6.0 的多线程模型采用了混合设计：网络 I/O 操作由多个线程并行处理，而命令执行仍然由单线程顺序执行。这种设计既保留了单线程模型的简单性和一致性优势（如避免线程安全问题、保证命令的原子性），又通过多线程提升了网络 I/O 的性能。和之前的版本相比，只是将更多的事情由多线程来处理。</p><h3 id="4、优化资源利用"><a href="#4、优化资源利用" class="headerlink" title="4、优化资源利用"></a>4、优化资源利用</h3><p>在高负载场景下，单线程模型可能导致 CPU 和内存资源的浪费。通过引入多线程，Redis 可以更高效地利用系统资源，减少请求的等待时间，从而提升整体性能。</p><h3 id="5、如何在-Redis-6-0-中启用多线程？"><a href="#5、如何在-Redis-6-0-中启用多线程？" class="headerlink" title="5、如何在 Redis 6.0 中启用多线程？"></a>5、如何在 Redis 6.0 中启用多线程？</h3><p>默认情况下，Redis 的多线程是禁用的，如果要启用多线程功能，需要修改 Redis 的配置文件,涉及到两个配置项：</p><p>io-threads：</p><ul><li>该选项用于设置 I/O 线程的数量</li><li>默认值为 <code>1</code>，即不启用多线程</li><li>如果设置为大于 <code>1</code> 的值，Redis 会启用多线程来处理网络 I/O</li><li>建议将 <code>io-threads</code> 设置为小于 CPU 核心数的值，通常为 CPU 核心数的 1/2 到 2/3。</li></ul><p>io-threads-do-reads：</p><ul><li>该选项用于控制是否启用多线程处理读操作</li><li>默认值为 <code>no</code>，即不启用多线程读操作</li><li>如果需要启用多线程读操作，可以将其设置为 <code>yes</code></li></ul><p>配置示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启用多线程，设置 I/O 线程数为 4</span><br><span class="line">io-threads 4</span><br><span class="line"></span><br><span class="line"># 启用多线程处理读操作</span><br><span class="line">io-threads-do-reads yes</span><br></pre></td></tr></table></figure><h2 id="修改了开源协议，有什么替代方案"><a href="#修改了开源协议，有什么替代方案" class="headerlink" title="修改了开源协议，有什么替代方案"></a>修改了开源协议，有什么替代方案</h2><p>Redis 从 7.4 版本开始修改了开源协议，从 BSD 变更为 RSALv2 和 SSPLv1 双重许可，这意味着 Redis 在 OSI（开放源代码促进会）定义下不再被视为严格的开源软件。</p><p>这一变更对云服务商和开发者产生了较大影响，尤其是那些依赖 Redis 提供商业服务的厂商。</p><p>可以使用 Valkey 进行代替，Valkey 由 Linux 基金会支持，采用 BSD 许可证，确保了项目的开源性质。自 2024 年 3 月由 Redis 项目的贡献者和 Linux 基金会联合发起以来，Valkey 已经得到了包括亚马逊云科技在内的 40 多家公司的支持和贡献。</p><p>我现在在研究的 RAGFlow 使用的就是 Valkey 。下面是 RAGFlow 中部署 Valkey 的 docker-compose 部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis:</span><br><span class="line">  image: valkey/valkey:8</span><br><span class="line">  container_name: ragflow-redis</span><br><span class="line">  command: redis-server --requirepass $&#123;REDIS_PASSWORD&#125; --maxmemory 128mb --maxmemory-policy allkeys-lru</span><br><span class="line">  env_file: .env</span><br><span class="line">  ports:</span><br><span class="line">    - $&#123;REDIS_PORT&#125;:6379</span><br><span class="line">  volumes:</span><br><span class="line">    - redis_data:/data</span><br><span class="line">  networks:</span><br><span class="line">    - ragflow</span><br><span class="line">  restart: on-failure</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;提起 Redis，一个印象就是速度很快的开源内存数据库，而且还是单线程的。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="http://fwhyy.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>从环境搭建到项目运行：Python 和 Flask 快速上手指南</title>
    <link href="http://fwhyy.com/2025/01/from-environment-setup-to-project-execution-a-quick-guide-to-getting-started-with-python-and-flask/"/>
    <id>http://fwhyy.com/2025/01/from-environment-setup-to-project-execution-a-quick-guide-to-getting-started-with-python-and-flask/</id>
    <published>2025-01-07T12:27:00.000Z</published>
    <updated>2025-02-12T08:28:39.834Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究 RAG，免不了会使用到 Python，本文简单介绍下 Python 从环境的搭建到运行一个简单的 Web 项目。</p><span id="more"></span><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>操作系统：Mac 13.0</li><li>Python：3.11.7</li><li>包管理：poetry1.8.3</li><li>Web 框架：Flask3.1</li></ul><p>Python 中的包管理工具有 conda、pip、poetry、PyPI 等，Web 框架也有 Django、Flask、FastAPI ，为什么选择的是 poetry 和 Flask 呢？</p><p>因为现在研究的 RAGFlow 的源码中使用的就是 poetry 和 Flask 。带着目的去学习效率会高很多。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-、安装-Python"><a href="#1-、安装-Python" class="headerlink" title="1 、安装 Python"></a>1 、安装 Python</h3><p>直接在官网下载安装就可以：<a href="https://www.python.org/downloads/%EF%BC%8C%E6%88%91%E5%BE%88%E6%97%A9%E5%89%8D%E5%B0%B1%E5%AE%89%E8%A3%85%E4%BA%86%EF%BC%8C%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E5%8D%87%E7%BA%A7%EF%BC%8C%E6%89%80%E4%BB%A5%E7%89%88%E6%9C%AC%E8%BF%98%E6%98%AF">https://www.python.org/downloads/，我很早前就安装了，一直没有升级，所以版本还是</a> 3.11.7 。</p><h3 id="2-、安装-poetry"><a href="#2-、安装-poetry" class="headerlink" title="2 、安装 poetry"></a>2 、安装 poetry</h3><p>如果你了解过 Python，一定知道 pip，但 pip 在包的依赖管理和版本冲突管理上做的不是很好，而 poetry 就是为了解决这两个问题而生。</p><p>我在本机是使用 pipx 来安装的 poetry ，先使用 homebrew 安装 pipx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install pipx</span><br><span class="line">pipx ensurepath</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images@master/img/202501061750427.webp"></p><p>接着使用 pipx 安装 poetry，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx 安装 poetry </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061805738.webp"></p><p>安装完成后，可以通过以下命令验证 poetry 是否安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry --version</span><br></pre></td></tr></table></figure><p>出现下图所示，说明安装成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061805772.webp"></p><h3 id="3-、使用-poetry"><a href="#3-、使用-poetry" class="headerlink" title="3 、使用 poetry"></a>3 、使用 poetry</h3><p>可以使用 poetry 创建一个新的项目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry new poetry-project</span><br></pre></td></tr></table></figure><p>也可以在现有项目的目录中初始化 poetry：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd exist-project</span><br><span class="line">poetry init</span><br></pre></td></tr></table></figure><p>使用 poetry 创建的项目目录如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061805758.webp"></p><p>在 pyproject.toml 文件中进行包版本的管理。这时如果我要给项目添加相关的依赖包，有两种方式：</p><p>直接使用 poetry 命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add six:1.16.0            </span><br></pre></td></tr></table></figure><p>使用命令安装完成后，pyproject.toml 文件中会自动添加 six = “1.16.0” ，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061805053.webp"></p><p>另一种方式就是先修改配置，在 pyproject.toml 中添加 six = “1.16.0” 或其他的包，然后执行下面命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry install</span><br></pre></td></tr></table></figure><p><strong>在使用 poetry 之前，先使用下面命令设置虚拟环境在项目内：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry config virtualenvs.in-project true</span><br></pre></td></tr></table></figure><p>经过上面的设置后，不管是使用 <code>poetry install</code> 还是使用 <code>poetry add </code> 添加的包，会在项目根目录下的 .venv 目录中，便于管理：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061805840.webp"></p><h3 id="4-、安装-flask"><a href="#4-、安装-flask" class="headerlink" title="4 、安装 flask"></a>4 、安装 flask</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry add flask</span><br></pre></td></tr></table></figure><p>上面命令会将 Flask 添加到 <code>pyproject.toml</code> 并安装到虚拟环境中。</p><h2 id="使用-flask"><a href="#使用-flask" class="headerlink" title="使用 flask"></a>使用 flask</h2><p>使用 poetry 初始化一个项目并添加 flask 后，项目的目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061805118.webp"></p><p>可以看到到多了 <code>__init__.py</code> 和 <code>poetry.lock</code> 两个文件：</p><ul><li><code>__init__.py</code>：可以将这个文件所在目录标记为一个 Python 包，使得这个目录可以被当作模块导入。</li><li><code>poetry.lock</code>：锁定项目所有依赖包的具体版本，确保项目在不同环境中使用完全相同的依赖版本，记录了每个包的详细信息，包括其哈希值、依赖关系等。</li></ul><p>在上面的基础上，我们让 windsurf 来完成一个示例程序，在 windsurf 中输入：按照flask的最佳实践，创建 get 和 post 的接口示例，创建的目录结构如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061806816.webp"></p><p>从上往下来看看每个文件的内容：</p><h3 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Flask 应用工厂模块&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> .config <span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_app</span>(<span class="params">config_name=<span class="string">&#x27;default&#x27;</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    创建 Flask 应用实例</span></span><br><span class="line"><span class="string">    :param config_name: 配置名称，可选值：development, production, default</span></span><br><span class="line"><span class="string">    :return: Flask 应用实例</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建应用实例</span></span><br><span class="line">    app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载配置</span></span><br><span class="line">    app.config.from_object(config[config_name])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注册蓝图</span></span><br><span class="line">    <span class="keyword">from</span> .api <span class="keyword">import</span> api_bp</span><br><span class="line">    app.register_blueprint(api_bp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加一个测试路由</span></span><br><span class="line"><span class="meta">    @app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Welcome to Flask API&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><h3 id="config-py"><a href="#config-py" class="headerlink" title="config.py"></a>config.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;Flask 应用配置文件&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;基础配置类&quot;&quot;&quot;</span></span><br><span class="line">    SECRET_KEY = <span class="string">&#x27;dev-key&#x27;</span>  <span class="comment"># 开发环境密钥</span></span><br><span class="line">    JSON_AS_ASCII = <span class="literal">False</span>   <span class="comment"># 支持中文返回</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevelopmentConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;开发环境配置&quot;&quot;&quot;</span></span><br><span class="line">    DEBUG = <span class="literal">True</span></span><br><span class="line">    ENV = <span class="string">&#x27;development&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductionConfig</span>(<span class="params">Config</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生产环境配置&quot;&quot;&quot;</span></span><br><span class="line">    DEBUG = <span class="literal">False</span></span><br><span class="line">    ENV = <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    SECRET_KEY = <span class="string">&#x27;your-production-secret-key&#x27;</span>  <span class="comment"># 生产环境应使用强密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置映射</span></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&#x27;development&#x27;</span>: DevelopmentConfig,</span><br><span class="line">    <span class="string">&#x27;production&#x27;</span>: ProductionConfig,</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: DevelopmentConfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="api-init-py"><a href="#api-init-py" class="headerlink" title="api__init__.py"></a>api__init__.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 API 蓝图</span></span><br><span class="line">api_bp = Blueprint(<span class="string">&#x27;api&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/api&#x27;</span>)</span><br><span class="line"><span class="comment"># 导入视图函数</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views <span class="comment"># 这行很重要，确保视图函数被注册到蓝图</span></span><br></pre></td></tr></table></figure><h3 id="api-views-py"><a href="#api-views-py" class="headerlink" title="api_views.py"></a>api_views.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;API 视图函数&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify, request</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> api_bp</span><br><span class="line"></span><br><span class="line"><span class="meta">@api_bp.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;GET 请求示例&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">        <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Hello, World!&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;data&#x27;</span>: <span class="literal">None</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@api_bp.route(<span class="params"><span class="string">&#x27;/echo&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;POST 请求示例&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 获取 JSON 数据</span></span><br><span class="line">        data = request.get_json()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">                <span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>,</span><br><span class="line">                <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;No JSON data provided&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;data&#x27;</span>: <span class="literal">None</span></span><br><span class="line">            &#125;), <span class="number">400</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回接收到的数据</span></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;Data received successfully&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: data</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;</span><br><span class="line">            <span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">&#x27;message&#x27;</span>: <span class="built_in">str</span>(e),</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: <span class="literal">None</span></span><br><span class="line">        &#125;), <span class="number">500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="run-py"><a href="#run-py" class="headerlink" title="run.py"></a>run.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;应用启动入口&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> poetry_project <span class="keyword">import</span> create_app</span><br><span class="line"></span><br><span class="line">app = create_app(<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">5005</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在项目更目录下执行下面命令运行和测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">poetry run python run.py</span><br><span class="line"></span><br><span class="line">curl http://localhost:5005/api/hello</span><br><span class="line">curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;message&quot;:&quot;test&quot;&#125;&#x27; http://localhost:5005/api/echo</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>到这里，一个简单的例子就跑起来了。</p><p>但例子中有些地方看不明白，直接在 windsurf 中去问就可以了，比如 api 目录中的 <code>__init__.py</code> 文件中有这样一行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api_bp = Blueprint(<span class="string">&#x27;api&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/api&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501061806824.webp"></p><p>了解了一个简单的 Flask 项目结构，也知道怎么去抽丝剥茧搞清楚不懂的问题。我们就可以去阅读 RAGFlow 的源码了。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1、升级-Poetry"><a href="#1、升级-Poetry" class="headerlink" title="1、升级 Poetry"></a>1、升级 Poetry</h3><p>如果需要升级 <code>Poetry</code>，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx upgrade poetry</span><br></pre></td></tr></table></figure><h3 id="2、卸载-Poetry"><a href="#2、卸载-Poetry" class="headerlink" title="2、卸载 Poetry"></a>2、卸载 Poetry</h3><p>如果不再需要 <code>Poetry</code>，可以通过以下命令卸载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipx uninstall poetry</span><br></pre></td></tr></table></figure><h3 id="3、创建虚拟环境"><a href="#3、创建虚拟环境" class="headerlink" title="3、创建虚拟环境"></a>3、创建虚拟环境</h3><p>Poetry 默认会在你安装依赖时自动创建虚拟环境。如果你想手动创建虚拟环境，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env use python</span><br></pre></td></tr></table></figure><p>这会使用系统默认的 Python 版本创建虚拟环境。如果你想指定 Python 版本，可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env use python3.9</span><br></pre></td></tr></table></figure><h3 id="4、查看虚拟环境信息"><a href="#4、查看虚拟环境信息" class="headerlink" title="4、查看虚拟环境信息"></a>4、查看虚拟环境信息</h3><p>创建虚拟环境后，可以通过以下命令查看虚拟环境的路径和信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env info</span><br></pre></td></tr></table></figure><h3 id="5、激活虚拟环境"><a href="#5、激活虚拟环境" class="headerlink" title="5、激活虚拟环境"></a>5、激活虚拟环境</h3><p>如果你想手动激活虚拟环境，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry shell</span><br></pre></td></tr></table></figure><p>这会启动一个新的 shell 并激活虚拟环境。激活后，你可以直接运行 Python 脚本或命令。</p><h3 id="6、删除虚拟环境"><a href="#6、删除虚拟环境" class="headerlink" title="6、删除虚拟环境"></a>6、删除虚拟环境</h3><p>如果你想删除虚拟环境，可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poetry env remove python</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在研究 RAG，免不了会使用到 Python，本文简单介绍下 Python 从环境的搭建到运行一个简单的 Web 项目。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Python" scheme="http://fwhyy.com/tags/python/"/>
    
    <category term="Flask" scheme="http://fwhyy.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 和 RabbitMQ 的比较以及 RocketMQ 的使用</title>
    <link href="http://fwhyy.com/2025/01/comparison-between-rocketmq-and-rabbitmq-and-the-use-of-rocketmq/"/>
    <id>http://fwhyy.com/2025/01/comparison-between-rocketmq-and-rabbitmq-and-the-use-of-rocketmq/</id>
    <published>2025-01-02T10:28:00.000Z</published>
    <updated>2025-02-12T08:27:33.312Z</updated>
    
    <content type="html"><![CDATA[<p>消息队列在项目中会经常用到，目前我们使用的是 RabbitMQ，但在 Java 技术栈下，RocketMQ 使用的比较多。下面比较下 RabbitMQ 和 RocketMQ。</p><span id="more"></span><h2 id="RabbitMQ-和-RocketMQ-对比"><a href="#RabbitMQ-和-RocketMQ-对比" class="headerlink" title="RabbitMQ 和 RocketMQ 对比"></a>RabbitMQ 和 RocketMQ 对比</h2><h3 id="1、设计理念和架构"><a href="#1、设计理念和架构" class="headerlink" title="1、设计理念和架构"></a>1、设计理念和架构</h3><p>RabbitMQ： </p><p>基于 AMQP（Advanced Message Queuing Protocol）协议，使用 Erlang 语言开发。Erlang 的天生高并发和容错性使得 RabbitMQ 在稳定性方面表现出色。RabbitMQ 的核心概念是 Exchange（交换机）和 Queue（队列），消息通过 Exchange 路由到 Queue，再由消费者消费。这种模型非常灵活，支持多种消息路由模式。</p><p>RocketMQ：</p><p>源于阿里巴巴，后捐献给 Apache 基金会，所以现在的官网是：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a> 。使用 Java 语言开发，更贴近 Java 技术栈。RocketMQ 的核心概念是 Topic（主题），消息发送到 Topic，消费者订阅 Topic 进行消费。RocketMQ 的设计目标是高吞吐量、低延迟和高可靠性，适合大规模分布式系统。</p><p>RocketMQ 的设计理念更偏向于解决互联网场景下的具体问题，如海量消息处理、消息顺序性等。</p><h3 id="2、性能"><a href="#2、性能" class="headerlink" title="2、性能"></a>2、性能</h3><p>吞吐量：RocketMQ 在吞吐量方面通常优于 RabbitMQ，尤其是在高并发场景下。RocketMQ 的设计更偏向于高吞吐的消息传递，而 RabbitMQ 更注重消息的可靠性和灵活性。</p><p>延迟：两者在延迟方面都表现不错，但在极端高负载情况下，RocketMQ 的延迟可能更低一些。</p><p>不过在 ToB 的一些业务场景，RabbitMQ 是可以胜任的。</p><h3 id="3、特性"><a href="#3、特性" class="headerlink" title="3、特性"></a>3、特性</h3><p>消息路由：RabbitMQ 支持多种 Exchange 类型（Direct、Topic、Fanout、Headers），提供更丰富的消息路由策略。RocketMQ 主要使用 Topic 进行消息路由，相对简单。</p><p>消息过滤：RocketMQ 支持基于 Tag 和 SQL 的消息过滤，方便消费者按需订阅消息。RabbitMQ 的消息过滤相对较弱。</p><p>事务消息：RocketMQ 提供了分布式事务消息的支持，可以保证消息生产和本地事务的原子性。RabbitMQ 没有直接提供事务消息的支持，需要通过其他方式实现。</p><p>延迟消息：RocketMQ 支持延迟消息，可以实现定时任务等功能。RabbitMQ 通过插件可以实现类似功能。</p><p>监控和管理：RocketMQ 和 RabbitMQ 都提供了丰富的监控指标和管理工具，相比之下我更喜欢 RocketMQ 的管理工具。</p><h3 id="4、创新点"><a href="#4、创新点" class="headerlink" title="4、创新点"></a>4、创新点</h3><p>RabbitMQ:</p><ul><li>插件系统设计灵活，易于扩展</li><li>虚拟主机（vhost）概念，实现多租户隔离</li><li>内存和磁盘节点的混合部署方案</li></ul><p>RocketMQ:</p><ul><li>基于文件的消息存储系统，避免了缓存未刷盘导致的消息丢失</li><li>Pull 模式和长轮询机制的结合，平衡了实时性和性能</li><li>消息过滤支持在 Broker 端完成，减少网络传输开销</li></ul><h3 id="5、Exchange-和-Topic-的区别"><a href="#5、Exchange-和-Topic-的区别" class="headerlink" title="5、Exchange 和 Topic 的区别"></a>5、Exchange 和 Topic 的区别</h3><p>RabbitMQ的 Exchange 和 RocketMQ 的 Topic 在消息路由机制上有以下主要区别：</p><p>概念和角色</p><p>RabbitMQ Exchange 是一个路由组件，负责接收生产者发送的消息并将其路由到一个或多个队列，作为消息的”交换机”，它不存储消息，只负责消息的路由转发，需要通过 binding key 与 Queue 建立绑定关系。</p><p>RocketMQ Topic 是消息的逻辑分类，直接作为消息的存储和投递单元，包含多个消息队列（MessageQueue），用于存储消息，消费者直接订阅 Topic 即可接收消息。</p><p>RabbitMQ 的 key 绑定和 Exchange、队列的关系，一开始不太容易理解，相比之下 RocketMQ 的 Topic 和队列关系更清晰。</p><p>路由方式</p><p>RabbitMQ Exchange 支持四种路由策略，路由更加灵活，可以实现复杂的消息分发模式</p><ul><li>Direct：根据routing key精确匹配</li><li>Topic：根据routing key的模式匹配</li><li>Fanout：广播到所有绑定的队列</li><li>Headers：根据消息属性匹配</li></ul><p>RocketMQ Topic 采用发布/订阅模式，更加简单直接，通过Tag机制实现消息过滤。支持消息队列的负载均衡。</p><p>消息存储</p><p>RabbitMQ Exchange 不存储消息，消息存储在 Queue 中，消息一旦被路由到 Queue 就与Exchange 无关。</p><p>RocketMQ Topic 直接存储消息，每个 Topic 包含多个消息队列。消息存储在 CommitLog 中，通过 ConsumeQueue 建立索引。</p><h2 id="Docker-compose-部署-RocketMQ"><a href="#Docker-compose-部署-RocketMQ" class="headerlink" title="Docker-compose 部署 RocketMQ"></a>Docker-compose 部署 RocketMQ</h2><p>同样是使用容器进行部署，RabbitMQ 一个容器搞定，RocketMQ 需要两个容器（NameServer 和 Broker），如果需要 web 管理工具，还需要再单独部署一个容器。</p><p>当进行集群模式部署时，RocketMQ 的下载包中有各种集群模式的示例配置文件，这对新手非常友好。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202501011909246.webp"></p><p>下面是部署 RocketMQ 的 docker-comopose 文件的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义自定义网络</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">rmq_network:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">    <span class="attr">ipam:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># RocketMQ Name Server</span></span><br><span class="line">  <span class="attr">namesrv:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.1.4</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqnamesrv</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">rmq_network:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9876</span><span class="string">:9876</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/namesrv/logs:/home/rocketmq/logs</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqnamesrv</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-server</span> <span class="string">-Xms512m</span> <span class="string">-Xmx512m</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RocketMQ Broker</span></span><br><span class="line">  <span class="attr">broker:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apache/rocketmq:5.3.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqbroker</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">rmq_network:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10909</span><span class="string">:10909</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10911</span><span class="string">:10911</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10912</span><span class="string">:10912</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/broker/logs:/home/rocketmq/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/broker/store:/home/rocketmq/store</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./conf/broker.conf:/home/rocketmq/conf/broker.conf</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">mqbroker</span> <span class="string">-c</span> <span class="string">/home/rocketmq/conf/broker.conf</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPT_EXT=-server</span> <span class="string">-Xms512m</span> <span class="string">-Xmx512m</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># RocketMQ Dashboard </span></span><br><span class="line">  <span class="attr">dashboard:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apacherocketmq/rocketmq-dashboard:1.0.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rmqdashboard</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">rmq_network:</span></span><br><span class="line">        <span class="attr">ipv4_address:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.4</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">19080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>broker.conf 的内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># broker集群名称</span></span><br><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line"><span class="meta"># broker名称</span></span><br><span class="line">brokerName = broker-a</span><br><span class="line"><span class="meta"># broker编号，0表示master，大于0表示slave</span></span><br><span class="line">brokerId = <span class="number">0</span></span><br><span class="line"># 删除过期文件时间点，默认是凌晨<span class="number">4</span>点</span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line"># 文件保留时间，默认<span class="number">48</span>小时</span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line"><span class="meta"># broker角色，ASYNC_MASTER=异步复制Master，SYNC_MASTER=同步双写Master，SLAVE=slave节点</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line"># 刷盘方式，ASYNC_FLUSH=异步刷盘，SYNC_FLUSH=同步刷盘</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"># nameServer地址，分号分割</span><br><span class="line">namesrvAddr = namesrv:<span class="number">9876</span></span><br><span class="line"># 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums = <span class="number">4</span></span><br><span class="line"># 是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable = <span class="literal">true</span></span><br><span class="line"># 是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup = <span class="literal">true</span></span><br><span class="line"># brokerIP1 注意：本地测试使用本机的宿主机的IP</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.1</span><span class="number">.109</span></span><br></pre></td></tr></table></figure><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>对于消息队列，单播、广播、重试，这三种场景用的比较多。下面就看看这三个场景是怎么实现的。</p><p>1、创建生产者 Service 类来处理消息的发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RocketMQ消息主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_UNICAST = <span class="string">&quot;topic-unicast&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_BROADCAST = <span class="string">&quot;topic-broadcast&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_RETRY = <span class="string">&quot;topic-retry&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送单播消息（点对点）</span></span><br><span class="line"><span class="comment">     * 单播消息会被消费组中的某一个消费者消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendUnicastMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">        rocketMQTemplate.convertAndSend(TOPIC_UNICAST, message);</span><br><span class="line">        log.info(<span class="string">&quot;Unicast message sent: &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送广播消息</span></span><br><span class="line"><span class="comment">     * 广播消息会被所有订阅该主题的消费者消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcastMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">        rocketMQTemplate.convertAndSend(TOPIC_BROADCAST, message);</span><br><span class="line">        log.info(<span class="string">&quot;Broadcast message sent: &#123;&#125;&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送需要重试的消息</span></span><br><span class="line"><span class="comment">     * 使用异步发送方式，并在回调中处理发送结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRetryMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">        rocketMQTemplate.asyncSend(TOPIC_RETRY, message, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                log.info(<span class="string">&quot;Retry message sent successfully: &#123;&#125;, result: &#123;&#125;&quot;</span>, message, sendResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;Failed to send retry message: &#123;&#125;, error: &#123;&#125;&quot;</span>, message, throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、创建消费者 Service 类来处理消息的接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RocketMQ消息主题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_UNICAST = <span class="string">&quot;topic-unicast&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_BROADCAST = <span class="string">&quot;topic-broadcast&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOPIC_RETRY = <span class="string">&quot;topic-retry&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单播消息消费者</span></span><br><span class="line"><span class="comment">     * consumeMode默认为CONCURRENTLY（并发消费）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">            topic = TOPIC_UNICAST,</span></span><br><span class="line"><span class="meta">            consumerGroup = &quot;unicast-consumer-group&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnicastMessageListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;Received unicast message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播消息消费者</span></span><br><span class="line"><span class="comment">     * messageModel设置为BROADCASTING表示广播模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">            topic = TOPIC_BROADCAST,</span></span><br><span class="line"><span class="meta">            consumerGroup = &quot;broadcast-consumer-group&quot;,</span></span><br><span class="line"><span class="meta">            messageModel = MessageModel.BROADCASTING</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastMessageListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">            log.info(<span class="string">&quot;Received broadcast message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试消息消费者</span></span><br><span class="line"><span class="comment">     * 配置了重试次数和重试间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="meta">@RocketMQMessageListener(</span></span><br><span class="line"><span class="meta">            topic = TOPIC_RETRY,</span></span><br><span class="line"><span class="meta">            consumerGroup = &quot;retry-consumer-group&quot;,</span></span><br><span class="line"><span class="meta">            maxReconsumeTimes = 3,    // 最大重试次数</span></span><br><span class="line"><span class="meta">            delayLevelWhenNextConsume = 2  // 重试间隔级别</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryMessageListener</span> <span class="keyword">implements</span> <span class="title">RocketMQListener</span>&lt;<span class="title">MessageEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(MessageEvent message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 模拟处理失败的情况</span></span><br><span class="line">                <span class="keyword">if</span> (message.getContent().contains(<span class="string">&quot;error&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Processing failed, will retry&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;Received retry message: &#123;&#125;&quot;</span>, message);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Error processing message: &#123;&#125;, error: &#123;&#125;&quot;</span>, message, e.getMessage());</span><br><span class="line">                <span class="keyword">throw</span> e; <span class="comment">// 抛出异常触发重试机制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、创建 MessageController 来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/messages&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MessageProducerService producerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/unicast&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendUnicastMessage</span><span class="params">(<span class="meta">@RequestParam</span> String content)</span> </span>&#123;</span><br><span class="line">        MessageEvent message = <span class="keyword">new</span> MessageEvent()</span><br><span class="line">                .setId(UUID.randomUUID().toString())</span><br><span class="line">                .setContent(content)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">        producerService.sendUnicastMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Unicast message sent successfully&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/broadcast&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendBroadcastMessage</span><span class="params">(<span class="meta">@RequestParam</span> String content)</span> </span>&#123;</span><br><span class="line">        MessageEvent message = <span class="keyword">new</span> MessageEvent()</span><br><span class="line">                .setId(UUID.randomUUID().toString())</span><br><span class="line">                .setContent(content)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">        producerService.sendBroadcastMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Broadcast message sent successfully&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/retry&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendRetryMessage</span><span class="params">(<span class="meta">@RequestParam</span> String content)</span> </span>&#123;</span><br><span class="line">        MessageEvent message = <span class="keyword">new</span> MessageEvent()</span><br><span class="line">                .setId(UUID.randomUUID().toString())</span><br><span class="line">                .setContent(content)</span><br><span class="line">                .setTimestamp(System.currentTimeMillis());</span><br><span class="line">        producerService.sendRetryMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Retry message sent successfully&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;消息队列在项目中会经常用到，目前我们使用的是 RabbitMQ，但在 Java 技术栈下，RocketMQ 使用的比较多。下面比较下 RabbitMQ 和 RocketMQ。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="RocketMQ" scheme="http://fwhyy.com/tags/rocketmq/"/>
    
    <category term="消息队列" scheme="http://fwhyy.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>OpenAI 连续 12 天 AI 发布会汇总</title>
    <link href="http://fwhyy.com/2024/12/summary-of-openais-12-consecutive-days-of-ai-press-conferences/"/>
    <id>http://fwhyy.com/2024/12/summary-of-openais-12-consecutive-days-of-ai-press-conferences/</id>
    <published>2024-12-21T08:25:00.000Z</published>
    <updated>2025-02-12T08:25:52.913Z</updated>
    
    <content type="html"><![CDATA[<p>随着凌晨第十二天的 o3 模型的发布，OpenAI 连续 12 天的 AI 发布会结束了。下面回顾下这十二天都发布了些啥。</p><span id="more"></span><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>在 OpenAI 的第一天发布会上，主要发布了两个重要的更新：o1 的完整版本和 ChatGPT Pro 订阅服务。</p><p>1、o 1 完整版本：这个版本在多个方面实现了突破性进展，包括更智能、更快的响应速度、多模态输入能力（能够处理图像和文本信息），以及在指令遵循方面的表现更好。o1 在重大错误率上降低了约 34%，思考速度提升了约 50%。o1 模型现在能够同时处理图像和文本进行推理，这为视觉相关的应用开辟了广阔的应用前景。</p><p>2、ChatGPT Pro：这是一个高级订阅服务，每月收费 200 美元，提供了无限访问 OpenAI 最先进的模型 o1，以及 o1-mini、GPT-4 o 和 Advanced Voice 等功能。特别引人注目的是 o1 Pro 模式，这是 o1 的一个高阶版本，利用更强大的计算资源，深度分析问题并为最复杂的问题提供更优解答。</p><p>用户价值：</p><ul><li>提升效率和准确性：o1 的升级版为用户提供了更快、更准确的服务，尤其在复杂问题的处理上，减少了错误率，提高了思考速度。</li><li>多模态能力：多模态输入的支持使得 o1 能够处理更多样化的任务，如图像分析和图文结合的创作等。</li><li>专业级服务：ChatGPT Pro 为高需求用户提供了更强大的功能和更稳定的服务，适合在数学、编程等领域需要极致性能的用户。</li></ul><p>o1 完整版本需要 Plus 用户才能体验，ChatGPT Pro 对个人来说太贵了，况且那些高级推理能力一般人也用不上。</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>第二天的发布会重点介绍了「强化微调（Reinforcement Fine-Tuning）」技术。</p><p>强化微调技术：这项技术允许用户在极少的训练数据基础上，创建特定领域的专家模型。通过强化学习的理念，这一技术使得模型具备更自主的推理能力，并在各项指标上显著提升。强化微调能力可以让小体量模型「从高中水平跃升至专家水平」，预计将在 2025 年春季开放给用户。</p><p>用户价值：</p><p>定制化 AI 应用：强化微调技术使得企业或科研单位能够根据特定需求，快速训练出专家级别的 AI 模型，提升了定制化 AI 应用的可能性和效率。</p><h2 id="第三天"><a href="#第三天" class="headerlink" title="第三天"></a>第三天</h2><p>第三天，OpenAI 发布了备受期待的 Sora 视频产品。</p><p>Sora 视频产品：Sora 支持生成 1080p 高清视频，并提供多种视频编辑智能功能，如替换元素、最佳帧隔离等，减少了视频创作的门槛。Sora 提供了文本转视频、图像转视频和视频转视频功能，并配备了精美的分镜工具，让用户精准指导视频创作。</p><p>用户价值：</p><ul><li>视频创作民主化：Sora 的发布极大地降低了视频创作的技术门槛，使得普通用户也能创作出专业级别的视频内容。</li><li>创意表达工具：Sora 为创意人员提供了强大的工具，帮助他们更好地表达自己的想法和创意，推动了内容创作的创新。</li></ul><p>最近看了檀东东的一个海螺和 Sora 对比评测视频，感觉 Sora 有点拉胯，有点对不起那么贵的价格。</p><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202412210859501.webp"></p><p>第四天，OpenAI 为 Canvas 推出了三项重大更新，这些更新使得 Canvas 更加强大，为用户提供了全新的使用体验。</p><p>1、Canvas 全面开放与主模型集成：OpenAI 将 Canvas 面向所有用户开放，并直接将其整合到主模型中，免去了额外的加载步骤。用户可以直接从首页的输入框跳转到 Canvas，进行文档编辑和创作。</p><p>2、Python 代码实时执行能力：Canvas 集成了一个 Web Assembly 的 Python 模拟器，允许用户直接在 Canvas 中运行 Python 代码，并实时查看文本或图形输出。这个环境不仅能够实时运行与反馈代码，还能智能报错提醒和提供代码建议，极大地提高了编程效率。</p><p>3、Canvas 与自定义 GPT 的深度整合：新创建的自定义 GPT 将默认启用 Canvas 功能，而现有自定义 GPT 可以通过简单设置启用这项功能。这标志着 OpenAI 在构建 AI 应用生态系统上迈出了关键一步，有望催生出一个比传统应用商店更具创新活力的 AI 应用市场。</p><p>用户价值：</p><ul><li>提高效率：Canvas 的更新使得文档编辑、代码编写和团队协作更加高效，尤其是实时代码执行和错误反馈功能，为程序员提供了即时的编程辅助。</li><li>增强协作：通过集成评论系统和版本对比功能，Canvas 优化了团队协作体验，使得团队成员的互动更加自然和高效。</li><li>扩展应用场景：Canvas 与自定义 GPT 的整合为开发者提供了更灵活的创作空间，降低了 AI 应用开发的门槛，加速了专业领域 AI 解决方案的落地。</li></ul><p>这个功能还比较良心，向全部用户开放。</p><h2 id="第五天"><a href="#第五天" class="headerlink" title="第五天"></a>第五天</h2><p>第五天，OpenAI 宣布了 ChatGPT 与苹果 iOS、iPadOS 和 macOS 系统的集成，允许用户在操作系统中直接访问 ChatGPT 的功能。</p><p>ChatGPT 集成到苹果系统：用户可以通过唤醒 Siri 来直接使用 ChatGPT 的功能，例如点评直播中嘉宾的毛衣，ChatGPT 能够评选出最具特色的毛衣并给出合理点评。</p><p>用户价值：</p><ul><li>便捷访问：集成到苹果系统中，使得用户可以更自然、更便捷地在更多场景中使用 ChatGPT。</li><li>提升体验：通过 Siri 的集成，ChatGPT 的交互变得更加直观和易于访问，提升了用户体验。</li></ul><h2 id="第六天"><a href="#第六天" class="headerlink" title="第六天"></a>第六天</h2><p>第六天，OpenAI 宣布了高级语音模式的重大升级，其中最引人注目的是视频聊天功能的加入。</p><p>1、视频聊天功能：用户可以通过智能手机摄像头与 ChatGPT 进行视频聊天，ChatGPT 能够理解用户的连续性动作以及记住相关信息，为用户提供实时的指导和帮助。</p><p>2、屏幕共享：用户可以将自己的屏幕分享给 ChatGPT，ChatGPT 能识别设备屏幕显示的物体和内容，并据此为用户提供相应的帮助和解答。</p><p>用户价值：</p><ul><li>多模态交互：视频聊天和屏幕共享功能的加入，使得 ChatGPT 能够提供更加自然、直观的交流方式，增强了用户体验。</li><li>实时指导：通过视频聊天，ChatGPT 可以实时指导用户解决具体问题，如冲泡咖啡等，为用户提供了实际的帮助。</li><li>提高沟通效率：屏幕共享功能使得 ChatGPT 可以更直接地参与到用户的工作中，帮助用户解决技术问题，提高沟通和工作效率。</li></ul><h2 id="第七天"><a href="#第七天" class="headerlink" title="第七天"></a>第七天</h2><p>在第七天的发布会上，OpenAI 推出了名为「Projects」的新功能，这是一个旨在提高用户工作效率和项目管理能力的工具。</p><p>1、Projects 功能：Projects 允许用户上传文件、设置自定义指令，并在一个 Project 中组织所有对话。这个功能类似于 GPT，但主要的区别在于它能够将所有相关的对话和文件整合在一起，方便用户管理和跟踪项目进展。</p><p>2、文件上传与自定义指令：用户可以上传各种格式的文件，如 TXT、PDF、Word 文档、PPT 幻灯片和 Excel 电子表格等，ChatGPT 会阅读文件内容后回复用户。同时，用户可以为特定项目设置自定义指令，使 AI 更好地理解和执行项目相关的任务。</p><p>3、对话组织与管理：Projects 功能还允许用户将现有会话加入到 Project 中，使得项目管理更加集中和高效。</p><p>用户价值：</p><ul><li>提高项目管理效率：通过整合文件和对话，Projects 功能帮助用户更有效地管理和跟踪项目进展。</li><li>增强协作能力：Projects 功能支持团队协作，使得团队成员可以共享文件和讨论，提高团队协作的效率。</li><li>定制化工作流程：用户可以根据自己的工作流程设置自定义指令，使 AI 更好地适应特定的工作需求。</li></ul><p>这个功能应该值得充一个 Plus 。</p><h2 id="第八天"><a href="#第八天" class="headerlink" title="第八天"></a>第八天</h2><p>第八天，OpenAI 宣布了 ChatGPT 搜索功能的三大更新，这些更新旨在提升用户体验和搜索功能的实用性。</p><p>1、搜索性能提升：OpenAI 提升了搜索性能，特别是在移动端，使得搜索更快、更便捷。</p><p>2、地图体验加入：搜索功能中加入了地图体验，用户可以更加直观地获取地理位置相关信息。</p><p>3、全球免费开放：<strong>搜索功能现在向全球所有登录用户免费开放</strong>，用户可以通过语音对话获取实时网络信息。</p><p>用户价值：</p><ul><li>提升搜索效率：性能的提升和地图体验的加入，使得用户能够更快地找到所需信息。</li><li>实时信息获取：通过语音对话获取实时网络信息，提高了信息获取的便捷性和实时性。</li><li>全球用户覆盖：全球免费开放使得更多用户能够享受到 ChatGPT 的搜索服务。</li></ul><p>不过 AI 搜索在国内是标配了。</p><h2 id="第九天"><a href="#第九天" class="headerlink" title="第九天"></a>第九天</h2><p>在第九天的发布会上，OpenAI 主要针对开发者群体，推出了多个 API 相关更新，特别是 o1 API 的正式版本。</p><p>1、o1 API 正式版本：这个版本不仅速度更快、成本更低，还加入了视觉识别、函数调用等新功能，使得开发者能够更轻松地构建各类应用。</p><p>2、计算资源节省：o1 API 正式版本比之前的版本节省了 60% 的计算资源，这意味着开发者可以用更低的成本获得更好的性能。</p><p>3、WebRTC 支持：OpenAI 通过引入 WebRTC 支持，极大简化了实时语音应用的开发流程，现在开发者只需要 12 行代码就能构建基础的语音交互功能。</p><p>4、价格下调：相关服务的价格大幅下调，其中 GPT-4o 的音频处理费用降低了 60%，使得更多开发者有机会尝试语音应用开发。</p><p>用户价值：</p><ul><li>降低开发成本：o1 API 的正式版本和价格下调，使得开发者能够以更低的成本构建和部署 AI 应用。</li><li>提升开发效率：新功能的加入和 WebRTC 的支持，简化了开发流程，提高了开发效率。</li><li>增强应用性能：节省计算资源和提升性能，使得应用能够提供更好的用户体验。</li></ul><h2 id="第十天"><a href="#第十天" class="headerlink" title="第十天"></a>第十天</h2><p>在第十天的发布会上，OpenAI 宣布了通过电话和 WhatsApp 使用 ChatGPT 的新功能。这意味着用户可以通过最基础的电话功能或 WhatsApp 与最先进的 AI 进行对话，号码是 1-800-CHAT-GPT，或者是 1-800-242-8478。支持智能手机，老人机和座机等设备。极大地降低了使用门槛。</p><ul><li>电话接入：美国用户可以拨打 1-800-CHAT-GPT（即 1-800-242-8478），通过语音与 ChatGPT 对话。每月可免费通话 15 分钟。</li><li>WhatsApp 集成：全球用户可以在 WhatsApp 上添加上述号码为联系人，与 ChatGPT 进行文本交流。这是 OpenAI 首次将 ChatGPT 集成到 WhatsApp 平台，且该服务完全免费。</li><li>简单易用：不需要注册账号，不需要记住密码，只需要像打电话一样简单操作。</li><li>跨设备支持：从最新款的 iPhone 到老式的翻盖机，都能直接和 AI 对话。</li><li>多语言支持：ChatGPT 能够提供多语言服务，如教用户用西班牙语交流。</li></ul><p>用不上。</p><h2 id="第十一天"><a href="#第十一天" class="headerlink" title="第十一天"></a>第十一天</h2><p>在第十一天的发布会上，OpenAI 宣布了 ChatGPT 与 Mac 应用的深度集成，特别在编程和写作方面进行了更新。现在，用户可以通过简单的复制粘贴操作，与 Warp、XCode 等应用协同工作，无需详细交流即可执行任务。此外，ChatGPT 还支持在语音模式下与 Notion、Apple Notes 等应用协同工作。这些新功能已在 Mac 最新版 ChatGPT 应用中推出，而 Windows 用户还需等待。</p><ul><li>桌面应用全新升级：ChatGPT 桌面应用支持与多种应用程序协同工作，包括开发工具和文档编辑工具。通过 ChatGPT 分析 Git 提交数据并生成可视化图表。</li><li>实时演示与 Warp 终端、Xcode IDE 的智能协作：展示了 ChatGPT 如何与开发环境无缝协作，为编程任务提供实时支持。在 Xcode 中实现代码自动补全和功能添加。</li><li>对 Notion、Apple Notes、Quip 等写作工具的支持：这些功能现已在 Mac 桌面应用上线，Windows 用户需等待。</li><li>高级语音交互模式：通过语音模式与 ChatGPT 交谈，提供了更加自然和高效的体验。</li><li>搜索辅助功能：确保输出信息的准确性，结合搜索功能来优化写作内容。</li></ul><p>Mac 一直没升级，用不上。</p><h2 id="第十二天"><a href="#第十二天" class="headerlink" title="第十二天"></a>第十二天</h2><p>今天凌晨的发布会上，OpenAI 发布了 o3 模型及其精简版 o3-mini。这标志着 OpenAI 在 AI 模型开发上的又一大步，o3 模型在性能上比前代模型有显著提升，而 o3-mini 则提供了一个更轻便的选择，以适应不同的使用场景和需求。</p><p>为什么从 o1 直接到了 o3，是因为跟英国电信服务提供商 O2 可能存在版权或商标冲突，就直接用了 o3。</p><p>目前不知道o3什么时候放出，但可以在下面地址进行申请：</p><p><a href="https://openai.com/index/early-access-for-safety-testing/">https://openai.com/index/early-access-for-safety-testing/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202412210859876.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着凌晨第十二天的 o3 模型的发布，OpenAI 连续 12 天的 AI 发布会结束了。下面回顾下这十二天都发布了些啥。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="总结" scheme="http://fwhyy.com/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>信创浪潮下的.NET困境与技术转型思考</title>
    <link href="http://fwhyy.com/2024/12/under-the-wave-of-innovation-and-entrepreneurship-net-dilemma-and-technological-transformation-thinking/"/>
    <id>http://fwhyy.com/2024/12/under-the-wave-of-innovation-and-entrepreneurship-net-dilemma-and-technological-transformation-thinking/</id>
    <published>2024-12-16T08:23:00.000Z</published>
    <updated>2025-02-12T08:24:51.764Z</updated>
    
    <content type="html"><![CDATA[<p>开始之前我想先介绍下什么是.NET、什么是信创？</p><span id="more"></span><h2 id="什么是-NET？"><a href="#什么是-NET？" class="headerlink" title="什么是 .NET？"></a>什么是 .NET？</h2><p>我们现在说 .NET 通常指 .NET Core 之后的版本。.NET Core 是跨平台的开源框架，不仅可以运行在 Windows，还支持 Linux 和 macOS。在 .NET Core 3.1 之后发布的 .NET 5 又做了大统一，名称中也去掉 Core 了），目前最新的版本为 .NET9 。</p><p>.NET 有以下几个特点：</p><p>1、采用最开放的 MIT/Apache 2 协议开源，具备中立性。</p><p>2、归属中立的第三方组织 .NET 基金会管理，不属于任何商业公司，进一步增强了其独立性和开放性。</p><p>3、完全支持 ARM 32/64 架构，适配国内主流的 ARM 架构芯片，如鲲鹏、飞腾等。</p><h2 id="什么是信创-？"><a href="#什么是信创-？" class="headerlink" title="什么是信创 ？"></a>什么是信创 ？</h2><p>信创，即信息技术应用创新产业，其核心目标是实现信息技术领域的自主可控，以保障国家信息安全。国资委 2022 年 79 号文件主要指示如下：</p><p><strong>核心内容</strong>：要求在 5 年内国企全部完成信创替换。</p><p><strong>实施步骤</strong>:</p><p>1、2022 年 11 月底，完成信创改造方案规划并报送国资委；</p><p>2、2023 年 1 月起，每季度报送信息化系统信创改造的最新进度；</p><p>3、2027 年底，全部央国企必须完成信息化系统的信创改造工作。</p><p><strong>替换要求</strong>：</p><p>1、全面替换：OA、门户、邮箱、纪检、党群、档案、经营管理。</p><p>2、应替就替：战略决策、ERP、风控管理、CRM 管理系统。</p><p>3、能替就替：生产制造、研发系统。</p><p>为什么要发展信创？</p><p>1、<strong>保障国家信息安全</strong>：随着信息技术的快速发展，网络安全风险日益增加，发展信创有助于提升国家信息安全水平。</p><p>2、<strong>实现自主可控</strong>：历史上，中国在信息技术领域长期依赖国外技术，发展信创可以推动国内信息技术产业的发展，减少对外部技术的依赖。</p><p>4、<strong>应对国际竞争</strong>：在全球信息技术产业竞争加剧的背景下，发展信创产业有助于提升国家的国际竞争力。</p><p>4、<strong>促进数字化转型</strong>：信创产业的发展有利于国内企业更安全地完成数字化转型。</p><h2 id="NET-支持信创吗？"><a href="#NET-支持信创吗？" class="headerlink" title=".NET 支持信创吗？"></a>.NET 支持信创吗？</h2><p>毫无疑问，从技术上来说，.NET 是支持信创的。</p><p>但是，这没有用，客户不听解释。</p><p>随着 27 年的临近，企业的信创进程在加快。最近见了不少客户，不管是否了解技术，都谈 .NET 色变，有的更是将 .NET 纳入了黑名单。有客户原话是：</p><blockquote><p>我也知道 .NET 是支持信创的，但集团下了文，不让用，我们也没有办法。</p></blockquote><p>幸好我们产品比较开放，很早就是多技术栈并行的。不过也很无奈，需要全面进行技术栈迁移了。</p><h2 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h2><p>说到无奈，是因为要做出改变，就要离开舒适区了。但仔细想想，舒适区待久了很难让人进步。这次的转型也许会成为再上一层楼的一个契机。转型分为两个层面：技术和业务。</p><h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>1、代码块节点使用到的 nodejs、python 还是继续保留。</p><p>2、剩余的 .NET 部分全部转换为 Java。</p><p>3、转换后的 Java 程序需要和原来的 Java 代码一起通盘考虑，架构上需要重新考虑和规划。</p><p>4、合理梳理业务链路、优化缓存的使用，进一步提升性能、稳定性和扩展性。</p><h3 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h3><p>我们的产品为低代码类型的产品，目的是能快速高效地为客户落地业务。现在随着 AI 技术的发展，我们产品也需要做出相应的变化。</p><p>AI 的发展远比我们想象的的要迅猛，现在 ChatGPT 的 o1 模型具备很强的推理能力。</p><p>Cursor 和 Windsurf 借助 Claude 3.5 Sonnet 模型可以根据自然语言进行项目目录创建和编码实现，现在两个工具都支持 agent 模式，可以执行客户端的命令，我们需要的只是点下 accept 就可以。最近比较火的小猫补光灯 app 就是作者在 Cursor 中完成的。</p><p>v0.dev 在前端页面的制作非常有优势的，直接浏览器可以预览，UI 设计师做出原型图，v0 就可以做出差不多效果的前端页面。</p><p>Gemini 现在最新的模型已经支持 2M Tokens 的长上下文窗口。一些内容比较多的代码文件需要进行分析可以交给 Gemini 。</p><p>功能都很强大，但比较分散。有点像是没有超链接的互联网，如果通过 Agent 将各种 AI 能力互联起来形成一个网络，必然能创新出更多的场景，真正通向 AGI 。2025 可能是 Agent 高速发展的一年。</p><p>那么我们的产品也需要做相应的改变，要有具备调用 Agent 和被 Agent 调用的能力。</p><h2 id="对程序员的影响"><a href="#对程序员的影响" class="headerlink" title="对程序员的影响"></a>对程序员的影响</h2><p>技术栈的改变，团队必然需要学习更多新的技能，这肯定不是坏事。而且写代码的思维、面向对象的原则都是通用的。借助现在的 AI 能力，语言上的细微差别几乎可以忽略。</p><p>现阶段，程序员可以借助 AI 工具来辅助编码，但整体架构还是需要人来把控，AI 写的代码也需要人来审核。其实是对人的要求更高了，需要懂上层架构，也要懂底层原理。</p><p>随着 AI 的进一步发展，程序员需要担起指挥的工作，以前是产品经理指挥程序员干活，以后会变成程序员指挥 AI 干活。所以，只要持续学习，程序员不会失业，只是工作形式会发生变化。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>俗话说，不破不立。新东西的出现，必然会带来新的机遇，不管是 .NET 还是 Java，都是为业务服务的工具。</p><p>这个号当时取名为「不止dotNET」，也是不想被某一种技术给束缚了，所以后面会分享 Java 甚至其他各种技术的学习心得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开始之前我想先介绍下什么是.NET、什么是信创？&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="信创" scheme="http://fwhyy.com/tags/%E4%BF%A1%E5%88%9B/"/>
    
    <category term="思考" scheme="http://fwhyy.com/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="dotNET" scheme="http://fwhyy.com/tags/dotnet/"/>
    
  </entry>
  
  <entry>
    <title>2024光谷马拉松复盘，风雨中迎来新突破</title>
    <link href="http://fwhyy.com/2024/11/2024-optics-valley-marathon-review-new-breakthrough-in-the-wind-and-rain/"/>
    <id>http://fwhyy.com/2024/11/2024-optics-valley-marathon-review-new-breakthrough-in-the-wind-and-rain/</id>
    <published>2024-11-25T08:11:00.000Z</published>
    <updated>2025-02-12T08:13:01.496Z</updated>
    
    <content type="html"><![CDATA[<p>光谷马拉松是家门口的马拉松，起点在华中科技大学的正门口，我每天上下班都会经过。很幸运 2024 年到光谷马拉松中签了，这也是 2017 年武汉马拉松之后第二次中签武汉本地的马拉松。比赛日期是 11 月 17 日上午 8 点。</p><span id="more"></span><p>在光谷马拉松之前的一场比赛是 3 月 31 日的石家庄马拉松，当时参加了 PB计划的冬训，大幅 PB，跑了 335 的成绩，非常满意。详细可以阅读：《复盘石家庄全马（PB 80 分钟）》。</p><p>这次的光谷马拉松提前就关注天气，17 号有大风，还很有可能下雨，也看了很多赛道的探路视频，得知全程马拉松的爬升有 200 多米。本来没抱希望，想着安全完赛就好。但最终还是在下雨刮风的天气下 PB 了近 5 分钟。</p><p>下面就从训练、赛前、赛中来复盘下这次比赛吧。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>石家庄马拉松之后就比较佛系了，虽然跑步一直没有停，但强度课跑得比较少。因为 7 月份要跑崇礼 MTC 越野赛，所以四、五、六月更多的在练习爬升。</p><p>崇礼回来后就是漫长的夏季了，这也是第一次在夏天坚持跑步，无与伦比的体验，出门 5 分钟就全身湿透，包括鞋袜。手里拿着冻成冰块的水，不到五公里就变成温水了。这种天气确实是一种考验，每天都关注着天气，期待着气温的下降。即便如此，七、八月的月跑量也上了 200。</p><p>九、十两个月回归到正常的训练。</p><p>因为有 PB计划的经验，总体训练遵循一个大的原则：</p><p>1、以周为单位，有氧跑为主；一周有一个强度跑，一般在周三；一周有一个长距离，一般安排在周末；</p><p>2、强度课主要来源为 B 站 UP主山雨小月和跑者日历四群的小伙伴提供；</p><p>3、每个月保底 200 公里的跑量；</p><p>4、赛前多跑马配，找到比赛的配速感觉。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202411250758162.webp"></p><h2 id="赛前准备"><a href="#赛前准备" class="headerlink" title="赛前准备"></a>赛前准备</h2><p>赛前准备有：装备、补给、饮食、天气</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202411250758117.webp"></p><h3 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h3><ul><li>背心：和石家庄马拉松一样，内道的风洞背心</li><li>裤子：朋友送的一条 2XU 的压缩裤</li><li>鞋子：上半年托朋友买了一双 160x5.0 和 160x5.0 Pro ，两双鞋都磨合了将近 100 公里，最终还是选择了 160x5.0 ，160x5.0Pro 跑过一次 30 公里，小腿肌肉非常酸，应该是力量和速度都达不到，现在还驾驭不了。</li></ul><h3 id="补给"><a href="#补给" class="headerlink" title="补给"></a>补给</h3><p>1、一瓶赛速饮。</p><p>2、一支参赛包里的康比特能量胶和 5 只 sis 能量胶。</p><p>3、8 颗盐丸。</p><h3 id="饮食"><a href="#饮食" class="headerlink" title="饮食"></a>饮食</h3><p>这次的光谷马拉松并没有那种要去拼死一战的感觉，是跑成绩冲击 PB 还是享受赛道都是可以的。饮食没有怎么特别的控制，只是在临近比赛的几天碳水稍微吃的多了点。</p><h3 id="天气"><a href="#天气" class="headerlink" title="天气"></a>天气</h3><p>一直都在关注着 11 月 17 号的天气，每天看到的都不一样。直到临近比赛看到 17 号有雨、还有 5 级大风。</p><p>心态也就释然了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202411250758327.webp"></p><h2 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h2><p>家离起点不算太远，也就没有起的很早，6 点起床，排空、吃了一碗泡面，换上装备，老婆开车送我到起点附近。一切都非常顺利，只是封路导致老婆回家绕了很大一圈。</p><p>光谷马拉松是 8 点起跑，我下车走了几百米到达起点时刚好 7 点，过安检时因为赛速饮是液体，不能带进去，就直接喝掉了，比预计的提前了半个小时。</p><p>光马的起点安排很合理，安检完进入等待区后，厕所和存包车在等待区路的两侧。我可以不用那么着急就存包，因为气温较低，身上的外套可以多穿会。之前参加过的不少比赛厕所和存包车都在检录区的外面，有的还离的比较远，非常不方便。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202411250759458.webp"></p><p>出发前的 15 分钟，吃了一根康比特的胶，就等候发枪了。因站的比较靠前，第一次仅用十几秒就过了拱门。这次的策略是先追上 330 的兔子，然后就紧跟在兔子方队的后面，这样的好处是可以有稳定的配速，还可以让前面的人挡风。</p><p>大概在 3 公里的地方追上了 330 的兔子，然后就一直跟在兔子后面，配速稳定在 455 左右，上坡会慢一点，下坡就稍微快一点。</p><p>这也是第一次跟着兔子跑，这几个 330 的兔子很专业，互相会报配速和总时间差，其中有一个去年跑港百还拿了小金人。跟着兔子跑确实很轻松，尽管光谷马拉松的坡非常多，也没有很累的感觉。</p><p>1 小时 44 分 59 秒，我跟在兔子后面过了半程。</p><p>就这样一直到了 30 公里，心肺感觉很轻松，腿也没有抽筋，我就有点飘了，加速到 440 左右，持续跑了两三公里，已经将 330 兔子远远甩在身后了。但好景不长，33 公里多，小腿有一点点要抽筋的感觉，就主动降速了。</p><p>终于，36 公里时，330 的兔子追上了我，并且很快就超过了我，而我还在抽筋边缘苦苦挣扎。抽筋不算很严重，只要降低配速就能缓解。让人着急的是体感感觉很轻松，但腿不敢发力。就这样一直跑到 41 公里，奇怪的是，最后一公里，稍微加速，但腿也没有抽筋的感觉。</p><p>最后的官方净成绩是 3:30:51 ，虽然没有突破 330，但仍然 PB 了近 5 分钟，很不错了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、再次要强调下跑量和力量的重要性，尤其是肌力的练习，是轻松完赛不抽筋的关键。</p><p>2、光马的天气很多人觉得不好，有一半的时间在下雨，不过我觉得下小雨比出太阳好，要是不刮大风就更好了。</p><p>3、最近听了跑者日历最新一期节目，将跑步的长期主义，我觉得这就是我跑步的初心，重要的是能跑的久，跑的快不快只是这个过程中的结果，顺其自然就好。</p><p>4、跑步很简单，但要持续跑下去也不太容易，非常感谢家属的支持，感谢跑者日历四群小伙伴的激励。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;光谷马拉松是家门口的马拉松，起点在华中科技大学的正门口，我每天上下班都会经过。很幸运 2024 年到光谷马拉松中签了，这也是 2017 年武汉马拉松之后第二次中签武汉本地的马拉松。比赛日期是 11 月 17 日上午 8 点。&lt;/p&gt;</summary>
    
    
    
    <category term="跑步" scheme="http://fwhyy.com/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
    <category term="马拉松" scheme="http://fwhyy.com/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
    <category term="跑步" scheme="http://fwhyy.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>AI工具推荐-辅助编程篇（202410）</title>
    <link href="http://fwhyy.com/2024/10/recommended-ai-tools-auxiliary-programming-202410/"/>
    <id>http://fwhyy.com/2024/10/recommended-ai-tools-auxiliary-programming-202410/</id>
    <published>2024-10-30T10:54:00.000Z</published>
    <updated>2025-02-12T08:35:19.158Z</updated>
    
    <content type="html"><![CDATA[<p>AI 的发展速度太快了，GPT 3.5 发布到现在也才不到两年的时间，现在的能力跟当时相比，已经不可同日而语。而就在前几天，升级版的 Claude 3.5 Sonnet 模型已经可以操控用户电脑了，还有正在内测的智谱 AI 的 AutoGLM 可以在移动端进行手机的操控。</p><span id="more"></span><p>作为程序员，非常有必要学习如何使用 AI 工具来提升效率，给自己多争取一点“摸鱼”的时间。目前了解到的辅助编程的工具有三类：</p><p>1、以插件的形式来使用，比如：MarsCode、Comate、通义灵码。</p><p>2、AI 编辑器，比如：Cursor 。</p><p>3、代码生成发布一条龙，比如：Bolt.new</p><h2 id="编程-IDE-插件中的-AI-助手"><a href="#编程-IDE-插件中的-AI-助手" class="headerlink" title="编程 IDE 插件中的 AI 助手"></a>编程 IDE 插件中的 AI 助手</h2><p>MarsCode、Comate、通义灵码这三个工具都是以插件的形式安装在 IDE 中使用，比如 VSCode 、JetBrains 系列的开发工具等，下面是这三个工具的简单介绍：</p><h3 id="MarsCode"><a href="#MarsCode" class="headerlink" title="MarsCode"></a>MarsCode</h3><ul><li><strong>出自</strong>：豆包，隶属于北京引力弹弓科技有限公司。</li><li><strong>特点</strong>：提供智能代码补全、单测生成、代码解释、错误修复、生成注释、AI 问答等功能，支持超过 100 种编程语言，兼容 VSCode 和 JetBrains 编辑器,没有 Visual Studio 。</li><li><strong>适用场景</strong>：适用于各种编程任务，包括代码编写、单元测试生成、代码解释和错误修复等。</li></ul><h3 id="Comate"><a href="#Comate" class="headerlink" title="Comate"></a>Comate</h3><ul><li><strong>出自</strong>：百度，基于文心大模型。</li><li><strong>特点</strong>：提供智能代码生成、单测生成、注释生成、代码优化、代码解释、研发智能问答等功能，支持 100 多种编程语言和主流 IDE。</li><li><strong>适用场景</strong>：适用于研发全流程，包括代码编写、优化、注释生成、单测生成和研发问答等。</li></ul><h3 id="通义灵码"><a href="#通义灵码" class="headerlink" title="通义灵码"></a>通义灵码</h3><ul><li><strong>出自</strong>：阿里云，基于通义大模型。</li><li><strong>特点</strong>：提供代码智能生成、单元测试生成、代码优化、代码解释、研发智能问答等功能，支持200多种编程语言和主流 IDE。</li><li><strong>适用场景</strong>：适用于代码编写、单元测试生成、代码优化、代码解释和研发问答等。</li></ul><p>这三个工具的功能大同小异，但也有各自的特点：</p><p>1、在函数的上方有各种 AI 工具按钮，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291708760.webp"></p><p>可以看出，代码解释、函数注释、生成单测是三个工具都有，MarsCode 没有优化建议，而 Comate 多了一个行间注释。</p><p>2、都有一个对话框窗口，使用斜杠唤起相关的指令，我对比了下， Comate 的最丰富。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291707866.webp"></p><p>3、在进行代码解释的时候，通义灵码还贴心生成了流程图，对于复杂的业务逻辑，有图的帮助可以更容易理解。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291707945.webp"></p><p>综合下来，我更喜欢的是 Comate，功能丰富、UI 漂亮、中文支持友好。不过另外两个也会同时安装，有些时候，如果一个工具给出的答案不是很满意，可以分别都试试，对比着看，就能得到比较满意的答案。</p><h2 id="通过对话生成代码文件：Cursor"><a href="#通过对话生成代码文件：Cursor" class="headerlink" title="通过对话生成代码文件：Cursor"></a>通过对话生成代码文件：Cursor</h2><p>Cursor 是在 VSCode 的基础上开发出来的一款 AI 开发工具。除了有上面提到的插件类型编程助手中的对话能力，还有三点比较惊艳到我：</p><p>1、有多种 AI 模型可以使用，但效果最好的还是 Claude 3.5 Sonnet。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291708944.webp"></p><p>2、有 Chat 和 Composer 两种模式，在 Composer 模式中，通过自然语言描述需求，Cursor 可以创建相关的代码文件，后续的各种修改你只需要在对话框中打字就好，代码全是自动修改。如果在编辑器中没有发现 Composer 窗口，可以可以先用 cmd + i 打开小弹窗，然后固定在右边。</p><p>3、在对话框中粘贴一个 UI 原型图，指定使用什么前端技术，Cursor 可以直接做出差不多效果的 UI 界面，还原度很高。</p><p>使用 Cursor 时，建议一步一步进行引导，不要一次性说所有的需求和功能。就我目前的使用来看，Cursor 还只适合做一些简单的工具类软件。复杂的需求沟通到最后它可能会忘记了前面的一些上下文，导致将正确的代码修改错了。</p><p>另外，我发现还可以使用 Cursor 来学习解决问题的思路，比如遇到编译或运行报错，将错误信息发给 Cursor，Cursor 会给出排查的思路：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291708389.webp"></p><h2 id="构建发布一条龙：Bolt-new"><a href="#构建发布一条龙：Bolt-new" class="headerlink" title="构建发布一条龙：Bolt.new"></a>构建发布一条龙：Bolt.new</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291708867.webp"></p><p>Bolt.new 是一个革命性的 AI 全栈 Web 编程工具，它结合了人工智能（AI）和 WebContainers 技术，为开发者提供了一个全新的开发体验。与传统的 AI 编程辅助工具相比，Bolt.new 具有以下几个显著的亮点：</p><p>1、<strong>无需复杂配置</strong>：Bolt.new 允许用户直接通过浏览器访问，无需下载或安装任何软件，也无需进行复杂的本地环境配置。这极大地简化了开发流程，使开发者能够更专注于代码的构建。</p><p>2、<strong>完整的全栈开发环境</strong>：Bolt.new 提供了完整的全栈设置，包括 npm 包安装、Node.js 服务器以及与第三方 API 的交互能力。这使得开发者能够开发完整的项目，而不仅仅局限于单个文件和预览。</p><p>3、<strong>灵活的项目管理和发布</strong>：在 Bolt.new 中可以快速将生产的项目代码在 StackBlitz 中打开继续编辑。也可以很方便一键发布，从开发到生产的过程更加顺畅。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410291714448.webp"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>AI 工具正在重塑编程领域的工作方式，从辅助编程到全流程自动化，开发者的生产力得到了前所未有的提升。无论是 MarsCode、Comate、通义灵码这样的 VSCode 插件，还是通过对话生成代码文件的 Cursor，以及一站式构建发布的 Bolt.new，AI 正在为编程提供前所未有的便利。</p><p>随着 AI 对输入输出的 Token 数的增强，未来让 AI 直接理解整个项目的代码，一键转换为其他任何语言肯定不是难事。在这个前提下，优化、重构、功能增加就变得非常简单了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AI 的发展速度太快了，GPT 3.5 发布到现在也才不到两年的时间，现在的能力跟当时相比，已经不可同日而语。而就在前几天，升级版的 Claude 3.5 Sonnet 模型已经可以操控用户电脑了，还有正在内测的智谱 AI 的 AutoGLM 可以在移动端进行手机的操控。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>代码写的好，就可以不写技术文档了吗？</title>
    <link href="http://fwhyy.com/2024/10/is-it-okay-not-to-write-technical-documentation-if-the-code-is-well-written/"/>
    <id>http://fwhyy.com/2024/10/is-it-okay-not-to-write-technical-documentation-if-the-code-is-well-written/</id>
    <published>2024-10-23T08:08:00.000Z</published>
    <updated>2025-02-12T08:09:24.688Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，代码与文档的关系是一个经常被讨论的话题，最近在一个技术群里也针对这个话题展开了讨论，大家各抒己见，以下是群中的一些主要观点，希望对你有所启发。</p><span id="more"></span><h2 id="观点一、代码无法替代文档，文档是必需的"><a href="#观点一、代码无法替代文档，文档是必需的" class="headerlink" title="观点一、代码无法替代文档，文档是必需的"></a>观点一、代码无法替代文档，文档是必需的</h2><p>在项目的初期阶段，文档对于需求分析和设计至关重要，它帮助团队理解整体目标和约束。而在实现和维护阶段，代码是核心内容，但文档依然不可或缺，用来补充背景信息、重点逻辑等，确保团队的有效协作。</p><ul><li><strong>团队成员水平参差不齐</strong>：在大型团队中，成员的编码水平和理解能力不同，仅靠代码无法确保所有人都理解项目的全部细节。文档可以为经验不足的成员提供必要的指导，帮助他们更快地融入项目。</li><li><strong>代码难以表达设计思路和决策过程</strong>：代码是最终实现的结果，但难以完整传达开发者的思考过程、约束条件，以及为何选择某种实现方式。这些背景信息对于后续的维护和迭代非常重要。</li><li><strong>知识传承的需要</strong>：代码会随着时间和技术的演进而过时（指的是有些历史代码架构、实现可能都不是最优的，但一直在稳定运行，没就没有去进行重构），但文档能够记录项目的核心理念和设计思路，帮助新成员快速上手，减少摸索的时间成本。</li><li><strong>写好代码的成本高于写文档</strong>：高质量代码的编写需要丰富的经验和时间，而编写简洁而清晰的文档相对容易，可以迅速传达重要的信息。</li><li><strong>文档面向多种读者</strong>：代码主要面向开发者，而文档可以针对不同的受众，如非技术人员和管理层，帮助他们理解项目的整体状况和业务逻辑。</li><li><strong>避免误解和知识诅咒</strong>：开发者通常认为自己的代码已经足够清晰，但对其他人来说可能并非如此。文档可以填补理解上的差距，降低沟通成本。</li></ul><h2 id="观点二、代码和文档是互补的，应该同时重视"><a href="#观点二、代码和文档是互补的，应该同时重视" class="headerlink" title="观点二、代码和文档是互补的，应该同时重视"></a>观点二、代码和文档是互补的，应该同时重视</h2><p>在小型团队中，沟通相对简单，文档的需求可能较少，更多依赖于自解释代码和口头沟通。而在大型团队中，成员众多且角色多样，文档的重要性显著提高，有助于团队成员理解项目背景、业务逻辑和设计决策，降低沟通成本。</p><ul><li><strong>自解释代码减少了部分文档需求</strong>：如果代码命名规范且逻辑清晰，部分重复性的文档可以省略，这符合 DRY（Don’t Repeat Yourself）原则。</li><li><strong>代码无法替代所有文档</strong>：即便代码写得再好，也无法描述项目的背景、业务逻辑、设计决策等信息，这些内容往往需要在文档中进行详细说明。</li><li><strong>团队协作需要平衡</strong>：团队应通过讨论来确定文档的必要性，确保每个成员都参与到文档的维护中，促进知识的共享和流动。</li><li><strong>文档需要更新</strong>：过度或形式化的文档可能流于形式，反而成为负担。因此，需要合理的文档管理和及时更新，以确保其质量和实用性。</li><li><strong>代码需要达意：</strong> 即便有很清晰的文档，开发人员最终还是需要去阅读和修改代码，所以代码本身的质量也非常重要。</li></ul><h2 id="观点三：过度依赖代码或文档都会带来问题，关键在于平衡"><a href="#观点三：过度依赖代码或文档都会带来问题，关键在于平衡" class="headerlink" title="观点三：过度依赖代码或文档都会带来问题，关键在于平衡"></a>观点三：过度依赖代码或文档都会带来问题，关键在于平衡</h2><p>在敏捷开发中，找到代码与文档的平衡尤为重要。例如，有一个团队在开发过程中采用了「轻文档化」策略，针对关键模块和复杂业务逻辑编写简要的设计文档，而对于简单的实现则依赖于清晰的代码注释和团队协作。这种方式既保证了开发效率，又确保了文档的实用性和及时性。</p><ul><li><strong>过分强调代码会忽略知识传递</strong>：没有文档的项目在团队人员变动时可能会面临严重的知识流失问题，从而影响项目的长期维护和发展。</li><li><strong>过度依赖文档可能导致低效</strong>：如果文档过于冗长或没有及时更新，开发者最终还是不得不查阅代码，这无疑增加了时间成本。</li><li><strong>培养文档使用文化</strong>：如果没有人阅读文档，开发者也就缺乏编写的动力。因此，团队需要培养阅读和利用文档的文化，使文档成为项目不可或缺的一部分。</li></ul><h2 id="观点四：澄清对「代码即文档」的误解"><a href="#观点四：澄清对「代码即文档」的误解" class="headerlink" title="观点四：澄清对「代码即文档」的误解"></a>观点四：澄清对「代码即文档」的误解</h2><ul><li><strong>代码清晰就不需要文档</strong>：某团队在开发初期认为只要代码写得足够清晰，就不需要额外的文档，导致后期新成员加入时对业务逻辑缺乏理解，不得不花费大量时间追溯代码背后的背景信息。</li><li><strong>敏捷开发不需要文档</strong>：有些团队误解了敏捷开发的原则，认为敏捷就是不写文档，结果在项目需求变更时，由于缺乏文档记录，变更管理变得困难，最终导致项目进度延误。</li><li><strong>注释等同于文档</strong>：某项目的开发者认为在代码中添加详细的注释就可以替代文档，但注释通常只针对具体的实现，而无法传达整体的设计思路和决策过程，导致项目在维护过程中，尤其是面对复杂业务逻辑时，出现困难。</li><li><strong>敏捷宣言的误读</strong>：敏捷开发提倡「可工作的软件胜过面面俱到的文档」，但这并不意味着不写文档，更不代表代码可以完全替代文档。</li><li><strong>「代码即文档」并非全覆盖</strong>：这一观点强调代码的可读性，但并不意味着代码能够表达所有类型的信息，特别是那些代码无法承载的项目背景和业务逻辑。</li><li><strong>避免走极端</strong>：认为写好代码就不需要任何文档是一种极端做法，不利于项目的长期发展和维护。</li></ul><h2 id="我的观点"><a href="#我的观点" class="headerlink" title="我的观点"></a>我的观点</h2><ul><li>代码除了让机器执行出结果，还需要人去阅读、修改、维护，所以每个开发人员需要持续提升自己的技能，从变量方法的命名到类之间的结构是清晰的、易读、可维护的。</li><li>如果代码质量很高，变量、方法上面的一些废话注释不是必须的，没有这些，代码反倒看着更简洁，但整个项目的整体架构、核心业务的逻辑、算法等还是需要沉淀到文档中，并且随着代码的迭代演进，文档也需要同步更新。</li><li>我不认为一个代码写的逻辑混乱的人，可以写出很清晰的文档。所以还是要先从代码入手，让每个人都能写出好到代码，再强调特定文档的重要性。</li></ul><p>希望对您有所帮助！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在软件开发中，代码与文档的关系是一个经常被讨论的话题，最近在一个技术群里也针对这个话题展开了讨论，大家各抒己见，以下是群中的一些主要观点，希望对你有所启发。&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="思考" scheme="http://fwhyy.com/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="技术文档" scheme="http://fwhyy.com/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>AI工具推荐-搜索问答篇（202410）</title>
    <link href="http://fwhyy.com/2024/10/ai-tool-recommendation-search-qa-article-202410/"/>
    <id>http://fwhyy.com/2024/10/ai-tool-recommendation-search-qa-article-202410/</id>
    <published>2024-10-16T08:55:00.000Z</published>
    <updated>2025-02-12T08:07:10.575Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个同事因为项目上的特殊需求，需要制作一个镜像底包。由于要求比较特殊，不容易找到现成的方案，我想到这正是 AI 工具擅长的领域，于是把需求说明随手推荐了一个工具，最终非常顺利地解决了问题。</p><span id="more"></span><p>现在各类 AI 工具非常多，常用的主要有两类：搜索问答类和辅助编程类。本文将介绍几个搜索问答类的工具。</p><h1 id="Kimi"><a href="#Kimi" class="headerlink" title="Kimi"></a>Kimi</h1><p>因为平时使用 kimi 比较多，先从 kimi 开始，下面是 kimi 对自己的介绍：</p><blockquote><p>一个由 Moonshot AI开发的多才多艺的人工智能助手。我擅长中英文对话，能够阅读和理解各种文档，还能上网搜索信息，帮你找到答案。无论是日常闲聊，还是需要专业信息，都能助你一臂之力。</p></blockquote><p>除了 Kimi，还有豆包、文心一言、通义千问、智谱清言等都有相似的功能和能力。Kimi 最近推出了探索版，只需要在对话框中输入 / 就可以启用，目前探索版每天可以使用 5 次。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410142048425.webp" alt="image.png"></p><p>Kimi 的探索版特别适合用于网络上已有的知识，依靠人工去查询总结非常耗时，而探索版就非常好用。比如我搜索：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410142106615.webp" alt="image.png"></p><p>可以看到 Kimi 阅读了 600 多个网页，最后输出的内容也按照我的要求写得非常清楚。不过 Kimi 在推理题方面稍有不足。</p><p>我用下面的推理题在 Kimi 的普通版中进行测试，答案是错误的，但探索版尝试了几次，结果有正确的也有错误的。</p><blockquote><p>问：某公司被窃，A、B、C、D四人涉嫌被拘留。侦破结果表明，罪犯就是其中的某一个人。A说：“是C偷的。”B说：“我没偷。”C说：“我也没偷。”D说：“如果B没有偷，那么就是我偷的。”现已查明，其中只有一个人说了假话，从上述条件可以确定谁偷的成立？</p></blockquote><p>同样的推理问题，通义千问也回答错误，文心一言啰嗦了上千字，但结果是正确的。让人惊艳的是豆包和智谱清言，它们知道 A 和 C 说的话是矛盾的：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410142115169.webp" alt="image.png"></p><p>Kimi 还有一个比较强大的功能是长文生成器。你给出一个关键词或一句话，Kimi 可以写出上万字的内容。比如我直接输入“数据密集型应用系统设计”（这是一部书的名称），Kimi 长文生成器直接对这本书进行了总结。</p><p>除了 Kimi，同类型的还有文心一言、通义千问、豆包、智谱清言等。</p><p>1、通义千问的效率工具包括实时记录、阅读助手、链接速读等功能，特别是链接速读可以支持 RSS，将“小宇宙”的链接直接粘贴进去，重点内容就能总结出来。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410142155600.webp" alt="image.png"></p><p>2、豆包的图片生成功能易用性不错，可以一键擦除、局部重绘和图片扩展。长文写作支持分步骤生成，先生成大纲，然后再根据大纲生成文章。</p><p>3、智谱清言的 AI 画图支持头像绘制、Logo 设计、文章配图等，功能非常实用，还支持视频生成。</p><p>这些工具我平时都是根据需求选择性地使用。有时也会对同一个问题让多个 AI 进行回答，然后对比选择，或者把一个 AI 的结果发给另一个 AI 进行优化和补充。</p><h1 id="NotebookLM"><a href="#NotebookLM" class="headerlink" title="NotebookLM"></a>NotebookLM</h1><p>NotebookLM 是 Google 开发的一款基于 AI 的笔记工具，旨在帮助用户在笔记整理、内容生成、信息探索等方面更加高效。它结合了大语言模型的能力和传统笔记的管理方式，通过智能化的交互，帮助用户从信息中提取更有价值的洞见，并进行更有结构的知识管理。</p><p>可以从一些来源来写笔记，NotebookLM 支持多种类型的来源，也可以上传文本或音频文件，基于这些内容来提问，回答的内容可以保存到笔记中。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410151125216.webp" alt="image.png"></p><p>下面是我将我的博客链接作为来源添加后，随便问了一个关于最近写的一篇文章的问题，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410151127041.webp" alt="image.png"></p><p>NotebookLM 还能做很多事情，比如给一个 GitHub 项目的链接，让它给出代码的阅读指南：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410151135947.webp" alt="image.png"></p><p>NotebookLM 最厉害的是，可以根据内容生成一个播客音频，不过目前只支持英文。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410151137870.webp" alt="image.png"></p><h2 id="秘塔-AI-搜索"><a href="#秘塔-AI-搜索" class="headerlink" title="秘塔 AI 搜索"></a>秘塔 AI 搜索</h2><p>秘塔 AI 搜索（metaso.cn）于 2024 年初上线，它是一款能够深入理解用户问题的 AI 搜索引擎，没有广告，直达结果。目前免费用户每天可以使用 100 次。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410151611557.webp" alt="image.png"></p><p>其实 Kimi 有探索版、豆包和智谱清言也有 AI 搜索功能，但秘塔专门针对 AI 搜索做得更为专业。我试了一下，问了关于“零代码平台的未来发展”的问题，回答非常详尽，还可以从文库、学术等不同角度进行搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410151616844.webp" alt="image.png"></p><p>类似于秘塔 AI 搜索的国外产品有一个叫 Perplexity。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>各类 AI 工具层出不穷，在工作和生活中的应用越来越广泛。不同的工具各有其优势，根据具体的需求选择合适的工具，可以有效地提高效率、节省时间。未来，随着 AI 技术的不断进步，我们也许会看到更多令人惊艳的应用场景，让我们拭目以待。</p><p>下一篇讲讲辅助编程相关的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一个同事因为项目上的特殊需求，需要制作一个镜像底包。由于要求比较特殊，不容易找到现成的方案，我想到这正是 AI 工具擅长的领域，于是把需求说明随手推荐了一个工具，最终非常顺利地解决了问题。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>十一皖南结伴行（2024）</title>
    <link href="http://fwhyy.com/2024/10/eleven-anhui-southern-companions-tour-2024/"/>
    <id>http://fwhyy.com/2024/10/eleven-anhui-southern-companions-tour-2024/</id>
    <published>2024-10-09T13:35:00.000Z</published>
    <updated>2025-02-12T08:03:32.850Z</updated>
    
    <content type="html"><![CDATA[<p>按照惯例，十一会自驾出行，和以往不同的是，这次有小伙伴一起。以前的老同事一家也加入了我们，他们有一个女儿，比我女儿小一岁，这让女儿多了一个玩伴，使整个旅途充满了更多的乐趣。</p><span id="more"></span><p>放假前，我们在旅行小分队群里讨论了几天，最终定出了一条较为冷门的路线，主要是在皖南转一圈，但避开热门景点，比如皖南 318 等。从 10 月 1 日出发，5 日返回武汉，行程涵盖了武汉、池州、宣城、泾县和安庆等地。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082131621.webp"></p><p>上图是当时初步制定的计划，其实只要地点和酒店确定了，到达后的时间安排都可以随时调整。</p><h2 id="10-月-1-日（武汉-池州）"><a href="#10-月-1-日（武汉-池州）" class="headerlink" title="10 月 1 日（武汉-池州）"></a>10 月 1 日（武汉-池州）</h2><p>因为工作上的事情，1 号凌晨 4 点才睡，10 点左右出发前往池州，整体路况还不错，只有几段路稍有行驶缓慢，下午 3 点多到达酒店。稍作休整后，就出发去了平天湖。当天天气阴沉且风大，但这并没有影响大家的心情。小朋友买了泡泡水在湖边玩得非常开心。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082131361.webp"></p><p>下午五六点时，天公作美，天空渐渐放晴，落日的余晖映照在湖面上，呈现出一幅绚丽动人的景象。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082132148.webp"></p><p>第二天一大早，我又独自跑步到了湖边，看到了日出。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082132844.webp"></p><h2 id="10-月-2-日（池州-宣城）"><a href="#10-月-2-日（池州-宣城）" class="headerlink" title="10 月 2 日（池州-宣城）"></a>10 月 2 日（池州-宣城）</h2><p>早餐过后，我们出发去宣城，到达时已是中午。在法制路排了三四十分钟才买到宁国粑粑，然后一行人来到了魏氏馄饨店，依然排了很久，果然在小红书上曝光多的店就特别火爆。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082132005.webp"></p><p>下午我们去了敬亭山，敬亭山历史悠久，自古以来便是文人雅士吟咏之地。李白曾多次登临此山，留下了脍炙人口的诗篇，如《独坐敬亭山》，使得敬亭山名声大振。</p><p>敬亭山不算高，海拔 300 多米，大部分都是台阶。现在的我有爬山的机会就很兴奋，当作是越野训练了。小孩们更是精力旺盛，相互攀比着，一直走在大人前面。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082133793.webp"></p><p>第二天早上，我又跑步爬了一次敬亭山。8 点之前不收门票，所以尽管很早，还是有不少人早起登山。遗憾的是，我晚了 10 分钟左右，等我到最高处的天际阁时，太阳已经升起了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082134976.webp"></p><h2 id="10-月-3-日（宣城-泾县）"><a href="#10-月-3-日（宣城-泾县）" class="headerlink" title="10 月 3 日（宣城-泾县）"></a>10 月 3 日（宣城-泾县）</h2><p>出发前，我们临时调整了行程，先去的是宣纸产业园，第一印象是人少、干净。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082134606.webp"></p><p>我们参观了宣纸的制作过程，接着女儿还体验了陶艺制作和徽墨描金的手工活动，陶艺制作应该是她旅程中最喜欢的部分。</p><p>下午我们去了桃花潭。桃花潭自古以来便因李白的诗句《赠汪伦》而闻名，诗中描绘了他与好友汪伦在桃花潭边惜别的情景，这也使得桃花潭成为了友谊的象征。</p><p>有趣的是，诗句中写道：“桃花潭水深千尺”，但现实中岸边有一块牌子，上面写着：“水深 2.5 米，注意安全”。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082135369.webp"></p><p>桃花潭岸边有很多鹅卵石，小朋友们玩着打水漂、比赛谁丢的石头更远，直到管理人员说快要涨水了，我们才离开。</p><h2 id="10-月-4-日（泾县-安庆）"><a href="#10-月-4-日（泾县-安庆）" class="headerlink" title="10 月 4 日（泾县-安庆）"></a>10 月 4 日（泾县-安庆）</h2><p>今天的目的地是安庆，我们决定先去徽州古城和阳产土楼。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082134788.webp"></p><p>徽州古城位于安徽省黄山市歙县，是中国保存完好的四大古城之一，也是国家历史文化名城。古城始建于秦朝，自唐代以来一直是徽郡、州、府治所在地，形成了独特的城套城风格。徽州古城不仅是徽文化的发祥地，也是徽学的重要中心，被誉为“东南邹鲁、礼仪之邦”。</p><p>古城内有许国石坊、斗山街、县衙、博物馆等景点，这些景点展现了古徽州的历史文化底蕴。同时，古城内也融合了现代商业，使得这座千年古城既有历史的厚重感，又充满了生活的气息。</p><p>从古城出来，导航到阳产土楼时，发现重点附近堵车严重，于是改去了离得更近的许村。许村最有特点的是大观亭。</p><p>大观亭始建于明嘉靖三十年（1557年），清康熙二十二年（1683年）进行了重修，是三层檐亭榭建筑，平面呈八角形，每边长 3.5 米，占地 64.6 平方米。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082134503.webp"></p><p>下午 4 点离开许村，前往安庆，到达安庆已经晚上 7 点，直接去了安庆七街吃了烧烤。没有酒的烧烤总感觉少了点什么。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082133037.webp"></p><h2 id="10-月-5-日（安庆-武汉）"><a href="#10-月-5-日（安庆-武汉）" class="headerlink" title="10 月 5 日（安庆-武汉）"></a>10 月 5 日（安庆-武汉）</h2><p>今天是最休闲的一天，在安庆逛一逛、吃一吃，下午就回武汉了。因为时间宽松，早上起来跑了一个长距离。</p><p>不得不说，安庆真是一个跑步的好地方，外层有长江步道，内层有康熙景观带，温度适宜，边跑边拍，非常舒服和惬意。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082133655.webp"></p><p>退房后，我们把车开到人民路附近，然后就是一通暴走，吃了大南门的牛肉包子、喝了卡旺卡奶茶、逛了前言后记新华书店和步行街、参观了英王府。</p><p>印象最深的是新华书店，人少座位多，布置也非常讲究，不管是拍照还是看书学习，都非常不错，反正武汉我是没见到类似的地方。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202410082133745.webp"></p><p>晚上 7 点多，安全回到家中。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>因为去的都是一些小众地方，没有遇到高速大堵车和景区人挤人的情况。这也是我们第一次和朋友一起结伴而行，比想象的要好很多（我这 I 人格起初还担心会遇到各种问题）。最后，非常感谢大雄订的酒店，性价比非常高，所有人都很满意。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;按照惯例，十一会自驾出行，和以往不同的是，这次有小伙伴一起。以前的老同事一家也加入了我们，他们有一个女儿，比我女儿小一岁，这让女儿多了一个玩伴，使整个旅途充满了更多的乐趣。&lt;/p&gt;</summary>
    
    
    
    <category term="旅行" scheme="http://fwhyy.com/categories/%E6%97%85%E8%A1%8C/"/>
    
    
    <category term="旅行" scheme="http://fwhyy.com/tags/%E6%97%85%E8%A1%8C/"/>
    
    <category term="十一" scheme="http://fwhyy.com/tags/%E5%8D%81%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>让信息自由流动：Follow 带你体验不一样的 RSS 阅读</title>
    <link href="http://fwhyy.com/2024/10/let-information-flow-freely-follow-takes-you-to-experience-a-different-rss-reading-experience/"/>
    <id>http://fwhyy.com/2024/10/let-information-flow-freely-follow-takes-you-to-experience-a-different-rss-reading-experience/</id>
    <published>2024-10-01T07:53:00.000Z</published>
    <updated>2025-02-12T08:01:55.317Z</updated>
    
    <content type="html"><![CDATA[<p>最近搞到一个 Follow 的邀请码，体验了几天，直观感受就是怎么没有早点出来这样的产品。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409301724196.webp"></p><p>现在每天都会接收到大量的信息，比如我的信息源有：微信公众号、得到、Twitter、YouTube、B 站、小宇宙、newsletter、技术博客、小红书等。</p><p>信息源多了，我们就需要在各类应用之间进行来回切换，还容易被各个应用的推荐算法给控制了，所以我更习惯在一个地方去看所有内容，这就需要 RSS，而 Follow 是 RSS 的升级版，似乎可以订阅一切。</p><h2 id="什么是-RSS？"><a href="#什么是-RSS？" class="headerlink" title="什么是 RSS？"></a>什么是 RSS？</h2><p>RSS，全称为「Really Simple Syndication」，是一种用于共享和聚合网络内容的技术。它采用标准的 XML 格式，使用户能够通过 RSS 阅读器订阅和阅读网站的更新，而无需逐一访问每个网站。这种形式在 20 世纪末期的网络世界尤为风靡，那时的互联网充满了自由和开放的精神，各个网站主动发布 RSS 订阅源，满足了用户对个性化信息聚合的需求。比如我的博客站点也支持 RSS：<a href="https://www.fwhyy.com/atom.xml">https://www.fwhyy.com/atom.xml</a> 。</p><h2 id="RSS-的起源与发展"><a href="#RSS-的起源与发展" class="headerlink" title="RSS 的起源与发展"></a>RSS 的起源与发展</h2><p>RSS（最早称为 RDF Site Summary）于 1999 年由 Netscape 作为其门户网站 「My Netscape」的一部分首次推出，基于早期的 RDF 标准。</p><p>同年 7 月，Netscape 发布了 RSS 0.91，称为 「Rich Site Summary」，不再依赖于 RDF，格式更为简化。</p><p>2002 年，Dave Winer 在 UserLand Software 的支持下发布了 RSS 2.0，并将其称为 「Really Simple Syndication」，这一版本因其简单的 XML 结构成为最流行的版本。</p><h2 id="RSSHub：让一切内容都能被订阅"><a href="#RSSHub：让一切内容都能被订阅" class="headerlink" title="RSSHub：让一切内容都能被订阅"></a>RSSHub：让一切内容都能被订阅</h2><p>RSS 的最大挑战之一在于，随着互联网的发展，很多网站逐渐取消了 RSS 功能，以引导用户到网站本身阅读，这样能带来广告收入。但这违背了 RSS 的去中心化和开放性精神。在这样的背景下，RSSHub 应运而生。</p><p>RSSHub 是一个强大且易于使用的开源工具，它的目标是「让万物皆可 RSS」。通过 RSSHub，用户可以生成各种类型的订阅源，即使是那些没有原生 RSS 支持的网站。Follow 就是出自 RSSHub 团队。</p><h2 id="RSS-为何走向没落？"><a href="#RSS-为何走向没落？" class="headerlink" title="RSS 为何走向没落？"></a>RSS 为何走向没落？</h2><p>尽管 RSS 曾经风靡一时，但随着时间的推移，它逐渐被边缘化。究其原因，有下面两个：</p><p>1、社交媒体的兴起改变了人们的阅读习惯。相较于 RSS，社交媒体平台通过算法推荐内容，为用户提供了更直观和即时的内容消费体验。</p><p>2、许多网站出于商业目的，取消了对 RSS 的支持，以便将流量留在自身平台上。</p><h2 id="Follow：重新定义-RSS-阅读"><a href="#Follow：重新定义-RSS-阅读" class="headerlink" title="Follow：重新定义 RSS 阅读"></a>Follow：重新定义 RSS 阅读</h2><p>Follow 不仅仅是一个 RSS 阅读器，它是一个结合了多种现代技术与社交元素的信息管理平台。由于是由 RSSHub 团队开发的，它具有独特优势，天然就能订阅一切内容。</p><p>Follow 有以下特点：</p><p>1、<strong>多元化内容聚合</strong>：Follow 支持订阅各种类型的内容，包括文章（博客）、社交媒体（微博、Twitter、即刻）、视频（B 站、YouTube）、播客（小宇宙）等。这使得用户不仅可以阅读博客和新闻，还可以在一个平台上获取社交媒体的动态、观看视频，甚至收听播客，后续应该还会添加邮件（订阅 newsletter）。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409301724112.webp"></p><p>2、<strong>AI 赋能</strong>：Follow 还引入了 AI 功能，文章和社交媒体页签中可以使用 AI 进行总结，对于订阅数量比较多的用户来说，可以快速了解更新的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409301725338.webp"></p><p>3、<strong>社交与互动</strong>：Follow 的另一个创新在于其轻社交功能，用户可以查看其他用户的订阅内容，并通过分享和发现建立联系。这种功能使得 RSS 阅读不再孤立，用户之间能够互相发现有趣的订阅源，从而形成社区化的阅读体验。这非常像在博客时代上面挂的外链，通过外链点击进去，又可以发现一些其他感兴趣的博客。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409301725915.webp"></p><p>4、<strong>激励机制</strong>：Follow 还引入了区块链激励机制，用户可以通过代币奖励自己喜欢的内容创作者。这种机制让优质内容的生产者获得了更多的认可和鼓励，推动了社区的良性循环。</p><h2 id="为什么-RSS-仍然重要？"><a href="#为什么-RSS-仍然重要？" class="headerlink" title="为什么 RSS 仍然重要？"></a>为什么 RSS 仍然重要？</h2><p>现在的年轻人估计大多都不知道 RSS 了，但我认为 RSS 仍然是重要的。</p><p>1、用户可以自由选择订阅的内容，不受算法推荐的影响，从而打破信息茧房的局限。</p><p>2、RSS 不依赖中央服务器或特定公司，用户无需提供个人信息，因此能有效保护隐私。这种去中心化特性降低了信息被控制或审查的风险，确保信息自由流动。</p><p>所以在知道 Follow 之前，我一直使用的是 Readwrise Reader，再之前还是用过 Inoreader、Google Reader 。不过目前 Follow 还在内测阶段，要不要替换还需要观望一段时间。</p><h3 id="Follow-的问题"><a href="#Follow-的问题" class="headerlink" title="Follow 的问题"></a>Follow 的问题</h3><p>1、社交媒体中内容显示不完整，只能跳转到原始链接中查看。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409301725571.webp"></p><p>2、消息显示不同步，比如在 APP 图标上显示了更新到数字，进去后，发现各个页签都是 0，随便点击一个后就会显示正确的更新数字。</p><p>3、订阅源上点击右键，菜单中点击「订阅」、「编辑」都没有反应。</p><p>4、YouTube 和 B 站我都订阅了，但 B 站的视频没法直接播放。</p><p>5、分类目录只要一切换页签就自动收缩了，没办法设置一直展开。</p><p>6、部分内容地址解析有误导致内容出不来。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409301725994.webp"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>RSS 从诞生至今，经历了兴盛与衰退，现在 Follow 的出现为 RSS 注入了新的活力，通过结合现代化的技术手段和创新的社交模式，让用户在信息获取的过程中找回了自由与乐趣。</p><p>现在 Follow 更新速度很快，每天晚上都会发一个版本，隔几天也会发布一个 alpha 版，目前最新是 v0.0.1-alpha.18 。希望尽快能出正式版。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近搞到一个 Follow 的邀请码，体验了几天，直观感受就是怎么没有早点出来这样的产品。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="Follow" scheme="http://fwhyy.com/tags/follow/"/>
    
    <category term="RSS" scheme="http://fwhyy.com/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>OpenAI o1 ，我试用一周多所了解到的</title>
    <link href="http://fwhyy.com/2024/09/introduction-to-openai-o1/"/>
    <id>http://fwhyy.com/2024/09/introduction-to-openai-o1/</id>
    <published>2024-09-25T00:44:38.000Z</published>
    <updated>2024-09-30T18:45:47.093Z</updated>
    
    <content type="html"><![CDATA[<p>1、OpenAI 在 9 月 13 日发布了 o1 的预览版。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241751659.webp"></p><p>2、o1 全称叫 OpenAI o1, 没有延续之前 GPT 系列，可见足够强大，当然也有一种说法是 o1 作为一个垂直基础模型为未来 GPT5 赋能。</p><p>3、o1 在推理方面变得更加强大了，特别擅长做数学题和写代码。在国际数学奥林匹克（IMO）资格考试中，GPT-4o 只正确解决了 13% 的问题，o1 的得分为 83%。</p><span id="more"></span><p>4、o1 分为两个版本：o1-preview 和 o1-mini，可能因为训练成本巨大或是其他原因（比如收集更高质量的问题），发布时 o1-preview 每周只能使用 30 次查询，o1-mini 是 50 次。GPT Plus 的付费用户才能使用。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241751431.webp"></p><p>5、9 月 17 号，OpenAI 发布消息，放宽了限额，o1-preview 现在为每周 50 次查询，o1-mini 改为每天 50 次查询。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241752377.webp"></p><p>6、o1 最特别的地方是能「思考」了，之前的版本都强调能快速给出结果，对 o1 来说「慢」是一种特点，当我们对 o1 提出问题时，内部会生成一个思维链来逐步推理问题，类似于人类解题时的思考过程，尝试不同的策略，并能认识到自己的错误。所以时间花的更长，通常几秒到几十秒不等。</p><p>7、o1 的慢和之前系列的快，就像丹尼尔·卡尼曼的《思考，快与慢》中写的快思考和慢思考：</p><ul><li>快思考：联想记忆，从已经训练的数据中快速获取，利用简化的决策规则解决问题，容易出现错误。</li><li>慢思考：有逻辑性，能对提的问题进行反复推敲，自我监督和矫正，正确率较高。</li></ul><p>8、正是因为 o1 能对问题进行推敲，就大大降低使用者的难度了，以前想要一个好的答案，需要写出好的提示词，现在 o1 经过推敲，更能理解提问者背后的意思。提升了易用性和效率。AI 发展太快，提示词工程师是不是刚要上岗就面临失业了呢？</p><p>9、和 GPT-4o 相比较，虽然推理能力强大很多，但功能还不算完善，比如不支持图像、不支持联网查询等，期待后续的版本。</p><p>10、对于编码来说，我们使用 o1-mini 就够了，因为 o1-mini 比 o1-preview 便宜 80%，每周有更多的查询次数，而且，编码仅需要推理不需要广泛的世界知识，非常适合 o1-mini。</p><p>11、我用 o1-mini，写了一个 License 生成工具，前端用 vue3、后端使用 .NET8，慢慢引导，从基本的功能到加上登录、加上鉴权等，周末一个上午时间就搞定了，基本没有出错，确实很强大。</p><p>12、AI 这么强大了，我们应该做更重要的事情。我觉得技术学习分为三层：</p><ul><li>架构层：架构层关注的是如何设计和构建系统的结构，确保系统的整体性和功能性，比如：单体、微服务、分布式、涉及模式、性能优化、扩展性、可维护性、安全性等。了解这些才能熟练驾驭 AI。</li><li>工具层：编程语言、框架使用等，这部分可以 AI 代替。</li><li>原理层：原理层是技术学习中最深入的一层，它关注的是底层原理和概念。了解这些，当 AI 抽风时不至于束手无策。</li></ul><p>重要的事情就是指架构层和原理层的学习。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、OpenAI 在 9 月 13 日发布了 o1 的预览版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409241751659.webp&quot;&gt;&lt;/p&gt;
&lt;p&gt;2、o1 全称叫 OpenAI o1, 没有延续之前 GPT 系列，可见足够强大，当然也有一种说法是 o1 作为一个垂直基础模型为未来 GPT5 赋能。&lt;/p&gt;
&lt;p&gt;3、o1 在推理方面变得更加强大了，特别擅长做数学题和写代码。在国际数学奥林匹克（IMO）资格考试中，GPT-4o 只正确解决了 13% 的问题，o1 的得分为 83%。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
    <category term="OpenAI" scheme="http://fwhyy.com/tags/openai/"/>
    
  </entry>
  
  <entry>
    <title>忙碌的陷阱</title>
    <link href="http://fwhyy.com/2024/09/the-busy-trap/"/>
    <id>http://fwhyy.com/2024/09/the-busy-trap/</id>
    <published>2024-09-23T00:35:29.000Z</published>
    <updated>2024-09-30T17:56:28.154Z</updated>
    
    <content type="html"><![CDATA[<p>在一个公司中，当所有人都很「忙碌」时，常常被视为高效和生产力的象征，但如果项目还是不能按时上线、客户投诉比较多，满意度差，就需要思考：这种忙碌是真的高效吗？我们是不是陷入了忙碌的陷阱了呢？</p><span id="more"></span><p>通过近段时间的观察，发现有这么几个现象：</p><h2 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h2><p>在软件开发和项目管理中，信息不对称是一个普遍存在的问题。它不仅会导致团队成员之间的沟通不畅，更会让任务的执行出现偏差。</p><blockquote><p>比如，经理安排小王写一份文档，在经理看来已经跟小王交代了文档的要求和要点，小王整理后只需交给 AI 生成相关内容，然后进行校对就可以， 1 小时以内就能完成。但小王接到任务后，评估至少得半天到一天的时间才能完成，又因为手头有优先级更高的事情，就迟迟没能完成。</p></blockquote><p>这表面上看是工作量理解的问题，但本质上却是信息不对称引发的认知差异，经理和小王的理解出现了偏差：经理认为这项任务简单快速，而小王觉得需要投入更多的精力。这种偏差在项目实施过程中尤为常见，可能导致如下问题：</p><p>1、<strong>需求理解上的偏差</strong>：客户提出的需求是否准确传达给了项目团队？<br>2、<strong>任务分配上的偏差</strong>：项目经理布置的任务，团队成员是否真正理解其目标和要求？</p><p>小时候我们都学过盲人摸象。每个人只触摸到大象的一部分，就妄下结论。摸到腿的说大象像柱子，摸到尾巴的说大象像绳子。由于缺乏全局信息，每个人的理解都不完整。这正是信息不对称导致的理解偏差。</p><p>项目失败一个很重要的原因就是需求和任务分配时的理解偏差，最终导致产出的成果不是客户想要的。想要解决，其实也很简单，在团队内部需要建立有效的沟通机制：</p><p>任务安排者应详细说明任务的背景、目标、具体要求和截止日期，最好提供书面的任务说明文档，一些小任务没有正式文档，在即时通讯工具或邮件中写清楚也是可以的。任务接受者在接到任务后，应主动反馈自己的理解，最好能复述任务要求，确认双方理解的一致性。这种双向确认机制在敏捷开发中被广泛应用，通过每日站会和及时反馈，确保团队成员的理解与任务要求高度一致。</p><p>此外，定期的沟通和反馈也是必要的。在任务进行过程中，双方应保持交流，及时汇报进展和遇到的问题。这样可以及时发现偏差，进行纠正，避免在错误的道路上越走越远。</p><h2 id="方案与需求的混淆"><a href="#方案与需求的混淆" class="headerlink" title="方案与需求的混淆"></a>方案与需求的混淆</h2><p>另一类常见的问题是将解决方案与需求混为一谈。在需求调研时，客户很容易就直接给出了解决方案，这种情况很容易导致项目资源的浪费，因为开发团队可能会依据客户的「解决方案」进行开发，却发现最终实现的功能并不能真正解决客户的问题。</p><blockquote><p>比如，在一个项目中，客户要求在流程审批中设置中能动态添加抄送人，很明显这是一个解决方案。经过深入沟通后发现，客户真正的目的其实是当审批人超时没有处理时，就抄送给此人的领导。如果没有弄清目的，盲目就去开发，肯定会造成返工，然后整个团队就可以「忙碌」了。</p></blockquote><p>为了避免这种情况，我们需要在需求分析阶段与客户进行深入的沟通。通过提问和倾听，了解他们的业务流程、痛点和目标，不要急于给出解决方案，而是先理解问题的本质，更是要能分辨客户讲的是需求还是解决方案。</p><p>同时，公司可以加强对需求分析的培训，提高团队在需求分析时的敏感度和准确度。制定标准化的需求分析流程，将需求与方案明确区分开来。这不仅有助于减少项目开发中的返工成本，还能提升客户满意度，增强公司竞争力。</p><h2 id="主次不分"><a href="#主次不分" class="headerlink" title="主次不分"></a>主次不分</h2><p>在项目实施过程中，面对众多任务和需求时，优先级的判断至关重要。如果无法正确区分主次，项目团队很容易陷入无止境的处理细节中，忽视了项目最核心的目标。</p><blockquote><p>比如：项目A 开发的系统目标用户有管理层和基层人员，管理层关注报表、大屏看板，基层员工进行数据提报。项目经理每天和基层的业务人员在一起，恰巧这些业务人员想法很多，每天都提出很多优化建议和调整，项目经理勤勤恳恳做需求记录，安排加班处理。最后项目没有按时上线，复盘后，原因是管理层关注的某个看板没有完成。</p></blockquote><p>这是很典型的主次不分，基层人员提的很多需求有可能是伪需求，重点干系人提的需求有可能很小，但会决定整个项目的推进。</p><p>为了避免主次不分的问题，项目管理中必须建立清晰的优先级管理机制，确保团队集中资源处理最重要的任务。以下是几个有效的策略：</p><p>1、<strong>明确项目的核心目标</strong>：在项目启动阶段，就要与客户的干系人明确项目的核心目标和关键成功指标。例如，在上面的案例中，管理层的需求（如报表和大屏看板）应被视为高优先级任务，并与团队沟通清楚。</p><p>2、<strong>制定优先级矩阵</strong>：采用<strong>四象限法则</strong>（重要紧急矩阵）或 <strong>MoSCoW法则</strong>（Must, Should, Could, Won’t）等优先级管理工具，将任务分类处理。优先处理那些既重要又紧急的任务，确保在有限的时间内完成对项目成功至关重要的工作。团队成员也应定期检查和更新优先级，保证任务处理顺序符合项目的实际需求。</p><p>3、<strong>加强沟通和反馈机制</strong>：项目经理不仅要与基层员工沟通，还要保持与客户重点干系人的紧密联系，确保随时掌握高层的关键需求。定期的进度汇报和反馈能帮助团队及时调整工作重心，不至于偏离核心目标。</p><p>4、<strong>防止需求蔓延</strong>：项目经理应设置严格的需求变更控制机制，避免过度的需求膨胀。对于基层员工提出的优化建议，要进行严格筛选，只处理那些符合项目整体目标并且对最终交付有显著影响的需求。对于不符合项目核心目标的需求，可以进行延后处理或将其纳入后续版本中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>忙碌常常给人一种充实感，但忙碌并不等于高效。如果我们没有明确的目标和计划，只是一味地埋头苦干，可能会陷入「忙而无果」的境地。</p><p>低头做事，也得时常抬头看路，就像越野跑，当你发现前后都没有人的时候，不一定是落在最后了，也可能是跑错了方向，这时如果继续加速追赶，只会离目标越来越远。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个公司中，当所有人都很「忙碌」时，常常被视为高效和生产力的象征，但如果项目还是不能按时上线、客户投诉比较多，满意度差，就需要思考：这种忙碌是真的高效吗？我们是不是陷入了忙碌的陷阱了呢？&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="管理" scheme="http://fwhyy.com/tags/%E7%AE%A1%E7%90%86/"/>
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="思维" scheme="http://fwhyy.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>什么是 RAG？</title>
    <link href="http://fwhyy.com/2024/09/what-is-rag/"/>
    <id>http://fwhyy.com/2024/09/what-is-rag/</id>
    <published>2024-09-10T00:32:52.000Z</published>
    <updated>2024-09-30T17:56:31.566Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能技术飞速发展的今天，各种创新和应用层出不穷。其中，RAG（Retrieval-Augmented Generation，检索增强生成）作为一种新兴的技术方法，正逐渐成为 AI 2.0 时代的杀手级应用。</p><span id="more"></span><p>那么，什么是 RAG？它如何工作？以及它在实际场景中的应用有哪些？本文将为你详细解答这些问题。</p><h2 id="一、RAG-的定义"><a href="#一、RAG-的定义" class="headerlink" title="一、RAG 的定义"></a>一、RAG 的定义</h2><p>RAG，全称为 Retrieval-Augmented Generation，直译为「检索增强生成」。简单来说，RAG是一种结合了检索和生成的技术方法。它将传统的基于检索的问答系统和基于自然语言生成的技术相结合，提升了 AI 系统在回答自然语言问题时的准确性和可靠性。</p><p>传统的生成模型依赖于大量的训练数据，通过学习这些数据来生成回答。然而，这种方法有一个明显的局限性：大模型在面对从未见过的问题或新兴领域的知识时，会产生不准确或不合逻辑的回答。</p><p>而 RAG 通过引入检索机制，首先从大量外部知识库或企业内私有文档中检索出相关信息，然后再结合生成模型，生成更加准确、上下文相关的答案。这种方法既保留了生成模型的灵活性，又增强了其对领域知识的覆盖面和准确性。</p><h2 id="二、RAG-的工作原理"><a href="#二、RAG-的工作原理" class="headerlink" title="二、RAG 的工作原理"></a>二、RAG 的工作原理</h2><p>RAG 的核心思想是通过「检索-生成」双重机制来提高生成模型的表现。具体来说，它的工作流程可以分为以下几个步骤：</p><p>1、<strong>问题理解和检索阶段</strong>：首先，RAG 模型接收到用户的问题或请求。然后，模型利用检索模块，从预定义的知识库或文档集合中，找到与问题最相关的文本片段。这些片段可以是短语、句子、段落甚至是整个文档。</p><p>2、<strong>生成阶段</strong>：在获取了相关文本片段后，RAG 模型会将这些片段与原始问题结合，输入到生成模型（GPT、通义千问、文心一言等）中。生成模型根据输入内容生成最终的答案或文本输出。</p><p>3、<strong>输出优化</strong>：为了确保生成的答案是相关且准确的，RAG 模型通常会在生成阶段加入后处理步骤，如答案的置信度评估、多候选答案筛选等，以进一步提升生成结果的质量。</p><p>这种「检索-生成」的方式使得 RAG 模型不仅可以利用现有的大规模训练数据，还可以从企业私有知识库中获取最新、最相关的信息，确保其生成的内容始终是及时、准确的。</p><p>在实际落地会分为用户端和管理端，在管理端进行知识文件的上传，系统会对文档进行文本读取、分快、向量化，将结果存入向量数据库。</p><p>用户端在一个搜索框中进行提问，系统会对问题进行向量化处理，然后到向量数据库中进行相似度匹配，将匹配的结果、原始问题、提示词一起提交给大模型，等着大模型的返回结果就好。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202409091849088.webp"></p><h2 id="三、RAG-的应用场景"><a href="#三、RAG-的应用场景" class="headerlink" title="三、RAG 的应用场景"></a>三、RAG 的应用场景</h2><p>RAG 技术的出现，使得许多传统的 NLP 任务得到了全新的解决方案。以下是几个 RAG 技术的典型应用场景：</p><p>1、<strong>智能问答</strong>：在客服、教育、医疗、企业内部知识库等领域，RAG 技术可以用于构建更为智能的问答系统。这类系统不仅可以回答常规问题，还能根据用户的特定问题实时检索相关信息，提供更加精准的答案。</p><p>2、<strong>内容生成</strong>：RAG 技术还可以用于内容创作领域，如新闻生成、技术文档编写等。通过结合检索到的最新信息，RAG 生成的内容不仅保持了连贯性，还能反映出当前的最新趋势和知识，甚至跟自己历史创作内容相结合，生成的内容可以更具有个人风格。</p><p>3、<strong>辅助决策</strong>：对于需要处理大量文档和信息的行业，如法律、金融等，RAG 技术可以帮助用户快速找到相关案例、法规或市场数据，辅助决策和研究工作。</p><h2 id="四、RAG-的技术优势"><a href="#四、RAG-的技术优势" class="headerlink" title="四、RAG 的技术优势"></a>四、RAG 的技术优势</h2><p>RAG 作为一种创新的技术方法，具有以下几大优势：</p><p>1、<strong>知识覆盖面广，更专业</strong> ：通过引入检索机制，RAG 可以访问私有领域知识库，这使得它在处理涉及专业领域问题时，依然能够生成准确的答案。</p><p>2、<strong>生成内容的准确性和上下文相关性增强</strong>：相比于传统的生成模型，RAG 生成的内容更加可靠，因为它可以借助检索到的相关信息，确保生成的文本与问题或上下文高度相关。</p><p>3、<strong>灵活性和扩展性强</strong>：RAG 模型可以灵活地应用于不同的领域和任务中，只需更换或扩展其检索库，便能适应新的应用场景。在企业内部，文档针对不同的智能部门有权限之分，RAG 的灵活性就可以很轻松满足这类需求。</p><h2 id="五、RAG-的发展前景"><a href="#五、RAG-的发展前景" class="headerlink" title="五、RAG 的发展前景"></a>五、RAG 的发展前景</h2><p>随着人工智能技术的不断进步，RAG 作为一种结合了检索和生成的混合技术方法，展示了其巨大的潜力。在未来，我们可以预见，RAG 将在更多的领域得到应用和发展，尤其是在需要大量信息处理和精准生成的场景中。</p><p>同时，随着知识库的扩展和生成模型的优化，RAG 的性能和应用广度将进一步提升。未来的 RAG 模型或许将不再局限于文本生成，还可能扩展到多模态生成，如图像、音频等，为各行各业带来更加丰富和智能的解决方案。</p><p>例如：我们现在在开发零代码开发平台，有很多的特定行业的实践经验，现在要制作一个行业系统的宣传视频，需要先写文案，再在网上找素材，然后人工进行整合，往往一个视频做完需要一两周的时间，未来 RAG 结合企业内部的专业资料，此类视频就能瞬间完成了。</p><h2 id="六、结语"><a href="#六、结语" class="headerlink" title="六、结语"></a>六、结语</h2><p>RAG（Retrieval-Augmented Generation）作为 AI2.0 时代的杀手级应用，凭借其「检索-生成」双重机制，成功解决了传统大模型的诸多局限性。它不仅提升了生成内容的准确性和上下文相关性，还扩展了知识的覆盖范围。无论是在智能问答、内容生成还是知识发现等领域，RAG 都展现出了强大的应用潜力。</p><p>现在技术成熟度也非常完善，RAG 在企业落地已经不是遥不可及的事情了，后续会继续分享怎样进行 RAG 的落地。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在人工智能技术飞速发展的今天，各种创新和应用层出不穷。其中，RAG（Retrieval-Augmented Generation，检索增强生成）作为一种新兴的技术方法，正逐渐成为 AI 2.0 时代的杀手级应用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
    <category term="RAG" scheme="http://fwhyy.com/tags/rag/"/>
    
    <category term="机器学习" scheme="http://fwhyy.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>在 .NET8 中获取 k8s 集群的 namespace id</title>
    <link href="http://fwhyy.com/2024/08/in-retrieve-the-namespace-id-of-the-k8s-cluster-in-net8/"/>
    <id>http://fwhyy.com/2024/08/in-retrieve-the-namespace-id-of-the-k8s-cluster-in-net8/</id>
    <published>2024-08-28T00:22:21.000Z</published>
    <updated>2024-09-30T16:23:34.006Z</updated>
    
    <content type="html"><![CDATA[<p>将程序和机器进行绑定是一种 License 校验的方法，需要能获取到机器的唯一标识，比如获取机器的 Mac 地址就是获取唯一标识的一种方式，命令如下：</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig |egrep &#x27;ether&#x27; |awk &#x27;&#123;&#123;print $2&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>但如果程序部署在 k8s 中，每次容器构建，使用上面命令获取的 Mac 地址就会发生变化，我使用 kubesphere 做测试发现的确如此。</p><p>那么在 k8s 环境中想要获取唯一标识应该怎么办呢？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、在 kubesphere 中，通常会以项目来进行组织，kubesphere 中的项目就是 k8s 中的 namespace，可以通过获取 namespace id 的方式来获取唯一标识。</p><p>2、.NET8 容器内部需要安装 kubectl 命令。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、构建 .NET8 底包镜像，供后面程序使用，Dockerfile 内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/aspnet:<span class="number">8.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y curl</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 kubectl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -LO <span class="string">&quot;https://dl.k8s.io/release/<span class="subst">$(curl -L -s https://dl.k8s.io/release/stable.txt)</span>/bin/linux/amd64/kubectl&quot;</span> &amp;&amp; \</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line">chmod +x kubectl &amp;&amp; \</span><br><span class="line"></span><br><span class="line">mv kubectl /usr/local/bin/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 kubectl 已正确安装</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> kubectl version --client</span></span><br></pre></td></tr></table></figure><p>在 Dockerfile 所在目录执行下面命令进行镜像构建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t net8-kube .</span><br></pre></td></tr></table></figure><p>2、编写示例程序获取 namespace id，获取 namespace id 的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace s2-test -o jsonpath=&#x27;&#123;.metadata.uid&#125;&#x27;</span><br></pre></td></tr></table></figure><p>创建一个 .NET8 的 WebAPI 项目，执行上面命令，并将结果输出，代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Diagnostics;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> builder = WebApplication.CreateBuilder(args);  </span><br><span class="line">  </span><br><span class="line">builder.Services.AddEndpointsApiExplorer();  </span><br><span class="line">builder.Services.AddSwaggerGen();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> app = builder.Build();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (app.Environment.IsDevelopment())  </span><br><span class="line">&#123;  </span><br><span class="line">    app.UseSwagger();  </span><br><span class="line">    app.UseSwaggerUI();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">app.UseHttpsRedirection();  </span><br><span class="line">  </span><br><span class="line">app.MapGet(<span class="string">&quot;/GetNamespaceId&quot;</span>, (<span class="built_in">string</span> name) =&gt;  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">&quot;id is empty&quot;</span>;  </span><br><span class="line">        <span class="keyword">try</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">string</span> cmd = <span class="string">&quot;kubectl get namespace &quot;</span>+name+<span class="string">&quot; -o jsonpath=&#x27;&#123;.metadata.uid&#125;&#x27;&quot;</span>;  </span><br><span class="line">            result= <span class="string">&quot;id is :&quot;</span>+ExecuteCommand(cmd);  </span><br><span class="line">        &#125;        catch (Exception ex)  </span><br><span class="line">        &#123;            Console.WriteLine(ex.Message);  </span><br><span class="line">        &#125;        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;)    .WithOpenApi();  </span><br><span class="line">  </span><br><span class="line">app.Run();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ExecuteCommand</span>(<span class="params"><span class="built_in">string</span> command</span>)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">var</span> processInfo = <span class="keyword">new</span> ProcessStartInfo(<span class="string">&quot;bash&quot;</span>, <span class="string">&quot;-c \&quot;&quot;</span> + command + <span class="string">&quot;\&quot;&quot;</span>)  </span><br><span class="line">    &#123;        RedirectStandardOutput = <span class="literal">true</span>,  </span><br><span class="line">        RedirectStandardError = <span class="literal">true</span>,  </span><br><span class="line">        UseShellExecute = <span class="literal">false</span>,  </span><br><span class="line">        CreateNoWindow = <span class="literal">true</span>  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">var</span> process = <span class="keyword">new</span> Process &#123; StartInfo = processInfo &#125;;  </span><br><span class="line">    process.Start();  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">string</span> output = process.StandardOutput.ReadToEnd();  </span><br><span class="line">    process.WaitForExit();  </span><br><span class="line">    <span class="keyword">return</span> output.Trim();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、将程序发布，并在 publish 目录中创建 Dockerfile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> net8-kube:latest </span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app  </span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;dotnet&quot;</span>, <span class="string">&quot;namespaceid.dll&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在 publish 目录中执行 <code>docker build -t namespace-id-test .</code>  命令进行测试程序的镜像构建。</p><p>4、在 kubesphere 中创建一个 test 项目，在该项目中创建无状态负载部署示例程序，调用程序中的示例接口，发现 namespace id 并没有获取到，日志中有报错信息：</p><blockquote><p>Error from server (Forbidden): namespaces is forbidden: User “system:serviceaccount:test:default” cannot list resource “namespaces” in API group “” at the cluster scope</p></blockquote><p>这个错误表明，当前在容器内执行 <code>kubectl</code> 命令的用户（<code>system:serviceaccount:test:default</code>）没有足够的权限在集群范围内列出命名空间（<code>namespaces</code>）。这个问题通常与 k8s 中的角色绑定（RoleBinding）或集群角色绑定（ClusterRoleBinding）配置有关。</p><p>可以使用下面命令来查看对应账户是否有权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl auth can-i list namespaces --as=system:serviceaccount:test:default</span><br></pre></td></tr></table></figure><p>结果返回 yes 说明该 <code>ServiceAccount</code> 有权限，返回 no 说明没有权限。</p><p>一种简单的解决方法就是将账户绑定到管理员角色上，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding test-admin-binding \ --clusterrole=cluster-admin \ --serviceaccount=test:default</span><br></pre></td></tr></table></figure><p>但 cluster-admin 权限过大，在生产环境中不太安全，下面是用另一种方法来解决，在服务器中创建一个 <code>namespace_reader.yaml</code> 的文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">namespace-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;namespaces&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用下面命令执行后就创建了一个名为 <code>namespace-reader</code> 的角色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f namespace_reader.yaml </span><br></pre></td></tr></table></figure><p>角色创建成功后，就可以将 <code>ServiceAccount</code> 绑定到这个只读角色了，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding test-namespace-reader-binding \</span><br><span class="line">--clusterrole=namespace-reader \</span><br><span class="line">--serviceaccount=test:default</span><br></pre></td></tr></table></figure><p>5、<code>ServiceAccount</code> 权限绑定后，再调用接口进行测试，会发现已经可以正常获取 namespace id 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将程序和机器进行绑定是一种 License 校验的方法，需要能获取到机器的唯一标识，比如获取机器的 Mac 地址就是获取唯一标识的一种方式，命令如下：&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term=".net8" scheme="http://fwhyy.com/tags/net8/"/>
    
    <category term="k8s" scheme="http://fwhyy.com/tags/k8s/"/>
    
    <category term="namespace" scheme="http://fwhyy.com/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>对提升项目效率的一点思考</title>
    <link href="http://fwhyy.com/2024/08/some-thoughts-on-improving-project-efficiency/"/>
    <id>http://fwhyy.com/2024/08/some-thoughts-on-improving-project-efficiency/</id>
    <published>2024-08-20T00:17:14.000Z</published>
    <updated>2024-09-30T16:20:00.962Z</updated>
    
    <content type="html"><![CDATA[<p>在一个软件企业中，项目实施效率非常重要，它关乎企业的竞争力，影响项目交付的速度和质量，关系到企业的盈利能力，甚至决定着企业的生死。</p><span id="more"></span><p>但当项目交付出现问题时，很多时候会粗暴地归结到人的能力上，要么人多了，要么人差了，那是不是两个差的换一个好的就能解决问题呢？</p><p>我觉得未必，有问题得找原因，找到原因，才能对症下药。</p><h2 id="效率低下的根源在哪里？"><a href="#效率低下的根源在哪里？" class="headerlink" title="效率低下的根源在哪里？"></a>效率低下的根源在哪里？</h2><p>在解决问题之前，我们必须先分析出其根源，否则改进措施很可能会事倍功半、南辕北辙。为此，我们需要问自己以下几个关键问题：</p><p>1、项目合同金额是否合理？ 下面一些情况是不合理的：</p><ul><li>新销售为了首次开单，故意压低价格</li><li>为了某个战略客户，低价中标占坑</li><li>报价时没有考虑到产品研发的成本</li></ul><p>金额低，没有钱赚，分不了项目奖金，积极性自然就不高。</p><p>2、说开发效率低到底指的是什么？ 这一问题往往有多个方面的因素，包括：</p><ul><li>研发人员技术能力的不足</li></ul><ul><li>流程与制度的不完善</li><li>团队沟通与协作的不顺畅</li><li>任务分配的不合理</li><li>实施方案的不是最优解</li><li>员工积极性的不足</li><li>工作量评估的误差</li><li>频繁的需求变更</li></ul><p>3、管理层的决策与执行是否到位？ 从部门负责人到项目经理，是否都能以客户价值为导向，并以降低公司成本为目标？</p><h2 id="数据驱动的根因分析"><a href="#数据驱动的根因分析" class="headerlink" title="数据驱动的根因分析"></a>数据驱动的根因分析</h2><p>有效的分析离不开数据支撑。我们需要从以下几个方面收集数据：</p><ul><li>项目的合同金额与投入成本，包括上线前的开发成本及验收前的调整成本</li><li>项目成员的具体工作内容</li><li>每个项目的盈亏情况</li><li>重点成本因素，如差旅、需求反复、特定需求的工作量评估超出预期等</li></ul><p>只有掌握了这些数据，才能科学地分析出问题的根源，并制定有针对性的应对措施。</p><h2 id="应对措施：流程、资源、工具"><a href="#应对措施：流程、资源、工具" class="headerlink" title="应对措施：流程、资源、工具"></a>应对措施：流程、资源、工具</h2><h3 id="1、优化流程与制度"><a href="#1、优化流程与制度" class="headerlink" title="1、优化流程与制度"></a>1、优化流程与制度</h3><p>流程和制度是保障项目顺利进行的关键。通过回顾过去的项目，尤其是那些曾暴露出问题的项目，我们可以识别出流程中的薄弱环节，并加以优化。此外，通过与同行分享经验，吸取教训，也能有效提升流和改进现有流程。</p><p>严格遵守公司流程，对公司来说可以减少很多低级错误的出现；对个人来说，是一种强有力的后盾，起到保护自己的作用。</p><h3 id="2、最佳实践"><a href="#2、最佳实践" class="headerlink" title="2、最佳实践"></a>2、最佳实践</h3><p>我们现在做的低代码平台进过这么多年的沉淀，能力变得越来越强，同时功能点也非常多，会导致达到同样一个目的会有很多种不同的路径。如果只是让项目经理或开发独自去完成，就有可能受限于他们的经验。</p><p>在长期的项目实践中，会积累了大量的经验和最佳实践。然而，在具体的项目中，由于个体经验的差异，可能导致不同的实现路径。如果缺乏集体讨论和经验分享，就可能错失效率提升的机会。因此，在项目需求调研后，进行一次集中讨论会，以确定最优的实现方案是非常必要的。</p><h3 id="3、改进项目管理模式"><a href="#3、改进项目管理模式" class="headerlink" title="3、改进项目管理模式"></a>3、改进项目管理模式</h3><p>举个例子：软件开发周期分为很多的步骤，有两个大的步骤是需求调研和代码开发。需求分析师调研完成后，形成需求文档，开发根据文档进行开发。这个过程看着就像是生产线上的两个环节，上下游直间定义好输入输出标准，就可以无缝对接。</p><p>按照上面的逻辑，一个部门专门和客户沟通，产出需求文档，一个部门专门做开发，是不是效率就高了呢？还真不一定，特别对于中小软件企业。</p><p>1、文档的颗粒度太粗，会导致沟通成本巨大，颗粒度太细，就会增加产出需求文档的时间成本，甚至出现开发等需求的情况。</p><p>2、对一些中小软件企业来说，一些不大的项目，项目经理、需求、开发、运维都是一个人就搞定了，分成多个部门后，小型项目也需要涉及到多人，效率是降低的。</p><p>所以说，现有的项目管理模式是否最优？是值得思考的一个问题。</p><h3 id="4、有效应对需求变更"><a href="#4、有效应对需求变更" class="headerlink" title="4、有效应对需求变更"></a>4、有效应对需求变更</h3><p>我一直以为客户不会故意为难我们，之所以我们感觉客户总是在进行变更。一个原因是没有解决用户的痛点问题。</p><blockquote><p>某项目的项目经理每天收集到很多的优化调整，项目经理按客户提出的逐一记录，并加班加点按时处理这些优化，最后却迟迟不能上线，因为客户领导最关注的一个页面没有完成。</p></blockquote><p>以这个例子来说，感觉上有很多的变更，但如果分清主次，把领导最关注的事情完成好，肯定是能顺利上线，至于业务提出的各种优化可能有很多是伪需求，是不需要处理的。</p><p>需求变更是项目过程中非常常见。我们需要明确客户的核心需求，避免在次要需求上浪费过多时间和资源。只有解决了用户的关键痛点，才能真正减少不必要的变更，提高项目上线效率。</p><h3 id="5、加强团队沟通与协作"><a href="#5、加强团队沟通与协作" class="headerlink" title="5、加强团队沟通与协作"></a>5、加强团队沟通与协作</h3><p>1、有的技术人员过于“独立思考”了，其实我认为独立思考和反馈、沟通是不冲突的。</p><p>2、团队成员平时都在忙于各个项目，如果团队或公司又没有组织团建活动，成员之间很多都不熟悉，在需要寻求帮助时，第一时间肯定是身边熟悉的人。</p><p>对此，有几个建议：</p><p>1、项目内部定期讨论会，听取团队成员的反馈和建议，再忙，一周一个小时总是能挤出来的。</p><p>2、不同项目之间可以定期分享，每个人在参与项目过程中总有自己的理解和感悟，分享出来对自己是一种锻炼，对其他人肯定也有帮助，再忙，一两个月半天时间总是有的，关键是能持续去做。</p><p>3、说服老板，多在工作日组织一些团建活动。</p><h3 id="6、工具化"><a href="#6、工具化" class="headerlink" title="6、工具化"></a>6、工具化</h3><p>当项目出现事故时，最终归因都是人的原因，是人的能力不行导致。整体效率不高也归因于人的能力。</p><p>一种简单的方式就是换人，还有一种方法就是工具化。很多时候，工具比人要稳定和可靠。</p><p>1、重复的、有规律可循的操作理论上都能工具化。我们的低代码平台在早期的时候，平台升级或发布应用时，部分操作需要手动执行 SQL。现在开发了专门的运维工具，里面包含应用发布、平台升级等功能，可以提升发布效率，也可以规避一些低级错误。</p><p>2、在项目实施过程中应该也有很多的场景可以进行工具化，来提升效率。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>人、公司在变、客户也在变，效率的提升我觉得是一个长期持续的事情，需要不断进行思考、发现问题、分析问题、找解决措施、实践。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在一个软件企业中，项目实施效率非常重要，它关乎企业的竞争力，影响项目交付的速度和质量，关系到企业的盈利能力，甚至决定着企业的生死。&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="思考" scheme="http://fwhyy.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>读《华为项目管理之道》</title>
    <link href="http://fwhyy.com/2024/08/read-the-way-of-huawei-project-management/"/>
    <id>http://fwhyy.com/2024/08/read-the-way-of-huawei-project-management/</id>
    <published>2024-08-07T00:11:47.000Z</published>
    <updated>2024-09-30T16:13:30.060Z</updated>
    
    <content type="html"><![CDATA[<p>在《软技能》一书中，提到将自己当作一个企业来思考，这其中的一个关键点就是要学会换位思考。做项目也是一样，需要换位思考，同时我们也能将很多事情都能理解为一个项目，例如：写系列文章、组织一次自驾游、产品开发等等，只不过这些项目的甲方可以是自己、家属、老板等。</p><span id="more"></span><p>不同类型的项目应该都能找到共同之处，在管理上也能采用相同的方法。最近读了《华为项目管理之道》，书中提到了很多的认知模型和能力模型 (比如：HEROS 模型、BEST 模型、SOBEST 模型等)，属于大而全，而我们只需要结合自身情况，灵活使用，不管对个人成长还是对管理项目，相信都能受益匪浅。</p><p>书中把项目的管理分为了八个大的章节，分别是：发展之道、交付之道、用将之道、治理之道、数智之道、文化之道、价值之道、未来之道。我结合书中的知识和自己的理解来谈谈项目管理。</p><h2 id="什么是软件项目？"><a href="#什么是软件项目？" class="headerlink" title="什么是软件项目？"></a>什么是软件项目？</h2><p>谈到项目一般会涉及甲乙双方，甲方的相关人提出诉求，乙方的以软件的形式进行交付，来满足甲方相关人的利益，给甲方带来价值。</p><p>这里面甲方的相关利益人叫干系人，乙方为了能交付软件，需要有一系列的角色和过程来确保项目的顺利进行。这就形成了项目的团队和管理制度。</p><p>其中甲方的干系人非常关键，在《有效需求分析》一书中也有大量的篇幅讲解干系人的重要性，这是项目是否能成功的一个很关键的因素。</p><h2 id="项目的目标"><a href="#项目的目标" class="headerlink" title="项目的目标"></a>项目的目标</h2><p>书中一直在强调项目存在的唯一价值就是坚定不移为客户创造价值，同时实现自己的价值。甚至有一个大的章节站门来阐述。</p><p>怎样来给客户带来价值？最重要的就是把控进度、提升质量。也就是书中提到的进度目标和质量目标。</p><ul><li>进度目标：任何一个项目都必须有明确的目标，有了明确的目标才能够制订清晰的项目计划，各项工作才能有序开展。</li><li>质量目标：项目质量目标包括可交付软件的质量、项目管理质量和客户满意度。</li></ul><p>举个例子：</p><p>一个核心业务系统对客户来说，稳定性是至关重要的。这时客户提出了新增和优化需求，当这些需求在新版本的产品中已经提供支持的时候，有两种选择：</p><p>1、将系统升级到最新的版本；</p><p>2、在原有版本中进行需求的开发。</p><p>第一直觉给出的方案通常是第二种，因为可以使用最新版本、后期可能会更容易维护、现阶段也能做更少的开发。</p><p>但如果目标是给客户提供价值，可以尝试提出一些问题？</p><ul><li>客户很关注系统是否是新版本吗？</li><li>除了客户提出的优化需求，新版本中其他的功能客户是否有兴趣？</li><li>新版本中 UI 的调整是否符合用户的习惯？</li><li>客户目前版本和最新版本是否存在较大差异？升级是否会带来不稳定？</li><li>升级是否能做到无缝？是否需要​更长时间的停机？</li></ul><p>好好思考这些问题，想想客户究竟需要什么？最终的答案可能还是升级到最新版本，但也能做到心里有底，知道这就是一个正确的方案。</p><h2 id="项目管理的流程"><a href="#项目管理的流程" class="headerlink" title="项目管理的流程"></a>项目管理的流程</h2><p>项目的流程通常分为：项目启动、项目规划、项目执行、项目监控、项目关闭。在书中谈到了在这整个周期内如何 「做正确的事、正确地做事、把事做正确」的典型模型、套路和方法，简称项目管理「十八般武艺」。</p><p>流程规范不是只在大公司适用，中小公司更应该进行规范，只是相比较大公司而言可以做适当的裁剪。而这恰恰是中小公司容易忽视的。小的乙方面对大的甲方，本来就处于弱势，而制定的这些流程规范就是在面对乙方时强有力的后盾。</p><p>所以说这十八般武艺非常值得参考和借鉴。</p><h2 id="项目管理的模式"><a href="#项目管理的模式" class="headerlink" title="项目管理的模式"></a>项目管理的模式</h2><p>项目管理模式有以前传统的瀑布型、也有后来流行的敏捷型，随着互联网的发展，低代码、零代码平台的兴起，管理模式变成了增量型。</p><p>比如：依靠 aPaaS 平台的能力快速构建出第一个版本，然后甲乙双方共同来完善系统，甲方在使用过程中可以不断提出优化点，乙方借助平台能力能够快速响应。最终以统计工作量的方式进行结算。</p><p>对甲方来说，前期可以快速上线进行验证，中期可以随时调整，以迭代的方式不断演进。这种方式可以更好地持续实现企业价值。</p><h2 id="需求优先级"><a href="#需求优先级" class="headerlink" title="需求优先级"></a>需求优先级</h2><p>客户想要的远比你能给的多的多。这时就需要分优先级了。书中介绍了项目需求管理的 BAS 分析：</p><ul><li>B（basic）：基本需求（核心业务功能和特性）</li><li>S（satisfied）：满意度需求（增值或附加业务）</li><li>A（attractive）：兴奋型需求（少数特定场景的需求）</li></ul><blockquote><p>在项目启动时，「人」和「事」是重中之重。干系人管理回答了「人」的问题，项目范围管理的对象就是「事」，它是对项目所期望的最终产品和可交付成果，以及为实现可交付成果所需的各项具体工作的简明描述。</p></blockquote><p>我觉得能把 B 做好就非常不容易了，所以需要按照 BSA 模型对需求进行分类排序，给该客户提交了分批次交付的计划。重点是需要能对需求进行识别，并按照 B、S、A 进行排序，分清主次。最怕的就是辛辛苦苦做了一堆功能，最后客户重点关注的功能却没有实现。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>书中的内容远不止上面谈到的这些，上面内容是一些印象深刻并且有共鸣的地方，可能一段时间后再翻翻这本书又会有新的感受。</p><p>好的书跟做项目一样，需要不断迭代，看完，写写笔记，一段时间后，再翻翻，再写写，这应该就是常读常新吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在《软技能》一书中，提到将自己当作一个企业来思考，这其中的一个关键点就是要学会换位思考。做项目也是一样，需要换位思考，同时我们也能将很多事情都能理解为一个项目，例如：写系列文章、组织一次自驾游、产品开发等等，只不过这些项目的甲方可以是自己、家属、老板等。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="项目管理" scheme="http://fwhyy.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    <category term="项目管理之道" scheme="http://fwhyy.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%B9%8B%E9%81%93/"/>
    
    <category term="华为" scheme="http://fwhyy.com/tags/%E5%8D%8E%E4%B8%BA/"/>
    
  </entry>
  
</feed>
