<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冯威的博客</title>
  
  <subtitle>公众号：不止dotNET | 临渊羡鱼不如退而结网</subtitle>
  <link href="http://fwhyy.com/atom.xml" rel="self"/>
  
  <link href="http://fwhyy.com/"/>
  <updated>2023-07-05T09:50:48.492Z</updated>
  <id>http://fwhyy.com/</id>
  
  <author>
    <name>oec2003</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>B 端软件：常见知识梳理</title>
    <link href="http://fwhyy.com/2023/07/b-end-software-common-knowledge-sorting/"/>
    <id>http://fwhyy.com/2023/07/b-end-software-common-knowledge-sorting/</id>
    <published>2023-07-05T09:49:40.000Z</published>
    <updated>2023-07-05T09:50:48.492Z</updated>
    
    <content type="html"><![CDATA[<p>我一直从事企业级软件研发工作，也就是我们通常称之为 B 端软件。近年来，我的工作重心主要在研发低代码平台和 aPaaS 平台，这使我对 B 端软件有了更深入的理解。</p><span id="more"></span><p>和 B 端软件对应的就是我们熟悉的 C 端软件，我们手机中安装的那些  APP  就属于此类。那么，他们之间的主要区别是什么呢？</p><p>最初始的印象是  B  端面向企业，而 C  端则面向个人。</p><p>最近我看到一个有趣的结论：</p><ul><li>C 端主要解决终端消费者的问题，需要耗费时间和金钱。例如抖音、淘宝、京东等应用程序。</li><li>B 端主要致力于赚钱和增加价值，解决组织的增值需求，即所谓的 「降本增效」。例如 OA 可以提高办公效率，低代码平台则可以提高软件交付效率。</li></ul><p>当然这种解释并不完全准确，因为 C 端也有很多学习类和效率提升类的软件。但是这样的解释可以帮助我们更快地理解它们之间的不同。</p><p>在接触 B 端软件慢慢深入后，发现有很多的维度和角度去看待  B  端软件。</p><h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>1、SaaS（Software as a Service）：软件即服务。SaaS 是一种让用户通过网络访问软件的模式。在这种模式下，软件被部署在云端，用户无需安装就可以使用。SaaS 提供商负责软件的维护和更新。</p><p>2、PaaS（Platform as a Service）：平台即服务。PaaS 提供了一个云端平台，让开发者可以在这个平台上开发、运行和管理应用程序。开发者无须关心底层基础设施，可以专注于应用开发。</p><p>3、IaaS（Infrastructure as a Service）：基础设施即服务。IaaS 提供了虚拟化的计算、存储和网络资源。用户可以按需购买资源，而无须投资购买硬件设备。IaaS 提供商负责基础设施的管理和维护。例如：阿里云的  OSS  服务。</p><p>关于这三者，曾经在播客中听一个大佬是这么类比的：</p><blockquote><p>SaaS ：凡是给一个账号和密码的，就可以认为是一个  SaaS  服务，就像住酒店，选择房型和时长，支付相应的费用，我们是客户，酒店提供  SaaS  服务。</p><p>PaaS：你盖一栋楼，按照酒店的规格装修好，租给他人去经营管理，你就是提供  PaaS  服务。</p><p>IaaS：你搞定水电缴费、蔬菜生鲜的供货、床单被套送洗，这就是在为酒店提供  IaaS  服务。</p></blockquote><p>除此之外，还有一种模式叫 aPaaS（Application Platform as a Service）：应用平台即服务。aPaaS 是 PaaS 的一种特殊形式，它提供了一个集成的开发、运行和管理应用程序的环境。用户可以在 aPaaS 平台上快速构建、部署和扩展应用程序。Gartner 对其所下的定义是：</p><blockquote><p>这是基于PaaS（平台即服务）的一种解决方案，支持应用程序在云端的开发、部署和运行，提供软件开发中的基础工具给用户，包括数据对象、权限管理、用户界面等。</p></blockquote><p>要确定一家平台是不是 aPaaS，只需要看该平台是否拥有开发应用系统的能力，能不能快速开发出一套软件系统。</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>1、个性化：记得早期做企业项目，全个性化定制，使用传统的瀑布模式开发：</p><ul><li>需求分析和客户的业务方沟通完需求，整理成需求文档；</li><li>进行高保正  UI  图的设计和技术层面的设计，找客户确认；</li><li>确认后进行开发、测试上线；</li><li>进入后期运维阶段。</li></ul><p>个性化定制的产品大多都是解决客户特定场景问题，无法进行复用，每一个新的客户进行项目落地，又需要重头开始，导致成本高、收益低。</p><p>2、垂直化：想要让边际成本比较低，就需要从个性中找共性，所以就出现了泛微、蓝凌、致远的  OA  办公软件；金蝶、用友的财务、人力资源软件；明源的房地产软件等。</p><p>垂直化的商业软件对于中小公司可以开箱即用，对于大型企业客户来说也需要一定的个性化定制和改造才能上线使用。这里的定制和第一阶段的个性化定制就是两个层面的东西了。</p><p>3、多样化：随着  B  端软件越来越成熟，企业信息化建设越来越完善，B  端软件越来越丰富和多样，从只支持  PC  端访问到支持多终端使用；从支持单机部署到分布式、容器化、SaaS 模式；从解决某一个特定场景问题到多领域发展，例如：泛微现在不单单只是一个  OA  系统了。</p><p>4、集成化：功能虽然在不断增强和扩展，但不可能把所有事情都做了，需要的是将擅长的事情发挥到极致。要完成更大的业务目标就需要进行集成和连接，只要涉及到这些方面：</p><ul><li>获取第三方系统的数据进行展示。</li><li>业务上有需要和第三方系统进行数据传递和交互。</li><li>特定的功能需要对接专有软件或服务，例如：电子签章、Office  文档编辑、查询企业信息、地图显示等。</li></ul><p>现在的一些  aPaaS  平台基本都具备各种集成的能力。</p><p>5、平台化：制定标准和规范，让更多的  ISV（独立软件开发商）能在平台上进行软件开发，或者让一些软件厂商能将自己产品和平台进行适配，当入驻的软件越多，平台的能力就越强，最终打造一个软件的生态。例如钉钉和企业微信的应用中心。</p><h2 id="运维角度"><a href="#运维角度" class="headerlink" title="运维角度"></a>运维角度</h2><p>从运维部署的角度来看，B  端软件可以分为公有云、私有云、混合云三种方式。</p><p>1、公有云：公有云是指第三方服务提供商（如 AWS、阿里云、华为云等）提供的云计算资源和服务。在这种情况下，企业不需要购买和维护自己的硬件和基础设施，而是根据使用情况付费。公有云的优点包括快速部署、按需付费和弹性扩展。</p><p>2、私有云：私有云是指企业内部建立和维护的云计算环境。企业可以在自己的数据中心内部署私有云，或者托管在第三方数据中心。私有云的优点包括更高的安全性、更好的性能和更强的定制能力。</p><p>3、混合云：混合云是公有云和私有云的结合，企业可以根据业务需求和安全性要求灵活地在两者之间切换。这种部署方式兼具公有云的灵活性和私有云的安全性，使企业能够将敏感数据放在私有云中，而将其他可扩展的工作负载放在公有云中。</p><p>现在，国产化是一种趋势，符合信创要求也属于常规操作了，所以产品除了能在不同的云进行部署外，还需要能适配各类国产服务器、数据库、中间件。</p><h2 id="业务划分"><a href="#业务划分" class="headerlink" title="业务划分"></a>业务划分</h2><p>如果你刚刚接触  B  端软件，在各种会议沟通中，可能经常会听到一些业务名词，比如  OA、ERP  等，下面列举些常见的业务系统：</p><p>1、OA （ Office Automation）：办公自动化。它是指通过计算机技术和通讯技术来提高办公效率，实现办公信息化、网络化、智能化的一系列技术和管理手段。常见功能有：即时通讯、日程安排、文档管理、协同办公、流程管理、知识管理、任务管理等。例如：泛微、蓝凌、致远。</p><p>2、ERP（Enterprise Resource Planning）：企业资源规划。ERP 系统是一种集成的管理信息系统，它可以帮助企业管理生产、采购、销售、财务等业务流程。例如：SAP。</p><p>3、CRM（Customer Relationship Management）：客户关系管理。CRM 系统用于管理企业与客户之间的关系，包括客户信息管理、销售线索、线索跟进、市场营销等功能。例如：纷享销客、销售易。</p><p>4、MES（Manufacturing Execution System）：制造执行系统。MES系统主要用于生产过程的实时监控和调度，以提高生产效率和产品质量。</p><p>5、WMS （Warehouse Management System）：仓库管理系统。WMS系统是一种用于管理仓库物流和库存的软件系统，包括入库、出库、库存管理、库存盘点等方面的管理。</p><p>6、SRM（Supplier Relationship Management）：供应商关系管理。SRM系统帮助企业管理与供应商的关系，包括供应商信息管理、采购管理、供应链协同等功能。例如：企企通。</p><p>7、HCM（Human Capital Management）：人力资本管理。HCM系统用于管理企业的人力资源，包括招聘、培训、绩效评估等功能。</p><p>8、SCM（Supply Chain Management）：供应链管理。SCM系统用于管理企业的供应链活动，包括物流、库存管理、需求预测等功能。</p><p>9、PLM（Product Lifecycle Management）：产品生命周期管理。PLM系统用于管理产品从设计到退役的整个生命周期，包括产品设计、生产、维护等环节。</p><p>10、EAM（Enterprise Asset Management）：企业资产管理。EAM系统用于管理企业的固定资产，包括资产登记、维护、报废等功能。</p><p>11、BI（Business Intelligence）：商业智能。BI系统用于收集、分析和呈现企业数据，帮助企业进行决策支持和战略规划。例如：帆软、思迈特、海致等。</p><p>12、BPM（Business Process Management）：业务流程管理。BPM 系统用于对企业的业务流程进行管理和优化，以提高企业的运营效率和灵活性。</p><p>13、DMS（Document Management System）：文档管理系统。DMS 系统用于管理企业的电子文档，包括文档存储、检索、版本控制等功能。</p><p>14、MDM（Master Data Management）：主数据管理。MDM 系统用于管理企业的主数据，如客户、产品、供应商、物料等核心数据，确保数据的准确性和一致性。</p><p>15、ITSM（IT Service Management）：IT服务管理。ITSM 系统用于管理企业的IT服务，包括服务台、事件管理、配置管理等功能。</p><p>16、电子签约：电子签约系统是一种基于互联网技术的合同签署方式，它通过数字化、网络化的方式，使得双方可以在不同的地点、不同的时间完成合同签署，从而提高合同签署的效率和便捷性。例如：E 签宝、金格、法大大、契约锁等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我一直从事企业级软件研发工作，也就是我们通常称之为 B 端软件。近年来，我的工作重心主要在研发低代码平台和 aPaaS 平台，这使我对 B 端软件有了更深入的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="产品" scheme="http://fwhyy.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="B 端软件" scheme="http://fwhyy.com/tags/b-%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Logseq：使用一年的感受</title>
    <link href="http://fwhyy.com/2023/06/the-feeling-of-using-logseq-for-a-year/"/>
    <id>http://fwhyy.com/2023/06/the-feeling-of-using-logseq-for-a-year/</id>
    <published>2023-06-27T02:45:05.000Z</published>
    <updated>2023-06-28T02:46:14.879Z</updated>
    
    <content type="html"><![CDATA[<p>去年  6  月  20 号写了一篇《Obsidian 初体验》，也就是从那时起，开始使用  Obsidian，随后不久，知道了  Logseq  这款软件，就同时使用 Obsidian 和 Logseq 。</p><span id="more"></span><p>如今，一年过去了，更早使用的 Obsidian 现在打开次数越来越少，而 Logseq 已经成为日常重度使用的工具之一。</p><h2 id="为什么喜欢-Logseq"><a href="#为什么喜欢-Logseq" class="headerlink" title="为什么喜欢 Logseq"></a>为什么喜欢 Logseq</h2><h3 id="丝滑的日志功能"><a href="#丝滑的日志功能" class="headerlink" title="丝滑的日志功能"></a>丝滑的日志功能</h3><p>最开始使用  Logseq  是因为日志功能，每天一打开  Logseq，就会自动有一个当前日期的页面（一个  md  文件），也就是说打开就能输入。</p><p>Obsidian  也有日志功能，但需要在左边的工具条中点击「打开/创建今天的日记」进行创建，就这么一个细小的区别，让我对  Logseq  的使用率大大提升。</p><p>另外，虽然日志是每天一个页面，但在  Logseq  中，日志功能模块是将所有日期的日志串起来，鼠标滚动就可以进行查看，这也比  Obsidian  要方便很多。</p><h3 id="丰富的展示"><a href="#丰富的展示" class="headerlink" title="丰富的展示"></a>丰富的展示</h3><p>在  Logseq  中，我们可以使用  Markdown  语法，比如标题、加粗、斜体、链接、图片、代码、数学公式等。</p><p>但  Logseq  也有自己个性化的展现：</p><p>1、整体为大纲模式，就是一个<strong>无序列表</strong>，类似幕布、workflowy。这种模式特别适合记录日常琐碎的事项。</p><p>2、使用  NOW、TODO、SCHEDULED、Linked References  等会在页面中产生独立的展现样式。</p><p>而在  Obsidian  中是严格遵循  Markdown  语法，更适合长文编辑和预览。</p><h3 id="颗粒度更小"><a href="#颗粒度更小" class="headerlink" title="颗粒度更小"></a>颗粒度更小</h3><p>在  Obsidian  中页面是最小单位，双链也是在页面和页面之间进行链接。Logseq  是大纲模式（无序列表），列表的每一项就是一个块，块可以被单独引用：</p><ul><li>右键列表项前面的小圆点，选择「复制块引用」，然后粘贴到想要引用的地方即可，这种引用方式只会显示第一行，鼠标放到引用上面可以预览内容，点击可以跳转到对应的块里。</li><li>右键列表项前面的小圆点，选择「复制内嵌块」，然后粘贴到想要引用的地方即可，相比于引用，能看到整个块的内容。修改引用位置的块，原来的块也会同步修改。</li><li>块中可以使用 [[]] 进行页面的引用，在页面中也可以引用块。</li><li>被引用的块所在行的后面会有引用次数的显示，点击数字，直接在下方按照时间顺序展示引用的内容。</li></ul><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>和  Obsidian  一样 ，Logseq  也是采用本地存储的方式。是否支持笔记存储现在已经成为了我选择笔记工具的首要条件了。</p><p>本地存储文件，非常有安全感，我现在是  iCloud  和  GitHub  双备份，iCloud  还可以实现移动端和  PC  端的同步。</p><h2 id="后续新发现"><a href="#后续新发现" class="headerlink" title="后续新发现"></a>后续新发现</h2><p>就因为一个日志的功能，我就从  Obsidian  迁移到了  Logseq 。随着慢慢深入地使用，又发现：</p><p>1、双链后，Logseq  会在页面的  Linked References 中直接展示内容，而 Obsidian 需要在右侧栏中进行查看。</p><p>2、在  Logseq 中，标签也是一个页面，点击某个标签会进入到这个标签对应的页面，在该页面中以时间顺序展现所有打过此标签的内容，而  Obsidian  中的  tag  只是一种搜索方式，结果以标题列表的形式展现，如果要看内容，还需要对标题进行逐个点击。</p><p>3、通过魔法棒 / 可以呼出 TODO、DOING、LATER、NOW、Deadline、Scheduled  等功能，再结合 logseq-plugin-agenda  插件，可以实现一个功能还不错的日程管理工具。</p><p>4、可以在  Logseq  中阅读  PDF  文件，左边是  PDF  内容，右边记录笔记，非常方便。</p><p>5、支持  query  语法，可以将 TODO、DOING、DONE  这些不同类型的数据在一个页面中进行分类汇总。</p><p>6、我是 readwise reader  的付费用户，readwise 可以实现和  Obsidian 、Logseq  的同步，起初配置了  Obsidian ，会同步到一个单独的  Readwise  目录中，不过这个目录几乎没有打开过。后来尝试了下  Logseq ，发现 readwise  中新增的内容会同步到当天的日志，显示在 Linked References 中，非常方便进行二次加工和处理，简直是惊喜。</p><h2 id="备受争议的文件夹"><a href="#备受争议的文件夹" class="headerlink" title="备受争议的文件夹"></a>备受争议的文件夹</h2><p>我们使用的很多笔记软件：语雀、Obsidian、印象笔记等都是支持文件夹的，似乎使用文件夹来组织内容已经成为了一种习惯，但在  Logseq  中没有文件夹，这让很多使用者不太适应，在  Logseq  的论坛中经常有人发帖强烈要求添加文件夹功能。</p><p>而我，选择  Logseq，其中一个原因就是不支持文件夹。</p><p>我的理由是：</p><p>1、目前  tag 、目录、搜索配合使用，已经完全可以满足分类管理的需求。</p><p>2、文件夹体系中，页面是最小的单位，而  Logseq  中块是最小单位。</p><p>3、文件夹会改变我们的思维方式，有文件夹，会先考虑写的内容放到那个文件夹，这个考虑会变成一种阻碍。</p><p>4、从产品架构设计层面来说，增加文件夹，可能会修改产品的存储数据的方式和检索方式，可能我最看重的本地存储就会消失了。思源笔记在  1.2  版本后就将  md  格式修改为了特定的数据格式，也因此丢失了一部分用户。</p><h2 id="使用到的插件"><a href="#使用到的插件" class="headerlink" title="使用到的插件"></a>使用到的插件</h2><p>1、Agenda：UI  美观、功能强大的日程管理工具。</p><p>2、Heatmap：热力图显示，跟  Github 类似。</p><p>3、Bullet Threading：大纲结构的数据存在父子级关系，用线连接块的父子级，让结构更加鲜明。</p><p>4、Tabs：方便打开多页面时的切换。</p><p>5、Tags：可以根据  Tag  名称进行搜索。</p><p>6、Logseq Markmap：可以根据页面和块生成思维导图，并可以保存为图片。</p><h2 id="对知识管理的思考"><a href="#对知识管理的思考" class="headerlink" title="对知识管理的思考"></a>对知识管理的思考</h2><p>知识管理大体上可以分收集、处理、输出三步。信息收集有很多种方式，上面提到的  readwrise reader  就是其中一种。readwise  可以很好的和  Logseq  进行同步。</p><p>中间的处理完全可以在  Logseq  中完成，处理数据的来源之一就是  readwise 。</p><p>输出就比较简单了，使用 Obsidian 、Typora 都可以。</p><p>最近在看知识管理理论 PARA ，正在尝试在  Logseq  中进行实践，后面单独开篇来写。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文是一些使用的体验和想法，没有截图，更适合使用过  Logseq 这款工具的同学阅读。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;去年  6  月  20 号写了一篇《Obsidian 初体验》，也就是从那时起，开始使用  Obsidian，随后不久，知道了  Logseq  这款软件，就同时使用 Obsidian 和 Logseq 。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="效率" scheme="http://fwhyy.com/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Logseq" scheme="http://fwhyy.com/tags/logseq/"/>
    
  </entry>
  
  <entry>
    <title>内驱力</title>
    <link href="http://fwhyy.com/2023/06/talk-about-drive/"/>
    <id>http://fwhyy.com/2023/06/talk-about-drive/</id>
    <published>2023-06-19T01:25:55.000Z</published>
    <updated>2023-06-19T06:27:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>最近在群里看到周筠老师征集小孩教育相关的问题，我第一个想到的问题就是：如何让孩子变得有内驱力？</p><span id="more"></span><p>不光是小孩教育，个人成长、团队管理都存在内驱力的问题。</p><p>内驱力是什么?</p><p>内驱力是指我们做某件事是因为这件事情本身，从个人内在的、自我发起的动力，而不是因为外部的奖惩。例如：</p><ul><li>周末约朋友一起去打球，是因为喜欢打球本身，这是内驱力在起作用；</li><li>员工因为怕扣  KPI  而加班干活，这是外驱力所带来的结果。</li></ul><p>下面谈谈对小孩教育、个人成长和团队管理的自驱力的一些思考。</p><h2 id="小孩教育"><a href="#小孩教育" class="headerlink" title="小孩教育"></a>小孩教育</h2><p>记得我小时候，经常听到家长在耳边说：“要转变思想，将要我学变成我要学”，当时理解不了，还是该玩玩，该闹闹。现在就变成了我对女儿说这些话了，同样，女儿也理解不了。</p><p>小学阶段课程少、内容相对简单，家长只要有监督，耐心对作业进行辅导，小孩成绩不会很差，但如果没能养成一个好的学习习惯，到初中、高中就会被拉下。</p><p>之前看到过一个  UP  主讲，小学六年就是用来培养孩子的学习习惯，不用太在意考试的分数。我觉得很有道理，这里的学习习惯就是有自主学习的意识和好的学习方法。</p><p>我们希望和孩子之间平等地沟通、交流，但我们和孩子的经历、认知是存在很大差异的，我们认为很简单的道理和正确的行动指南，孩子不会去践行，甚至会反抗。</p><p>奖励和惩罚应该是我们常用的手段，例如：女儿的画画班有暑期的北京游学活动，女儿非常想去，我们可以用这个作为她期末考试结果的奖励，可能为了得到这个奖励，女儿会很认真对待学习一阵子，但如果某一天，她不想去北京了，学习的兴致也会没了。</p><p>李松蔚在得到的《心理学通识》课程中提到：</p><blockquote><p>1、奖励有可能弱化一个人的内部动机。</p><p>2、并不是说不能奖励，但要在动机上强调内驱，在物质上给予回报。</p><p>3、给一个行为设置适度的障碍，反而更有助于发挥自己的内驱力。</p></blockquote><p>有意识的让孩子多运动、多阅读，对养成好的学习习惯也会有正向的促进作用，有一本书就叫《培养孩子从跑步开始》，最近准备看看。</p><p>现在培养女儿仍然在不断摸索和实践中，但没那么焦虑了，离小学毕业还有 3 年，三年养成一个习惯时间上来说，应该足够了。</p><h2 id="个人成长"><a href="#个人成长" class="headerlink" title="个人成长"></a>个人成长</h2><p>在同事眼中，我算是一个比较自律的人，能坚持早起、坚持跑步、虽然文笔不好，也能坚持输出点文字。</p><p>这些都是因为内驱力导致的吗？也不尽然。很多时候也会使用奖励、倒逼等各种方法。</p><p>拿跑步来说，很长一段时间，我享受跑完后大汗淋漓的畅快，但跑步的过程没有觉得很愉悦，最后分析原因，可能是过于追求配速，导致大量出汗的同时也非常累。</p><p>今年  5  月后，气温逐渐升高，我改变了跑步的方法，只管心率，不管配速，将心率控制在了  140  左右，有时碰到 30  多度的气温，天气闷热，也跑得很舒服。就这一个小小的改变，这个夏天的跑量我不担心了。</p><p>最近在看一本书：《行为设计学：零成本改变》，书中最后一个部分介绍通过营造路径来进行改变。我跑步将关注配速调整为关注心率，其实就是营造了一条新的路径，让跑步变得愉悦了，有想去跑的冲动了。</p><h2 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h2><p>德鲁克说过：“管理是最大程度地激发他人的善意”。这个善意是指激发员工的成长性思维，提升每个人的内驱力，让每个人看问题能更长远，而不是只顾眼前利益。</p><p>团队中每个人的个人成长、工作经历、兴趣爱好都不同，看待问题的方式、自身的需求也会不一样，不能用同一套方法对待每个人。</p><p>胡萝卜加大棒可能是很多团队中的管理方法，就是通过  KPI  制定奖惩机制。但无论是奖励还是惩罚，最大的特点或者说是缺点，都是来自外部刺激。人对外部刺激的应对机制是增强免疫力，用多了就没效果了。</p><p>但即便是胡萝卜加大棒的模式下，也要讲究方式方法：</p><p>1、具体化：不管是奖励还是惩罚，需要具体，不要说表现不错、进步很大这种模糊的评价，只有具体化才能让每个人知道方向和目标；</p><p>2、公开化： 拿奖励来说，被奖励的人会受到更大的激励，同时也会让其他同学知道什么样的行为是正确的、被认可的；</p><p>3、及时性：发生事情后，需要立马作出奖励或惩罚的反馈，这样效果会更好，否则一段时间后，再拿出来说，都没啥感觉了。</p><p>上面的模式终究会失效，因为奖励会弱化一个人的内部动机嘛。所以更重要的是让每个员工有内驱力，我相信团队每个人都是想进步，想要去提升自己的能力。当然，也可能有那种混日子的，就不在讨论范围了。</p><p>那怎样能激发团队成员的积极性呢？</p><p>1、做感兴趣的事。最近制作产品宣传视频，这本来不属于产品经理的事情，但和我们团队的一位产品经理沟通后，表示愿意尝试，因为对产品理解比较深刻，也对视频制作有兴趣，周末还主动在家进行剪辑和调整。最后效果得到大家一致称赞，我想这就是兴趣导致的内驱力。</p><p>2、提升专精度。前些年有一次年终一对一沟通，有一位同学说，平时安排的工作过于简单，没有挑战，觉得很没意思。当团队成员的能力提升后，工作安排也需要与之匹配。而且还要根据每个人的兴趣进行培养，让每个人都能变得更专业，成为某个领域的专家，这样就会带来更大的满足感和更大的动力。</p><p>3、意义和使命。举个简单例子：安排给开发的任务不能只是这个做个列表，那里加个按钮，需要强调这些功能背后的逻辑、业务背景，以及能给客户带来什么样的利益，这样工作的意义和价值才能体现。 </p><p>4、放权。适当放权，让每个人有更多的自主权，而不是在被动的做事。参与感越强，做事的动力就越大。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在群里看到周筠老师征集小孩教育相关的问题，我第一个想到的问题就是：如何让孩子变得有内驱力？&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="成长" scheme="http://fwhyy.com/tags/%E6%88%90%E9%95%BF/"/>
    
    <category term="内驱力" scheme="http://fwhyy.com/tags/%E5%86%85%E9%A9%B1%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>银河麒麟系统安装中间件</title>
    <link href="http://fwhyy.com/2023/06/galaxy-kirin-system-installation-middleware/"/>
    <id>http://fwhyy.com/2023/06/galaxy-kirin-system-installation-middleware/</id>
    <published>2023-06-12T01:24:01.000Z</published>
    <updated>2023-06-19T22:36:33.862Z</updated>
    
    <content type="html"><![CDATA[<p>现在越来越多的企业级应用需要运行在国产化环境中，本文介绍下我们产品使用的中间件在国产操作系统银河麒麟的安装（不一定是最优方式，但能用）。</p><span id="more"></span><p>包含；Nginx、Redis、RabbitMQ、MongoDB、dotNETCore。</p><p>下图是银河麒麟服务器的信息：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191424224.webp"></p><p>想要顺利安装需要确保：</p><p>1、服务器能访问网络，完全离线的方式安装会更复杂，需要进一步研究；</p><p>2、修改  yum  源。</p><p>使用  <code>vi  /etc/yum.repos.d/kylin_aarch64.repo</code> 来设置  yum  源，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##Kylin Linux Advanced Server 10 - os repo###</span></span></span><br><span class="line"></span><br><span class="line">[ks10-adv-os]</span><br><span class="line">name = Kylin Linux Advanced Server 10 - Os</span><br><span class="line">baseurl = https://update.cs2c.com.cn/NS/V10/V10SP3/os/adv/lic/base/$basearch/</span><br><span class="line">gpgcheck = 1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-kylin</span><br><span class="line">enabled = 1</span><br><span class="line"></span><br><span class="line">[ks10-adv-updates]</span><br><span class="line">name = Kylin Linux Advanced Server 10 - Updates</span><br><span class="line">baseurl = https://update.cs2c.com.cn/NS/V10/V10SP3/os/adv/lic/updates/$basearch/</span><br><span class="line">gpgcheck = 1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-kylin</span><br><span class="line">enabled = 1</span><br><span class="line"></span><br><span class="line">[ks10-adv-addons]</span><br><span class="line">name = Kylin Linux Advanced Server 10 - Addons</span><br><span class="line">baseurl = https://update.cs2c.com.cn/NS/V10/V10SP3/os/adv/lic/addons/$basearch/</span><br><span class="line">gpgcheck = 1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-kylin</span><br><span class="line">enabled = 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>先执行下面命令安装依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc gcc-c++ make unzip pcre pcre-devel zlib zlib-devel libxml2 libxml2-devel  readline readline-devel ncurses ncurses-devel perl-devel perl-ExtUtils-Embed openssl-devel -y</span><br></pre></td></tr></table></figure><p>下载源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -c http://nginx.org/download/nginx-1.20.1.tar.gz</span><br><span class="line">tar -zxvf  nginx-1.20.1.tar.gz -C /opt</span><br><span class="line">cd  /opt/nginx-1.20.1/</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">--with-http_ssl_module \</span><br><span class="line">--with-http_flv_module \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_gzip_static_module \</span><br><span class="line">--with-pcre</span><br></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j2 &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>进入 /usr/local/nginx/sbin/ 目录，执行下面命令启动服务： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>执行<code>ps -ef | grep nginx</code> 查看 nginx 进程：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191424692.webp"></p><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>安装依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install cpp binutils glibc glibc-kernheaders glibc-common glibc-devel -y</span><br></pre></td></tr></table></figure><p>下载源码和：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://download.redis.io/releases/redis-6.0.2.tar.gz</span><br><span class="line">tar -zxvf redis-6.0.2.tar.gz -C /opt</span><br></pre></td></tr></table></figure><p>编译安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/redis-6.0.2</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs </span><br><span class="line">nohup /opt/redis-6.0.2/src/redis-server /opt/redis-6.0.2/redis.conf &gt;&gt; /opt/redis-6.0.2/logs/redis.log  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ  的安装比较简单，执行几个命令就行。</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install socat logrotate -y</span><br><span class="line">yum -y install erlang -y</span><br><span class="line">yum -y install rabbitmq-server</span><br></pre></td></tr></table></figure><p>启动服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable rabbitmq-server</span><br><span class="line">systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure><p>如果想要使用浏览器访问  RabbitMQ 的管理界面，需要启用插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><p>插件启用后，就可以在浏览器中输入：htp://ip:15672 进行访问了，15672  端口需要在防火墙进行开放。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>因为上面的中间件已经安装了部分依赖，所以执行下面命令安装剩余依赖即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install libcurl-devel openssl libxml2-devel libxml2 glibc-static libstdc++-static libffi-devel</span><br></pre></td></tr></table></figure><h3 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装  Python"></a>安装  Python</h3><p>Python  安装的是  2.x  版本，因为这里  MongoDB  使用的是  3.6.19  版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://www.python.org/ftp/python/2.7.17/Python-2.7.17.tgz</span><br><span class="line">tar -zxvf Python-2.7.17.tgz</span><br><span class="line">cd Python-2.7.17</span><br><span class="line">./configure --prefix=/usr/local/python2</span><br><span class="line">make -j64</span><br><span class="line">make install</span><br><span class="line">ln -s /usr/local/python2/bin/python2.7 /usr/local/bin/python2.7</span><br></pre></td></tr></table></figure><h3 id="安装-setuptools-工具"><a href="#安装-setuptools-工具" class="headerlink" title="安装 setuptools 工具"></a>安装 setuptools 工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/pypa/setuptools/archive/v41.0.1.zip</span><br><span class="line">unzip setuptools-v41.0.1.zip</span><br><span class="line">cd setuptools-41.0.1</span><br><span class="line">/usr/local/bin/python2.7 bootstrap.py</span><br><span class="line">/usr/local/bin/python2.7 setup.py install</span><br></pre></td></tr></table></figure><h3 id="安装-pip-工具"><a href="#安装-pip-工具" class="headerlink" title="安装 pip  工具"></a>安装 pip  工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/pypa/pip/archive/19.2.2.tar.gz</span><br><span class="line">tar zxvf pip-19.2.2.tar.gz</span><br><span class="line">cd pip-19.2.2</span><br><span class="line">/usr/local/bin/python2.7 setup.py install</span><br></pre></td></tr></table></figure><h3 id="安装-mongo"><a href="#安装-mongo" class="headerlink" title="安装  mongo"></a>安装  mongo</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/mongodb/mongo/archive/r3.6.19.tar.gz</span><br><span class="line">tar -zxvf mongo-r3.6.19.tar.gz</span><br><span class="line">cd mongo-r3.6.19</span><br><span class="line"><span class="meta">#</span><span class="bash">构建编译环境</span></span><br><span class="line">/usr/local/python2/bin/pip2 install -r buildscripts/requirements.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建数据目录</span></span><br><span class="line">mkdir -p /data/db</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">/usr/local/bin/python2.7 buildscripts/scons.py --prefix=/opt/mongo install MONGO_VERSION=3.6.19 CCFLAGS=&quot;-march=armv8-a+crc&quot; --disable-warnings-as-errors --variables-files=etc/scons/propagate_shell_environment.vars</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">创建软连接</span></span><br><span class="line">ln -s /opt/mongo/bin/mongo /usr/local/bin/mongo</span><br><span class="line">ln -s /opt/mongo/bin/mongod /usr/local/bin/mongod</span><br></pre></td></tr></table></figure><ul><li>–prefix=/opt/mongo 为安装目录</li></ul><p>执行上面命令如果没有出现任何错误，就安装成功了，执行下面命令进行服务端的后端启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup mongod &gt;&gt; /opt/mongo/logs/mongolog 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h2 id="dotNETCore-3-1"><a href="#dotNETCore-3-1" class="headerlink" title="dotNETCore 3.1"></a>dotNETCore 3.1</h2><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gmp-devel mpfr-devel libmpc-devel -y</span><br></pre></td></tr></table></figure><p>执行下面命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.visualstudio.microsoft.com/download/pr/186257d9-bca2-4dda-be74-006205965ec9/b2b63d45482701473d9731abc41ecc2a/dotnet-sdk-3.1.426-linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line">mkdir -p /opt/dotnet</span><br><span class="line">tar -zxvf dotnet-sdk-3.1.426-linux-arm64.tar.gz -C /opt/dotnet</span><br><span class="line"></span><br><span class="line">ln -s /opt/dotnet/dotnet /usr/bin</span><br><span class="line">export DOTNET_ROOT=/opt/dotnet</span><br><span class="line">export PATH=$PATH:/opt/dotnet</span><br></pre></td></tr></table></figure><p> 执行命令  dotnet –info 进行验证，出现下面结果表示安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.NET Core SDK (reflecting any global.json):</span><br><span class="line"> Version:   3.1.426</span><br><span class="line"> Commit:    e81f6c8565</span><br><span class="line"></span><br><span class="line">Runtime Environment:</span><br><span class="line"> OS Name:     kylin</span><br><span class="line"> OS Version:  V10</span><br><span class="line"> OS Platform: Linux</span><br><span class="line"> RID:         linux-arm64</span><br><span class="line"> Base Path:   /opt/dotnet/sdk/3.1.426/</span><br><span class="line"></span><br><span class="line">Host (useful for support):</span><br><span class="line">  Version: 3.1.32</span><br><span class="line">  Commit:  f94bb2c3ff</span><br><span class="line"></span><br><span class="line">.NET Core SDKs installed:</span><br><span class="line">  3.1.426 [/opt/dotnet/sdk]</span><br><span class="line"></span><br><span class="line">.NET Core runtimes installed:</span><br><span class="line">  Microsoft.AspNetCore.App 3.1.32 [/opt/dotnet/shared/Microsoft.AspNetCore.App]</span><br><span class="line">  Microsoft.NETCore.App 3.1.32 [/opt/dotnet/shared/Microsoft.NETCore.App]</span><br><span class="line"></span><br><span class="line">To install additional .NET Core runtimes or SDKs:</span><br><span class="line">  https://aka.ms/dotnet-download</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在越来越多的企业级应用需要运行在国产化环境中，本文介绍下我们产品使用的中间件在国产操作系统银河麒麟的安装（不一定是最优方式，但能用）。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="中间件" scheme="http://fwhyy.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="国产化" scheme="http://fwhyy.com/tags/%E5%9B%BD%E4%BA%A7%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>五月读的四本书</title>
    <link href="http://fwhyy.com/2023/05/four-books-read-in-may/"/>
    <id>http://fwhyy.com/2023/05/four-books-read-in-may/</id>
    <published>2023-05-29T06:21:44.000Z</published>
    <updated>2023-06-19T08:57:28.041Z</updated>
    
    <content type="html"><![CDATA[<p>我读书很慢，读书慢不是因为读的很认真仔细，而是读书太少，也就是阅读量不够，量不够，质就难以发生变化，跑步如此，读书也是。</p><span id="more"></span><p>没有足够的阅读量，不光是读不快，有可能根本就读不进去，所以碰到一本书发现很难读，不是书不好，很可能是自己的积累不够，这时需要停下来，等有了足够积累再继续读。</p><p>所以现在看书方式有些调整：</p><ul><li>技术书籍看偏底层、经典的书籍，不用担心看的时间长，目的是理解、吃透。比如《凤凰架构》、《数据密集型应用系统设计》等。</li><li>技术书籍，主要看纸质书，如果是电子版，就会在电脑上看，方便记录笔记和查阅资料。</li><li>非技术书籍分为两类：办公室有一个书架，上面陈列着一些待读的纸质书，早、中、晚都可以看。</li><li>另一类就是微信读书和得到这类电子书了，利用碎片时间一两周也能看完一本。</li></ul><p>非技术书籍看什么？</p><p>自从在小宇宙上关注了《银杏树下》和《文化有限》后，就不愁不知道看什么书了，节目中讲的书在微信读书上有的就看电子版，没有的就在多抓鱼上淘。节目的推荐给了我一个范围，具体决定看那本还是要试看，看是否对我有吸引力，有吸引力的标准也很简单，当合上书时，是否有再次打开去阅读的欲望。</p><p>因为这种改变，读书的效率提升了不少，五月居然读完了四本，看到豆瓣的记录后，我也很惊讶。下面简单谈谈五月读的这几本书吧。</p><h2 id="你的懒惰让我愁肠百结"><a href="#你的懒惰让我愁肠百结" class="headerlink" title="你的懒惰让我愁肠百结"></a>你的懒惰让我愁肠百结</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191422616.webp"></p><p>如果你不知道菲茨杰拉德，但一定听过他写的《了不起的盖茨比》。你的懒惰让我愁肠百结是作者在女儿的成长期写给女儿信的合集。</p><p>这本书看完最大的感受就是释然了，因为我也有一个  9  岁的女儿，在成长路上遇到了各种问题。谁曾想，这些问题在大作家的孩子身上也都存在。让我们看到了大作家的另一面，面对女儿的教育，也会苦口婆心、啰啰嗦嗦。</p><p>简单摘录几个片段：</p><p>女儿乱花钱的时候，会说：</p><blockquote><p>老这么管束你，我也非常厌烦，很多时候我甚至已经不在乎你会不会好好学习。我一边跟你争执，一边还得尽量令你生活舒适—— 这根本违反人性。我宁愿买辆新车。</p></blockquote><p>成绩也是关注的重点：</p><blockquote><p>你的自由完全取决于你的成绩</p></blockquote><p>为了培养女儿的良好习惯：</p><blockquote><p>如果你在一个礼拜里，每次用完一样东西，就立刻把它放回原位，而不是等用完三样东西再一起收拾，我想不出一个月，你就会养成习惯。</p></blockquote><p>树立正确的价值观：</p><blockquote><p>别为自己的小说不够拔尖而灰心丧气。同时，在这件事情上我也不打算鼓励你。毕竟，你若想跻身一流就得自己克服障碍，从实践中获取经验。没人能单凭发愿就能当上作家。</p></blockquote><h2 id="夜晚的潜水艇"><a href="#夜晚的潜水艇" class="headerlink" title="夜晚的潜水艇"></a>夜晚的潜水艇</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191422075.webp"></p><p>90 后作家陈春成的首部短篇小说集，一共九篇。</p><p>还是见识太少，读第一篇《夜晚的潜水艇》的时候就被吸引了，结构精巧，想象力丰富。读完全书后，对作者更加佩服了。</p><p>每一篇都跟梦有关，梦和现实交织在一起，难以分清，有点庄周梦蝶的意思。</p><p>每一篇都在找东西，找硬币、找石碑、找湖、找佳酿、找名剑、找乐谱等。而且主人公都姓陈，这是作者对自己的影射。而我们每天面临着家庭琐事、小孩教育、繁忙的工作，还有要想去寻找的东西吗？</p><h2 id="局外人"><a href="#局外人" class="headerlink" title="局外人"></a>局外人</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191422364.webp"></p><p>主人公莫尔索被认为是一个很冷漠的人，在母亲的葬礼上没有掉眼泪，甚至第二天还去看电影，以至于杀人后没有因为杀人本身，而是因为冷漠被定罪，荒诞而讽刺。</p><p>莫尔索看似冷漠，却是非常正常的一个人，很真实地做了自己，所以在社会这个大舞台中，就显得格格不入，最终得以悲惨的结局。</p><p>对书中的一个故事印象很深刻：</p><blockquote><p>有个人早年离开自己的村子，外出谋生。过了二十五年，他发了财，带着妻儿回家乡。他母亲与他妹妹在村里开了家旅店。为了要让她们得到意外的惊喜，他把自己的妻子和儿子留在另一个地方，自己则住进他母亲的旅馆。进去时，他母亲没有认出他。他想开个大玩笑，就特意租了一个房间，并亮出自己的钱财。夜里，他的母亲与妹妹为了谋财，用大锤砸死了他，把尸体扔进了河里。第二天早晨，他的妻子来了，懵然不知真情，通报了这位店客的姓名。母亲上吊自尽，妹妹投井而死。这则报道，我天天反复阅读，足足读了几千遍。一方面，这桩事不像是真的，另一方面，却又自然而然。不论怎样，我觉得这个店客有点咎由自取，人生在世，永远也不该演戏作假。</p></blockquote><p>是啊，「人生在世，永远也不该演戏作假。」，这或许是每个人内心都想做到的，但又有多少人是完全没有戴面具的在这个社会中游走呢？</p><h2 id="秋园"><a href="#秋园" class="headerlink" title="秋园"></a>秋园</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191422849.webp"></p><p>《秋园》是一本个人传记，作者杨本芬就是书中的人物之骅。秋园是之骅的妈妈，作者讲述了妈妈艰辛的一生，语言平实而生动。</p><p>秋园的一生经历了从洛阳到湖南、湖南到湖北、晚年又回湖南的颠沛流离；经历了少年丧父、中年丧夫、老年丧子的人生悲事；经历了两任丈夫，而且都走在了她的前面。</p><p>生活如此艰苦，秋园没有抱怨，而是积极地面对，坚韧的生活着。就像儿子子恒在她床底下发现两颗竹笋一样，生命力顽强，从山上地底下钻进房里，从来没有见过阳光，去那么努力的生长着。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我读书很慢，读书慢不是因为读的很认真仔细，而是读书太少，也就是阅读量不够，量不够，质就难以发生变化，跑步如此，读书也是。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>做产品的思考</title>
    <link href="http://fwhyy.com/2023/05/tthinking-about-making-products/"/>
    <id>http://fwhyy.com/2023/05/tthinking-about-making-products/</id>
    <published>2023-05-22T01:19:28.000Z</published>
    <updated>2023-06-19T06:20:48.478Z</updated>
    
    <content type="html"><![CDATA[<p>在当今竞争激烈的市场中，如何打造出成功的产品是许多企业和团队关注的焦点。结合实际经验，我总结了一些值得关注的关于做产品思考的方面，希望能够为大家提供一些启示。</p><span id="more"></span><p>1、<strong>简单是一种能力。</strong>在设计产品时，保持简单性至关重要。简单并不意味着简陋，而是在功能和设计上追求高效、直观和易用。一种判断标准是用户不用看说明文档就能上手使用。微信发展到现在，功能很多，每次发版的更新说明都是：解决了一些已知问题，新增功能让用户自己慢慢去发现。作为国民 APP ，微信是简单的。</p><p>2、<strong>打好基础。</strong>在产品的主干功能还未成熟的情况下，匆忙添加其他能力会削弱用户对产品的信任。以低代码平台为例，如果核心功能表单、列表、流程都有问题，那么用户会选择其他更可靠的竞品。尼采说过：“人跟树是一样的，越是向往高处的阳光，它的根就越要伸向黑暗的地底。”做产品，一样的道理，打好基础很重要。</p><p>3、<strong>细节决定成败</strong>。很多时候，我们往往会更关注功能迭代、优先去满足业务。而对细节会忽略，甚至觉得不重要，但恰恰细节能体现出专业性。</p><p>比如：界面的风格是否统一、按钮位置是否一致、各类功能的小图标是否和功能相符等等。每一件小事都做好了，更容易让客户对产品、团队、公司产生信任。</p><p>好的产品在细节上下足功夫，使用户在使用过程中无法察觉，直到他们用了竞品后才能体会到差别。</p><p>4、<strong>事缓则圆</strong>。同一个客户的不同人员，或者不同的客户针对同一模块会提出各种需求，每个人说的好像都挺有道理。如果所有的要求都作为一个需求点添加到产品上，这样毫无节制的迭代产品功能，最终会做出一个庞大、复杂、易用性低但功能很全的产品。</p><p>这时可以冷静下来，综合考虑、多方调研，会发现，有的需求可能根本就不用做，有的多个需求可以使用另一个更好的方案就都解决了。</p><p>5、<strong>独特性。</strong>做任何产品，都会遇到很多竞品，怎么样能脱颖而出，具备市场竞争力，就需要建立产品的独特性。这样才能在激烈的竞争中找到生存的缝隙。</p><p>之前在油管上听少楠讲 flomo ，有很多功能不做，是因为要打造自己的产品独特性，如果做待办，就跟滴答成竞争对手了；做大纲笔记，就跟幕布成竞争对手了；做内容收藏，就跟 Pocket 成竞争对手了。</p><p>现在市场上低代码产品很多，大多数都是提供 SaaS 服务，而我们服务于大型头部客户，能满足复杂业务、将十几年的大型客户项目实施经验注入其中，这是我们的优势。</p><p>6、<strong>切换视角。</strong>一个产品一起讨论出来的酷炫的功能，一旦切换了用户视角去思考，会发现可能完全颠覆。</p><p>这种问题很常见，经常测试在功能层面验证没有问题的新特性发布后，使用者会发现有些场景不支持，因为开发者和使用者考虑问题的方式和角度是不一样的，所以我一直在团队强调无论是产品经理还是开发同学，一定要能以用户的思维去设计和使用产品功能，才能发现更多细节问题。</p><p>7、<strong>成为重度使用者</strong>。要做好一个产品，我们需要深入了解其功能和使用场景，首先我们自己需要成为产品的重度使用者，如果自己都不愿意使用，怎么能去说服客户使用呢？</p><p>重度使用自己的产品，才能深刻理解客户的诉求，才能站在客户的角度去思考和解决问题，最终的迭代和交付才是有价值的。</p><p>8、<strong>降低边际成本。</strong>低代码作为一个平台级工具，属于平台级产品。基于低代码产品构建出来的业务系统，例如：CRM、MES 等同样也是产品。</p><p>不同行业对这些业务系统的要求是有差异的，那么在设计这些业务产品时，提高复用性、做到方便迁移和后期运维，就是需要重点考虑的事情了。</p><p>9、<strong>耐心。</strong>做产品需要长期有耐心，持续改进和迭代，永远没有最好，但至少有那么一刻，你很愿意，并且很自己地将自己做的产品推荐给身边的朋友。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在当今竞争激烈的市场中，如何打造出成功的产品是许多企业和团队关注的焦点。结合实际经验，我总结了一些值得关注的关于做产品思考的方面，希望能够为大家提供一些启示。&lt;/p&gt;</summary>
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="产品" scheme="http://fwhyy.com/tags/%E4%BA%A7%E5%93%81/"/>
    
  </entry>
  
  <entry>
    <title>高可用：Nginx配合keepalived</title>
    <link href="http://fwhyy.com/2023/05/high-availability-nginx-combined-with-keepalived/"/>
    <id>http://fwhyy.com/2023/05/high-availability-nginx-combined-with-keepalived/</id>
    <published>2023-05-15T04:07:12.000Z</published>
    <updated>2023-06-19T04:10:08.050Z</updated>
    
    <content type="html"><![CDATA[<p>如果在谷歌中搜索 「Nginx 高可用」，搜索出来的大多都是 Nginx + keepalived 的使用。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191209195.webp"></p><p>所以，本文就介绍下怎样用 Nginx 和 keepalived 来实现应用的高可用。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>服务器：CentOS7<ul><li>Server1 : 10.211.55.3</li><li>Server2 : 10.211.55.14</li></ul></li><li>Docker：23.0.5</li><li>Nginx：1.23.4</li><li>keepalived：1.3.5</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>本次测试使用两台测试虚拟机，IP 分别为 10.211.55.3 和 10.211.55.14 ，Nginx 使用 Docker 进行部署，keepalived 直接在服务器部署。架构图如下：</p><p><img src="../../attachmenent/202306191208889.webp"></p><p>具体部署和配置步骤如下：</p><p>1、在两台 CentOS 服务器上安装 docker 和 docker-compose 。</p><p>2、在 10.211.55.3 服务器的 /root 目录中创建 nginx-ha 目录，目录内容如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191209234.webp" alt="image-20230511110208516"></p><p>3、docker-compose.yml 文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"> <span class="attr">s2_net:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line">  <span class="attr">ipam:</span></span><br><span class="line">   <span class="attr">driver:</span> <span class="string">default</span></span><br><span class="line">   <span class="attr">config:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">subnet:</span> <span class="number">172.55</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./config/nginx/conf.d:/etc/nginx/conf.d:ro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./web:/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="attr">s2_net:</span></span><br><span class="line">      <span class="attr">ipv4_address:</span> <span class="number">172.55</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nginx-proxy1:</span></span><br><span class="line">   <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">   <span class="attr">container_name:</span> <span class="string">nginx-proxy1</span></span><br><span class="line">   <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">   <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;10000:80&quot;</span></span><br><span class="line">   <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./config/nginx-proxy/conf.d:/etc/nginx/conf.d:ro</span></span><br><span class="line">   <span class="attr">networks:</span></span><br><span class="line">    <span class="attr">s2_net:</span></span><br><span class="line">     <span class="attr">ipv4_address:</span> <span class="number">172.55</span><span class="number">.1</span><span class="number">.3</span></span><br></pre></td></tr></table></figure><ul><li>nginx1：构建一个 web 服务，展示一个静态页面，显示服务器 IP ，能达到验证效果即可；</li><li>nginx-proxy1：反向代理负载到两台服务器的 web 服务。</li></ul><p>4、web 服务的 nginx 配置文件 config/nginx/conf.d/default.conf  ，内容如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">10.211.55.3</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">100M</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        <span class="attribute">try_files</span> $uri $uri/ /index.html;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、nginx 负载的配置文件 config/nginx-proxy/conf.d/default.conf  ，内容如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_web &#123;</span><br><span class="line">   <span class="attribute">server</span>   <span class="number">172.55.1.2</span> weight=<span class="number">7</span> max_fails=<span class="number">1</span> fail_timeout=<span class="number">10s</span>;</span><br><span class="line">   <span class="attribute">server</span>   <span class="number">10.211.55.14:9000</span> weight=<span class="number">7</span> max_fails=<span class="number">1</span> fail_timeout=<span class="number">10s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">10.211.55.3</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">100M</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://my_web;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、web/index.html 的内容就很简单了，只写了当前服务器的 IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx 1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx IP:11.211.55.3<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>7、在 nginx -ha 目录中，执行 <code>docker-compose up -d</code> 命令进行容器的构建，构建成功后，使用 docker ps 查看如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191208464.webp"></p><p>这时使用 <a href="http://10.211.55.3:10000/">http://10.211.55.3:10000</a> 或者 <a href="http://10.211.55.3:9000/">http://10.211.55.3:9000</a> 应该都能访问：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191208190.webp"></p><p>8、在 10.211.55.14 服务器上重复第二步到第七步的步骤，部署 web 服务和 nginx 负载，<strong>需要注意的是 nginx 负载的配置文件 config/nginx-proxy/conf.d/default.conf 的内容有所不同，upstream 中的 IP 地址需要修改</strong>，如下所示：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> my_web &#123;</span><br><span class="line">   <span class="attribute">server</span>   <span class="number">172.55.1.2</span> weight=<span class="number">7</span> max_fails=<span class="number">1</span> fail_timeout=<span class="number">10s</span>;</span><br><span class="line">   <span class="attribute">server</span>   <span class="number">10.211.55.3:9000</span> weight=<span class="number">7</span> max_fails=<span class="number">1</span> fail_timeout=<span class="number">10s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  <span class="number">10.211.55.14</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">100M</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://my_web;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，web 的 html 页面中展示的 IP 地址为：10.211.55.14 。</p><p>9、在两台服务器上安装 keepalived ，执行下面命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y keepalived</span><br></pre></td></tr></table></figure><p>10、使用 yum 安装的 keepalived，配置文件在 /etc/keepalived/ 目录下，将 10.211.55.3 服务器的 keepalived.conf 文件内容替换为下面内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">   script_user root</span><br><span class="line">   enable_script_security</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_script check_nginx &#123;</span><br><span class="line">    script /etc/keepalived/check-nginx.sh</span><br><span class="line">    interval 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance Vs_1 &#123;</span><br><span class="line">    state BACKUP # 定义节点主/备，主MASTER，备BACKUP，这里2个节点均为BACKUP</span><br><span class="line">    interface eth0 # 虚拟IP绑定的网卡</span><br><span class="line">    virtual_router_id 32 # 集群号，所有节点需要相同</span><br><span class="line">    priority 100 # 权重，2个节点权重一致，降低权重后会发生切换</span><br><span class="line">    advert_int 1 # 检测间隔</span><br><span class="line"></span><br><span class="line">    # 抢占模式，（nopreempt非抢占模式），配置为抢占模式时，当节点权重降低时，另外一个高权重节点会抢占服务，发生切换；</span><br><span class="line">    # 如果为非抢占模式，上面配置的检查脚本在检查到服务失败后，降低权重，但是不会发生切换。</span><br><span class="line">    !nopreempt</span><br><span class="line"></span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111 # 各节点密码一致</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unicast_src_ip 10.211.55.3 # 本端，源地址</span><br><span class="line">    unicast_peer &#123;</span><br><span class="line">      10.211.55.14 # 对端，目标地址</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        10.211.55.4  # 虚拟IP</span><br><span class="line">    &#125;</span><br><span class="line">    track_interface &#123;</span><br><span class="line">        eth0 # 检查网卡健康</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        check_nginx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>virtual_ipaddress ：定义了虚拟 IP 10.211.55.4 ，后续访问将会使用虚拟 IP 进行访问</li><li>unicast_peer：设置另一台服务器的 IP ：10.211.55.14</li><li>unicast_src_ip：设置当前服务器的 IP：10.211.55.3</li><li>check_nginx：设置一个心跳检测的脚本</li></ul><p>11、10.211.55.14 服务器的配置文件和上面一样，将 unicast_peer 和 unicast_src_ip 设置的 IP 对换即可。</p><p>12、check_nginx 设置的心跳检测脚本路径为：/etc/keepalived/check-nginx.sh ，在 /etc/keepalived 目录下创建 check-nginx.sh 文件，内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">count=`netstat -ntpl | grep 10000 | wc -l`</span><br><span class="line">if [ $count -gt 0 ]; then</span><br><span class="line">    exit 0</span><br><span class="line">else</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li>要执行 netstat 命令，需要使用 <code>yum -y isntall net-tools</code> 命令安装相关依赖</li><li>这段脚本的意思就是使用 <code>netstat</code> 命令查看当前系统中所有 TCP 连接的状态，然后使用 <code>grep</code> 命令筛选出其中监听端口为 10000 的连接，最后使用 <code>wc -l</code> 命令统计筛选出的行数</li><li>使用 <code>if</code> 语句对命令输出结果进行判断。如果监听在 TCP 端口 8888 上的进程数量大于 0，则表示有进程正在监听该端口，那么脚本就会执行 <code>exit 0</code> 命令来退出，并返回一个成功的退出码（0）。反之，如果监听在 TCP 端口 10000 上的进程数量等于 0，则表示没有进程在监听该端口，那么脚本就会执行 <code>exit 1</code> 命令来退出，并返回一个失败的退出码（1）</li></ul><p>13、使用下面命令给 check-nginx.sh  文件设置权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x check-nginx.sh </span><br></pre></td></tr></table></figure><p>14、配置文件修改好后，执行 <code>systemctl start keepalived</code> 启动 keepalived 服务，使用命令 <code>systemctl status keepalived</code> 可以查看状态，如下图为正常：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191207160.webp"></p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1、两台服务器都正常运行时，使用虚拟 IP + 负载 Nginx 端口（<a href="http://10.211.55.4:10000）进行访问，正常情况下页面中的">http://10.211.55.4:10000）进行访问，正常情况下页面中的</a> IP 应该在 10.211.55.3 和 10.211.55.14 之间来回切换。</p><p>2、关闭 10.211.55.14  服务器的 9000 端口的容器，访问站点页面应该只会出现 IP 10.211.55.3。</p><p>3、继续关闭 10.211.55.14  服务器的 10000 端口的容器，站点应该可以继续访问。</p><p>4、关闭 10.211.55.14 服务器，站点应该可以继续访问。</p><p>5、启动 10.211.55.14  服务器和 9000、10000 端口的容器，访问页面，检查是否恢复了负载切换。</p><p>6、同样的操作可以将  10.211.55.3 再来一遍，检查网页访问是否正常。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果在谷歌中搜索 「Nginx 高可用」，搜索出来的大多都是 Nginx + keepalived 的使用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="运维" scheme="http://fwhyy.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Nginx" scheme="http://fwhyy.com/tags/nginx/"/>
    
    <category term="keepalived" scheme="http://fwhyy.com/tags/keepalived/"/>
    
  </entry>
  
  <entry>
    <title>高可用：MongoDB容器部署</title>
    <link href="http://fwhyy.com/2023/05/high-availability-mongodb-container-deployment/"/>
    <id>http://fwhyy.com/2023/05/high-availability-mongodb-container-deployment/</id>
    <published>2023-05-08T04:04:42.000Z</published>
    <updated>2023-06-19T04:06:09.408Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是一款 NoSQL 数据，通常用来存储非结构化数据，我们的产品中也有用到，例如：一些文件存储在 MongoDB 的 GridFS 中。</p><span id="more"></span><p>MongoDB 有三种方式来实现高可用：</p><ul><li>副本集：副本集是 MongoDB 官方推荐的高可用解决方案。它通过在多个节点上复制数据来实现数据冗余和故障转移。副本集通常包括一个主节点和多个从节点，如果主节点发生故障，从节点可以自动选举出一个新的主节点，从而实现自动故障转移。</li><li>分片集群：分片集群是一种横向扩展的解决方案，可以将数据分散到多个节点上，从而提高读写性能和可伸缩性。分片集群通常由多个分片节点、多个配置节点和多个代理节点组成，其中分片节点负责存储数据，配置节点负责管理元数据，代理节点负责将客户端请求路由到正确的分片节点上。</li><li>复制集群：复制集群是一种基于副本集的解决方案，可以将多个副本集组合在一起，从而实现更高的可用性和可扩展性。复制集群通常由多个副本集节点和多个代理节点组成，其中代理节点负责将客户端请求路由到正确的副本集节点上。</li></ul><p>本文中选择 MongoDB 的副本集的方式来进行演示，副本集相对简单，也能达到高可用的目的，架构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191205418.webp"></p><p>为了方便，在一台服务器上使用多个容器的方式来进行部署，真实场景下只需要把三个容器分别部署到三台服务器上即可，具体步骤如下：</p><p>1、准备一台 CentOS 服务器，安装好 Docker 和 docker-compose 。</p><p>2、在 /home 目录创建 mongodb 目录，进入 mongodb 目录创建 data 目录，data 目录中分别创建 mongo1、mongo2、mongo3 用来存放三个节点的数据。</p><p>3、使用命令 <code>chmod -R 777 data</code> 给 data 目录设置权限。</p><p>4、在 mongodb 目录中创建文件 docker-compose.yml ，用来构建容器，内容如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mongo1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:5.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;27017:27017&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./data/mongo1:/data/db</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--replSet</span> <span class="string">rs0</span> <span class="string">--bind_ip_all</span> <span class="string">--port</span> <span class="number">27017</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:5.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;27018:27017&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./data/mongo2:/data/db</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--replSet</span> <span class="string">rs0</span> <span class="string">--bind_ip_all</span> <span class="string">--port</span> <span class="number">27017</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">mongo3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:5.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mongo3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&quot;27019:27017&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">./data/mongo3:/data/db</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">mongod</span> <span class="string">--replSet</span> <span class="string">rs0</span> <span class="string">--bind_ip_all</span> <span class="string">--port</span> <span class="number">27017</span></span><br></pre></td></tr></table></figure><ul><li>ports：27017、27018、27019 分别为三个节点对外的端口</li><li>volumes：将步骤 2 中创建的目录和容器内的数据目录进行映射</li><li>–replSet rs0：指定副本集的名称为 rs0</li><li>–bind_ip_all：可以让 MongoDB 实例能够通过所有网络接口进行连接，包括本地主机、局域网和互联网。这通常用于在多个计算机之间共享 MongoDB 数据库，或在具有可用公共 IP 地址的环境中使用。</li></ul><p>5、在 mongodb 目录下执行  <code>docker-compose up -d</code> 进行容器的构建，成功后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191205155.webp"></p><p>6、随便进入一个 MongoDB 容器，下面命令为进入容器名 mongo1 的容器内部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongo1 bash</span><br></pre></td></tr></table></figure><p>7、进入容器内部后，输入 <code>mongo</code> 命令进入 MongoDB 的命令行模式，在该模式执行下面的命令进行副本集的初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rs.initiate(&#123;_id: &quot;rs0&quot;, members: [</span><br><span class="line">  &#123;_id: 0, host: &quot;10.211.55.3:27017&quot;&#125;,</span><br><span class="line">  &#123;_id: 1, host: &quot;10.211.55.3:27017&quot;&#125;,</span><br><span class="line">  &#123;_id: 2, host: &quot;10.211.55.3:27017&quot;&#125;</span><br><span class="line">]&#125;)</span><br></pre></td></tr></table></figure><ul><li>该命令初始化一个名为 rs0 的副本集，并将三个 MongoDB 容器添加为成员。</li><li><strong>注意：host 中指定的 IP 为服务器的 IP，当然如果使用的是容器 IP 或者容器名称，副本集和能正常启动和运行，但程序连接的时候就会出错 。</strong></li></ul><p>8、继续在 MongoDB 的命令行模式执行 <code>rs.status()</code> ，这个命令可以查看副本集的状态信息，包括成员、主节点和副本集配置。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191205756.webp"></p><ul><li>Mongo1 被指定为了主（Primary），其余两个容器为副本（Secondary）</li></ul><p>9、在 Navicat 中配置连接副本集，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191205272.webp"></p><p>10、到这里，MongoDB 在 Docker 中部署副本集就已经完成，接下来可以通过一些场景测试下是否能故障自动转移，我验证的场景如下：</p><ul><li>重启虚拟机后检查 MongoDB 服务是否正常</li><li>使用命令 <code>systemctl restart docker</code> 将 docker 重启，检查 MongoDB 服务是否正常</li><li>使用命令 <code>docker stop mongo1</code> 将副本集中的主节点停掉，检查剩下的两个从节点是否能重现选举新的主节点</li><li>使用命令 <code>docker start mongo1</code> 将之前的主节点启动，检查是否能自动切换为从节点</li><li>将 mongo2、mongo3 这两个从节点都停掉，检查 MongoDB 服务还是否可用，正常情况下应该是不可用，主节点 mongo1 会降级为从，变为只读，直连 mongo1 可以连接进行数据读取，集群无法连接。</li><li>上面每一步操作后，除了看状态之外，还需要用程序进行连接验证服务是否正常。</li></ul><p>11、使用 .NET Core 程序进行验证，创建一个 .NET 6 的控制台程序，引用 NuGet 包 MongoDB.Driver 。</p><p>12、Program 类的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">using MongoDB.Bson;</span><br><span class="line">using MongoDB.Driver;</span><br><span class="line"></span><br><span class="line">var mongoConnectionString = &quot;mongodb://10.211.55.3:27017,10.211.55.3:27018,10.211.55.3:27019/test?replicaSet=rs0&amp;readPreference=primary&quot;;</span><br><span class="line"></span><br><span class="line">var mongoClient = new MongoClient(mongoConnectionString);</span><br><span class="line">var database = mongoClient.GetDatabase(&quot;test&quot;);</span><br><span class="line">var collection = database.GetCollection&lt;BsonDocument&gt;(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line"> // 插入一条文档</span><br><span class="line">var document = new BsonDocument &#123; &#123; &quot;name&quot;, &quot;oec2003&quot; &#125;, &#123; &quot;age&quot;, 30 &#125; &#125;;</span><br><span class="line">collection.InsertOne(document);</span><br><span class="line"></span><br><span class="line">var documents = await collection.Find(Builders&lt;BsonDocument&gt;.Filter.Empty).ToListAsync();</span><br><span class="line">foreach (var doc in documents)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>连接字符串中的 replicaSet = rs0 用来指定副本集的名称</li><li>readPreference=primary ，将读取偏好设置为主节点，表示只从主节点读取数据，这也是默认模式，除了 primary 外，还有一些其他的配置选项，说明如下：<ul><li><code>readPreference=primaryPreferred</code>：查询将首选主节点，但如果主节点不可用，则可以从其他节点读取数据。</li><li><code>readPreference=secondary</code>：查询将只从副本集的次要节点读取数据。如果没有次要节点可用，则查询将失败。</li><li><code>readPreference=secondaryPreferred</code>：查询将优先从次要节点读取数据，但如果没有次要节点可用，则可以从主节点读取数据。</li><li><code>readPreference=nearest</code>：查询将从网络延迟最低的节点读取数据。这个选项不考虑节点的角色（主节点或次要节点），而是选择网络最近的节点。</li></ul></li></ul><p>在高可用部署中，一定要结合实际情况进行权衡后，采取即能解决问题，又熟练掌握的方案，否则，出现问题，如果不能及时解决，效果还不如单机。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MongoDB 是一款 NoSQL 数据，通常用来存储非结构化数据，我们的产品中也有用到，例如：一些文件存储在 MongoDB 的 GridFS 中。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="运维" scheme="http://fwhyy.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="MongoDB" scheme="http://fwhyy.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>读《持续架构实践》</title>
    <link href="http://fwhyy.com/2023/04/read-continuous-architecture-practices/"/>
    <id>http://fwhyy.com/2023/04/read-continuous-architecture-practices/</id>
    <published>2023-04-26T03:56:13.000Z</published>
    <updated>2023-06-19T08:58:29.784Z</updated>
    
    <content type="html"><![CDATA[<p>之前看到过一种言论，说相比互联网产品，做 ToB 产品没有那么大的业务量，也没有那么多的用户量，所以非功能性的需求没那么重要，重要的还是业务。</p><span id="more"></span><p>虽然不是很认同，但之前也确实对非功能性需求不够重视，后来发现随着客户信息化越来越成熟、系统使用的时间越来越长，用户数的增长和业务量的增长都会带来问题，导致系统的可用性降低。</p><p>那么，什么是非功能性需求呢？</p><p>最近看的一本书《持续架构实践》中有详细的讲解。</p><p>书中提倡架构应该持续地进行，就是说在整个研发生命周期中，持续提出架构决策，需要遵守六个架构准则：</p><blockquote><p>1、用产品思维，而非项目思维来设计架构</p><p>2、聚集质量属性，而不仅仅是功能性需求</p><p>3、在绝对必要的时候再做设计决策</p><p>4、利用微小的力量，面向变化来设计架构</p><p>5、为构建、测试、部署和运营来设计架构</p><p>6、在完成系统设计后，开始为团队做组织建模</p></blockquote><p>这六个准则贯穿全书，其中准则二说的质量属性，指的就是非功能性需求，包括：安全性、伸缩性、性能、弹性等。这也是本文的主要内容。</p><h2 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h2><p>可伸缩性经常被人忽视，但随着用户使用系统的人数越来越多，数据量越来越大，可伸缩性的重要性就体现出来了。</p><p>什么是可伸缩性呢？</p><blockquote><p>通过增加或减少系统成本来处理增加或减少的工作负载，这个工作负载指的是更大的业务量，或更大的用户量。</p></blockquote><p>对于 ToB 企业级应用来说，这个系统成本通常是增加。那什么是系统成本呢？有两个维度：</p><ul><li><p>垂直伸缩：增加服务器资源，比如硬盘、内存、CPU ，这种是最简单的，程序不需要做任何调整就把问题解决了，但会有上限的问题。</p></li><li><p>水平伸缩：添加多台服务器，构建集群，对于应用来说，可能需要进行代码改造才能支持集群方式部署；对于中间件会增加部署的复杂度。</p></li></ul><p>中间件的伸缩都有成熟的方案，我们自己开发的程序可能会遇到些问题，现在的架构基本都是前后端分离，后端 API 接口是无状态的，但如果在 API 中将数据存在内存中，就会变得复杂。</p><p>所以说，有状态和无状态对可伸缩是有影响的，有状态的额外数据存放在服务器的内存中，垂直伸缩的时候没有问题，水平伸缩就会涉及到数据同步的问题。不过也有处理的办法：</p><ul><li>同一台机器保持相同的访问实例，可以通过 Nginx 的配置实现；</li><li>当数据发生改变的时候，发广播通知其他节点进行数据同步，要考虑数据一致性的问题。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>安全问题基本上在开发过程中很少考虑，客户环境一旦有护网行动，或者进行安全漏洞扫描，就出扫出一堆问题，然后按照危险等级进行修复。</p><p>所以，如果在架构设计时就对安全性进行了考虑，会省去很多的麻烦。</p><p>下面列举下经常出现的安全性的问题：</p><p>1、数据库的 Sql 注入；</p><p>2、API 接口没有鉴权可以直接调用；</p><p>3、某些页面是需要授权才能访问的，但拿到页面地址，在权限不匹配的情况下也能进行访问；</p><p>4、登录时调用接口，密码是明文；</p><p>5、在一些进行数据库连接设置的界面，接口会返回一些不必要的信息，比如数据库密码；</p><p>6、对关键信息的修改没有相关日志记录；</p><p>7、中间件使用默认配置，没有设置密码，比如：Redis、MongoDB 等；</p><p>8、恶意攻击下的缓存的雪崩、击穿、穿透问题；</p><p>9、API 出现异常时，没有进行合理处理导致返回了敏感信息；</p><p>上面只是简单列了几条常见问题，在实际软件开发过程中，应该将安全性左移，不能等扫出问题再进行补救，应该在整个软件生命周期中就伴随着安全性的考虑。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>开发经常说：我本地是好的呀！我本地不慢呀！</p><p>这是因为和生产系统相比，环境不一样、用户数不一样、业务量也不一样。自然结果也不一样。</p><p>我们在交付软件的时候，由于有时间节点的压力，往往都是功能、业务优先，大数据量、高并发并不会作为第一优先级考虑。这就会导致在客户环境中可能出现性能问题。</p><p>小的性能问题会影响使用体验，严重的性能问题可能导致系统不可用，给客户带来损失。</p><p>提高性能的策略有下面一些方式：</p><p>对内：</p><ul><li>优化代码</li><li>降级处理，在相同资源的情况下，保证核心业务稳定</li></ul><p>对外：</p><ul><li>增加服务器资源</li><li>使用缓存</li><li>将一些业务使用消息机制异步处理</li></ul><p>减少开销：</p><ul><li>微服务的整合，减少调用层级</li><li>API 瘦身，减少不必要的信息返回到前端</li></ul><p>在书中也建议将性能测试活动左移，尽早发现性能问题，提前进行正常负载、预计的最大负载的压力测试。</p><h2 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h2><p>软件系统可用性有三个层级：可用、可靠、弹性</p><ul><li>可用：系统不跨，主要依靠基础设施的能力，进行副本集复制，自动故障转移等</li><li>可靠：建立在可用基础之上，增加了一条，就是系统是正确的，业务流转不会出现问题</li><li>弹性：结合了上面两种，让系统可以从容地处理意外故障和恶意故障并进行恢复</li></ul><p>在系统出现问题时，怎样让系统恢复可用，损失降到最小，是优先级最高的，之前看过一个说法，我认为很有道理：</p><blockquote><p>运维有三大法宝：重启、扩容、回滚。</p></blockquote><p>其实就是让系统能尽快恢复使用。那怎么做到有弹性呢？</p><p>1、识别问题：出现问题时能快速识别，就需要用到监控系统。</p><p>2、隔离问题：服务的拆分、容器化部署等都可以让一个服务失败时，其他可以继续运行，不受影响。</p><p>3、缓解问题：数据、系统出现问题时能够回滚，让系统恢复正常，留出排查问题的时间；数据出错，有补偿机制，可以手动进行修复。</p><p>4、解决问题：需要有详细的日志进行辅助、全链路日志追踪、日志检索等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、非功能性的需求都需要左移，伴随着软件生命周期一起成长，左移让所有人、事都融合起来，每个迭代的目标性更强；</p><p>2、非功能性需求需要配合监控，只有发现问题，才能解决问题；</p><p>3、我很认可一句话：架构是演进出来的，不是设计出来的，这其实就很符合持续架构的思想。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前看到过一种言论，说相比互联网产品，做 ToB 产品没有那么大的业务量，也没有那么多的用户量，所以非功能性的需求没那么重要，重要的还是业务。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="架构" scheme="http://fwhyy.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>分享几个网站和工具（202304）</title>
    <link href="http://fwhyy.com/2023/04/share-some-website-and-tools-202304/"/>
    <id>http://fwhyy.com/2023/04/share-some-website-and-tools-202304/</id>
    <published>2023-04-17T03:48:31.000Z</published>
    <updated>2023-06-19T08:56:53.744Z</updated>
    
    <content type="html"><![CDATA[<p>最近又收集了一些工具和站点，其中部分和 ChatGPT 有关。</p><span id="more"></span><h2 id="ChatGPT-免费教程"><a href="#ChatGPT-免费教程" class="headerlink" title="ChatGPT 免费教程"></a>ChatGPT 免费教程</h2><p><a href="https://learningprompt.wiki/">https://learningprompt.wiki/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152514.webp"></p><p>很不错的一个免费学习 AI 的网站，目前有 ChatGPT 和 Midjourney 教程。</p><h2 id="ChatGPT-SC"><a href="#ChatGPT-SC" class="headerlink" title="ChatGPT SC"></a>ChatGPT SC</h2><p><a href="https://www.aishort.top/cn/">https://www.aishort.top/cn/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152568.webp"></p><p>一份 ChatGPT 的中文 Prompt 合集，目前有 170+ 个Prompt，涵盖的方面非常广泛，有中文版。</p><p>ChatGPT 以聊天对话的模式，使用非常简单，但要用好不太容易，这种提示词网站可以给我们帮助。</p><h2 id="AI-研究所"><a href="#AI-研究所" class="headerlink" title="AI 研究所"></a>AI 研究所</h2><p><a href="https://www.aiyjs.com/">https://www.aiyjs.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152668.webp"></p><p>一个聚合网站，整合了 AI 相关的资讯，工具。如果不知道怎么开始使用 AI，不妨可以到这里看看。</p><h2 id="Copilot-Hub"><a href="#Copilot-Hub" class="headerlink" title="Copilot Hub"></a>Copilot Hub</h2><p><a href="https://app.copilothub.co/">https://app.copilothub.co/</a></p><p>Copilot Hub 是一个帮助你基于私有数据创建智能知识库的平台。你可以基于文档、网站、Notion database 或其他数据源在几分钟内创建一个自定义的 ChatGPT。</p><p>我简单传了一个我们平台组织机构同步的 PDF 说明文档，使用效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152210.webp"></p><p>借鉴其思路，在公司内部实现同样效果，正是想要去做的事情。</p><h2 id="ChatGPT-中文指南"><a href="#ChatGPT-中文指南" class="headerlink" title="ChatGPT 中文指南"></a>ChatGPT 中文指南</h2><p><a href="https://github.com/yzfly/awesome-chatgpt-zh">https://github.com/yzfly/awesome-chatgpt-zh</a></p><p>GitHub 上的一个开源项目，该项目意图帮助中文用户了解和使用 ChatGPT，本文中提到了不少站点可能已经收录在这个项目中。</p><h2 id="候补名单（Waitlist）"><a href="#候补名单（Waitlist）" class="headerlink" title="候补名单（Waitlist）"></a>候补名单（Waitlist）</h2><p><a href="https://www.waitlist.wtf/">https://www.waitlist.wtf/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152959.webp"></p><p>最近各大 AI 产品推出，都需要先 Waitlist，这个网站提供了很多网站的 Waitlist 入口，可以方便一站式加入这些 Waitlist。例如：Speak.com 、Mest.io 、ChatGPT Plugin 、Adobe Firfly 、Google Bard 等。</p><p>需要说明的是，这个网站自己也需要 Waitlist</p><h2 id="Awesome-ChatGPT"><a href="#Awesome-ChatGPT" class="headerlink" title="Awesome-ChatGPT"></a>Awesome-ChatGPT</h2><p><a href="https://github.com/dalinvip/Awesome-ChatGPT">https://github.com/dalinvip/Awesome-ChatGPT</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152515.webp"></p><p>GitHub 上的另一个资料汇总学习项目，可以和 ChatGPT 中文指南这个项目对比着看。</p><h2 id="warp"><a href="#warp" class="headerlink" title="warp"></a>warp</h2><p><a href="https://www.warp.dev/">https://www.warp.dev/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152257.webp"></p><p>一款终端工具，有两个亮点：启动速度快、颜值高。</p><p>如果在未来的版本中，支持 session 的保存，我应该会考虑从 Tabby 迁移到 warp 。</p><h2 id="B端观止"><a href="#B端观止" class="headerlink" title="B端观止"></a>B端观止</h2><p><a href="https://www.yuque.com/u1003394/fn574a">https://www.yuque.com/u1003394/fn574a</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152727.webp"></p><p>语雀上一个讲解 ToB 产品的文档库，涉及到开发 ToB 产品的方方面面，产品经理和技术人员都比较适合。</p><h2 id="Mapster"><a href="#Mapster" class="headerlink" title="Mapster"></a>Mapster</h2><p><a href="https://github.com/MapsterMapper/Mapster">https://github.com/MapsterMapper/Mapster</a></p><p>在 .NET Core 中我们通常会使用 AutoMapper 来做对象的映射，Mapster 跟 AutoMapper 有相同的能力，但速度更快，下面是一个性能比较图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152639.webp"></p><h2 id="myCompiler（在线IDE）"><a href="#myCompiler（在线IDE）" class="headerlink" title="myCompiler（在线IDE）"></a>myCompiler（在线IDE）</h2><p><a href="https://www.mycompiler.io/">https://www.mycompiler.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191152374.webp"></p><p>一款免费的在线 IDE 工具，支持大多数主流语言，无需注册，写完代码就能在线运行。</p><h2 id="wiki-js"><a href="#wiki-js" class="headerlink" title="wiki.js"></a>wiki.js</h2><p><a href="https://docs.requarks.io/">docs.requarks.io</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151888.webp"></p><p>如果觉得语雀之类的文档限制越来越多，想要自己搭建一套文档库，不妨试试。</p><h2 id="grep-app"><a href="#grep-app" class="headerlink" title="grep.app"></a>grep.app</h2><p><a href="https://grep.app/">https://grep.app/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151776.webp"></p><p>一个在线代码搜索工具，输入代码片段，便可从50 万个开源仓库中检索出结果，搜索时可选区分大小写、正则表达式以及单词搜索，结果输出速度非常快。</p><h2 id="USVA"><a href="#USVA" class="headerlink" title="USVA"></a>USVA</h2><p><a href="https://usva.cc/">https://usva.cc/</a><br><a href="https://github.com/usvacloud/usva">https://github.com/usvacloud/usva</a></p><p>一款开源的匿名文件传输工具，单文件最大 3G，只有三十天有限期，无上传数量限制。临时用下还是非常不错的。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151226.webp"></p><h2 id="一个有趣的个人网站"><a href="#一个有趣的个人网站" class="headerlink" title="一个有趣的个人网站"></a>一个有趣的个人网站</h2><p><a href="https://henryheffernan.com/">https://henryheffernan.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151964.webp"></p><p>国外的一个个人网站，非常有意思，页面中有一个电脑桌，桌上放着一台老式电脑，神奇的是，这个电脑是可以使用的。</p><h2 id="学历史"><a href="#学历史" class="headerlink" title="学历史"></a>学历史</h2><p><a href="https://history-maps.com/zh">https://history-maps.com/zh</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151836.webp"></p><p>一个学历史的网站，如果对历史感兴趣，可以看看。</p><h2 id="he3"><a href="#he3" class="headerlink" title="he3"></a>he3</h2><p><a href="https://he3.app/cn/">https://he3.app/cn/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151033.webp"></p><p>类似 bejson 那种的客户端工具，有常用的链接编码解码、JSON 对比、二维码解析、定时任务表达式编写、格式转换等等。</p><p>同类的客户端工具还有 devtoys 也不错。</p><h2 id="iOS快捷指令大全"><a href="#iOS快捷指令大全" class="headerlink" title="iOS快捷指令大全"></a>iOS快捷指令大全</h2><p><a href="https://www.rcuts.com/">https://www.rcuts.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151081.webp"></p><p>一个专注分享苹果手机 iOS 快捷指令大全，提供实用的 iPhone 快捷指令下载与教程的网站，上面收集社交、生活、效率、阅读等等各种类型的快捷指令工具集合。</p><h2 id="参数化二维码生成器"><a href="#参数化二维码生成器" class="headerlink" title="参数化二维码生成器"></a>参数化二维码生成器</h2><p><a href="https://qrbtf.com/">https://qrbtf.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151800.webp"></p><p>通常生成二维码都会使用草料二维码，但在 qrbtf.com 这个站点中可以生成非常美观的二维码，并且还可以调整二维码各项参数。</p><h2 id="网页设计博物馆"><a href="#网页设计博物馆" class="headerlink" title="网页设计博物馆"></a>网页设计博物馆</h2><p><a href="https://www.webdesignmuseum.org/">https://www.webdesignmuseum.org/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191151821.webp"></p><p>一个展示了 1991 年至今的网页设计变迁的网站，收录了2300 多个精心挑选和分类的网站，展示了其 1991 年至近年来的网页设计变迁，例如 Google、亚马逊、苹果、Netflix、微软等等，国内的大厂也能搜到，不过不是很全。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近又收集了一些工具和站点，其中部分和 ChatGPT 有关。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="分享" scheme="http://fwhyy.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="网站" scheme="http://fwhyy.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>由 ChatGPT 带来的对低代码产品的思考</title>
    <link href="http://fwhyy.com/2023/04/thinking-about-low-code-products-brought-about-by-chatgpt/"/>
    <id>http://fwhyy.com/2023/04/thinking-about-low-code-products-brought-about-by-chatgpt/</id>
    <published>2023-04-13T03:42:00.000Z</published>
    <updated>2023-06-19T03:44:23.021Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的文章中多次提到我们在开发一款低代码平台，主要面向 ToB 企业，帮助企业完善信息化建设，给企业的数字化转型贡献一份力量。</p><span id="more"></span><p>数字化转型的目标是降本增效，同样，效率对我们来说至关重要，售前能快速提供原型和客户沟通、实施过程中能高效快速交付、售后遇到的各种问题能立马找到答案。</p><p>最近，ChatGPT 持续火热，每天在推上都能发现新的应用，那么 ChatGPT 和我们的低代码产品能结合吗？或者说这种大语言模型的思路能给低代码带来怎样的效率提升？</p><p>其实一些巨头已经这样做了。</p><p>Salesforce 宣布推出新产品 EinsteinGPT，这是一种基于 LLM 技术的产品，它与 Salesforce 的主要网络应用程序集成，利用 OpenAI ChatGPT 模型来帮助跟踪销售人员联系潜在客户的频率，并自动编写营销电子邮件，无需手动编写电子邮件。</p><p>另一方面，微软也宣布将 ChatGPT 技术扩展到 Power Platform 平台上。Power Platform 是微软的一款低代码产品，在《最近看了两本低代码的书》中有介绍。这意味着 Power Platform 上的 Power 虚拟代理和 AI Builder，都已经更新了 ChatGPT 编码功能，使用户可以在很少甚至不用编写代码的情况下，开发自己的应用程序。</p><p>Salesforce 将其应用在业务能力上，微软则在平台能力上进行了增强。对我们来说，售前和实施中需要的是能快速搭建应用，售后需要快速解决问题，所以有两个方向可以去做：</p><p>1、应用搭建效率的提升；</p><p>2、构建智能问答系统。</p><p>目前项目实施的步骤如下：</p><ul><li>需求分析师和客户沟通完后，整理出需求文档；</li><li>需求分析师对搭建工程师和开发进行需求宣讲；</li><li>可以通过配置实现的部分由搭建工程师进行搭建配置，其他部分由开发人员进行定制开发然后和平台进行集成。</li></ul><p>让低代码产品集成了 ChatGPT 的能力后，系统就会变成这样：</p><ul><li>系统具备理解自然语言的能力；</li><li>需求分析和客户聊完形成的文档本身就是自然语言描述的；</li><li>在系统中有聊天对话框和进行交互；</li><li>在对话框输入需求描述，能够识别关键信息，关键信息包括接口识别、参数提取；</li><li>调用平台接口进行应用的创建，或者局部功能调整；</li><li>就这样聊着天把系统给做完了。</li></ul><p>例如：在对话框中输入，将当前列表的项目名称这一列宽度调整到 500 ，这时就需要能识别参数：项目名称和 500，而且知道需要调用调整列宽的接口。</p><p>现有的低代码平台在后台做完各种配置后，点击保存后，前端收集所有数据传递给接口，接口的颗粒度比较粗，一次性会存储很多内容，但上面例子中调整一个列的列宽设置就需要一个接口，这就需要接口的颗粒度非常细，我觉得改造接口颗粒度是实现智能化的第一步。</p><p>上面说结合 ChatGPT 的能力，并不是直接对接 ChatGPT 的接口，所以说要实现还是相当有难度的。不过一个新的技术兴起到完全在 ToB 市场中普及，是有一个时间周期的，只要方向没错，完全有这个准备的时间。</p><p>目前在项目实施过程中存在几个问题，这也是为什么一个智能问题系统很重要的原因：</p><ul><li>因为平台功能多、非常灵活，以至于同样的需求不同的人去实现，方法和途径是不一样的，工作量可能有好几倍的差距；</li><li>实施过程中遇到的各种产品问题，需要找熟悉的同事询问，或者咨询产品团队。</li></ul><p>现在的方式就是通过文档搜索，业务场景案例、操作手册、实施常见问题手册等，这些年也沉淀了非常多的文档，不过是基于关键字搜索的，用关键字搜索有几个问题：</p><ul><li>很多时候不知道怎么提取关键字；</li><li>搜索的结果非常多，不能精准匹配，随着文档的增多，需要在大量的结果中去筛选；</li><li>对于业务场景来说，匹配度非常差。</li></ul><p>如果按照 ChatGPT 的思路，智能问题系统的逻辑就是这样的：</p><ul><li>所有沉淀的文档（语料库）生成向量数据存储到向量数据库；</li><li>输入的自然语言生成向量，计算相似度，找到相关结果；</li><li>整理输出。</li></ul><p>针对这个问题，我在知识星球问过张善友大佬，下面的图就是张善友提供的：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191143766.webp"></p><p>宝玉在推上也回答过类似的问题：</p><p><a href="https://twitter-thread.com/t/1641656561650249730">https://twitter-thread.com/t/1641656561650249730</a></p><p>不过张善友和宝玉提供的参数都是依赖 OpenAI 的接口，如果不依赖 OpenAI，有办法实现吗？这需要进一步去学习和研究。</p><p>最近看到 Supabase 产品的文档就提供了 AI 问答（<a href="https://supabase.com/docs%EF%BC%89%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%95%88%E6%9E%9C%E5%B0%B1%E6%98%AF%E6%88%91%E6%83%B3%E8%A6%81%E8%BE%BE%E5%88%B0%E7%9A%84%EF%BC%8C%E6%80%BB%E7%BB%93%E4%B8%8B%E5%B0%B1%E6%98%AF%E6%A0%B9%E6%8D%AE%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%8C%E7%BB%99%E4%B8%80%E4%B8%AA%E7%B2%BE%E5%87%86%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82">https://supabase.com/docs），这个效果就是我想要达到的，总结下就是根据自然语言的输入，给一个精准的答案。</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191143053.webp"></p><p>未来已经到来，不管是产品还是个人，都需要持续不断地学习和进化，才能不被淘汰。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的文章中多次提到我们在开发一款低代码平台，主要面向 ToB 企业，帮助企业完善信息化建设，给企业的数字化转型贡献一份力量。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="低代码" scheme="http://fwhyy.com/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
    <category term="思考" scheme="http://fwhyy.com/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="ChatGPT" scheme="http://fwhyy.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>读《认识AI》</title>
    <link href="http://fwhyy.com/2023/04/read-ai/"/>
    <id>http://fwhyy.com/2023/04/read-ai/</id>
    <published>2023-04-03T03:38:15.000Z</published>
    <updated>2023-06-19T03:41:40.328Z</updated>
    
    <content type="html"><![CDATA[<p>1、最近 ChatGPT 越来越热，都已经到了马斯克等千人签署公开信，呼吁暂停开发更强大的AI系统，担心人工智能开发危及「文明控制权」，而我这个 AI 小白决定要系统性的学习下 AI 相关知识了。</p><span id="more"></span><p>2、我之前说过，看书是系统化学习比较有效的一种方式，于是我找到了《认识 AI》这本书，这本书非常适合入门，整本书只有 200 页，涉及了 AI 的方方面面，很多地方都以生活中实际的例子进行隐喻，即便是非技术人员也能很好理解。</p><p>3、AI 是 Artificial Intelligence 的缩写，中文名是人工智能，这个现在耳熟能详的名字，居然在 1955 就被创造了，1956 年的达特茅斯会议上由约翰·麦卡锡提出，讨论了要让计算机能像人一样具有智能。约翰·麦卡锡也被称为人工智能之父。</p><p>4、人工智能的一个分支是符号和模式匹配，通过关键字和模式匹配的方式对信息进行处理然后输出结果，当不能匹配时就没有结果返回，这种方式适合垂直领域，像客户机器人、天猫精灵等都属于这种。</p><p>5、另一个分支就是机器学习，就是让机器能像人一样进行学习，这就突破符号模式匹配的限制。例如在符号系统中，数据中有 10 个小狗的照片，如果你提供的的照片在这个范围内，就能识别，否则就不能匹配，儿在机器学习中，可以提取海量小狗照片进行特征提取，当提供一个范围外的小狗照片，只要特征符合，就能识别。</p><p>6、机器学习分为有监督和无监督，就像小朋友学习一样，找一个好的老师带着学，这就是有监督；让小朋友自己不断试错和观察，找到规律的学习方式就是无监督。对应到机器学习中，有监督就需要对数据足够了解，知道什么样的输入能产生什么样的输出，就像老师对所有知识都了如指掌一样；无监督我们只需要提供数据和算法，让机器自己去寻找内在联系和规律，数据量越大，结果越好。2015 年名震一时的 AlphaGo 就是通过无监督来进行学习的。</p><p>7、思考：我们现在做的低代码产品，在项目实施过程中，不同经验的人达到同样的业务目的，采用的方式可能完全不同，那是否能将这些经验让机器进行学习，通过自然语言进行场景描述，就能给出一个最优解呢？而对于相对确定的内容，比如特定故障的处理方式，就可以使用模式匹配的方式给出明确答案。</p><p>8、上面提到的有监督、无监督是学习的方式，在具体学习时还是需要根据不同场景使用不同的算法，常见的算法有下面这些：</p><ul><li><strong>决策树</strong>：是一系列指引帮助你做决定的流程，如游戏中的选项。例如：外出玩要穿什么衣服？如果天气热就穿T恤短裤,如果下雨就穿雨衣雨鞋，天气凉快就穿件夹克。这就是一个简单的决策树。常用于数据挖掘、机器学习中的分类和回归问题。</li><li><strong>k最近邻</strong>：找到最相似的 k 个同伴,然后看看他们的决定，你也做同样的决定。例如：不知道周末去玩什么，找 k 个最好的朋友问问他们周末的计划，然后你也去做类似的活动。主要用于分类问题。</li><li><strong>k均值聚类</strong>：把相似的项划分到同一个组中。例如：小朋友有 10 个糖果，可以通过观察糖果的颜色、形状等属性，将相似的糖果放在一组中，最终将10个糖果分成多组。它用于无监督学习的聚类问题。</li><li><strong>回归分析</strong>：找到两件事之间的对应关系。例如：通过测量小学生的身高和年龄：建立年龄与身高的对应模型，可以预测某个年龄的孩子大概的身高。它适用于回归和预测问题。</li><li><strong>朴素贝叶斯</strong>：通过统计学计算，对未知事物进行概率预测。例如，对于一篇文章，如果出现了与体育相关的单词，那么朴素贝叶斯算法就会认为这篇文章属于体育类别的概率更高。</li></ul><p>9、书中还提到一个重要的机器学习算法：人工神经网络，它模拟了人类神经系统的结构和工作原理，能够学习和处理复杂的数据。分为三层，下面用一个例子来解释下这三个层级：</p><p>假设我们要训练一个人工神经网络来识别手写数字。</p><ul><li>输入层：将数字图片输入到神经网络的输入层，输入层会将每个像素的值作为输入，传递给下一层隐藏层。</li><li>隐藏层：在隐藏层中，每个神经元都会对输入的像素进行各种处理和计算，提取特征。通过调整权重和偏置，隐藏层可以学习如何提取数字图片的特征，比如边缘、线条、圆弧等。</li><li>输出层：最后，神经网络会将隐藏层的输出传递到输出层，输出层会计算每个数字的概率，并输出概率最高的数字作为识别结果。</li></ul><p>10、机器能够通过学习解决很多的问题，但要让人可以方便地和机器进行沟通，这就需要用到自然语言处理技术（NLP），NLP 是自然语言理解（NLU）和自然语言生成（NLG）的结合，一个输入，一个输出，结合起来就是 NLP 了。关于 NLP 书中提到了很多的挑战，现在 ChatGPT 都解决的很好，ChatGPT 可以很轻松地理解我们要表达的意思。</p><p>11、总的来说，这本书可以让我们了解到很多人工智能相关的很多概念，通俗易懂，也不需要有很强的背景知识，可以为后面进一步学习打下基础。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、最近 ChatGPT 越来越热，都已经到了马斯克等千人签署公开信，呼吁暂停开发更强大的AI系统，担心人工智能开发危及「文明控制权」，而我这个 AI 小白决定要系统性的学习下 AI 相关知识了。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书笔记" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>Docker日志大小限制和切换存储目录</title>
    <link href="http://fwhyy.com/2023/03/docker-log-size-limits-and-switching-storage-directories/"/>
    <id>http://fwhyy.com/2023/03/docker-log-size-limits-and-switching-storage-directories/</id>
    <published>2023-03-28T03:35:16.000Z</published>
    <updated>2023-06-19T03:37:41.252Z</updated>
    
    <content type="html"><![CDATA[<p>产品的各种环境使用了很多 <code>CentOS</code> 虚拟机，默认情况下 <code>root</code> 目录空间是 50 G，随着使用时间越来越长，空间会变得不够用。</p><span id="more"></span><p>一直采用的方法就是清除无用的镜像和 <code>Docker</code> 日志，服务器就一直处于可用的状态。直到连清理都没用的时候，才想起来要要需找其他的方法。</p><p>当没有逼到绝境的时候，我们会习惯性依赖自己熟悉的方法和工具，可能不高效，但能解决问题，这种又不是不能用的思维害人不浅，会让人呆在舒适区不愿意出来。</p><p>上面所说的其他的方法其实很简单，就是限制 <code>Docker</code> 日志大小和将 <code>Docker</code> 数据目录切换到外部存储中。</p><h2 id="日志限制"><a href="#日志限制" class="headerlink" title="日志限制"></a>日志限制</h2><p>1、编辑 Docker 的配置文件 <code>/etc/docker/daemon.json</code>，如果该文件不存在，就新建一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>2、在该文件中添加以下内容，以限制单个日志文件的大小为100MB，并保留最近5个日志文件。这里我们使用 <code>max-size</code> 和 <code>max-file</code> 参数来控制日志的大小和数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;: &#123;</span><br><span class="line">      &quot;max-size&quot;: &quot;100m&quot;,</span><br><span class="line">      &quot;max-file&quot;: &quot;5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>max-size：单个日志文件的最大大小；</li><li>max-file：最多保留几个日志文件，当单个文件的日志大小超过设置后，会产生新的日志文件。</li></ul><p>3、重新启动 <code>Docker</code> 服务使配置生效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="数据目录切换"><a href="#数据目录切换" class="headerlink" title="数据目录切换"></a>数据目录切换</h2><p>在 <code>CentOS</code> 中，<code>Docker</code> 默认的目录为 <code>/var/lib/docker</code> ，可以使用 <code>Docker</code> 配置文件中的 <code>data-root</code> 选项，进行 <code>Dcoker</code> 数据目录的设置，具体步骤如下：</p><p>1、在 <code>/etc/docker/daemon.json</code>  配置文件中添加 <code>data-root</code> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;: &#123;</span><br><span class="line">      &quot;max-size&quot;: &quot;100m&quot;,</span><br><span class="line">      &quot;max-file&quot;: &quot;5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &quot;data-root&quot;: &quot;/home/docker&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>/home/docker</code> 目录为外接存储，或者空间比较大的卷。</li></ul><p>2、停用 <code>Docker</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop docker</span><br></pre></td></tr></table></figure><p>3、将 <code>Docker</code> 默认目录中的内容拷贝到新的目录中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rsync -aqxP /var/lib/docker/ /home/docker/ </span><br></pre></td></tr></table></figure><ul><li>一个用于远程同步文件和目录的工具；</li><li>告诉  <code>rsync</code>  以归档模式同步文件和目录，其中  <code>a</code>  表示归档模式，  <code>q</code>  表示安静模式（不显示输出），  <code>x</code>  表示不跨越文件系统边界，  <code>P</code>  表示显示进度条和部分传输的文件。</li></ul><p>4、修改默认目录的名称为 bak：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/lib/docker /var/lib/docker.bak</span><br></pre></td></tr></table></figure><p>这样做的好处是可以对原始数据进行一个备份，等运行稳定了再进行删除，另外就是防止配置没有生效导致还是读取的原始目录。</p><p>5、启用 <code>Dcoker</code>：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>在上面第三步中使用了  <code>rsync</code>  这个命令来进行内容的同步，这个命令的含义是使用  <code>rsync</code>  工具将本地计算机中  <code>/var/lib/docker/</code>  目录下的所有文件和子目录同步到另一个本地计算机中的  <code>/home/docker/</code>  目录下。</p><p>在此之前，进行文件或目录的操作使用 <code>cp</code>  和 <code>scp</code> 比较多，这次查资料时知道了 rsync 这个命令工具，便继续学习了下和  <code>cp</code>  、 <code>scp</code>  的区别：</p><h3 id="rsync-和-cp-、-rsync-的区别"><a href="#rsync-和-cp-、-rsync-的区别" class="headerlink" title="rsync 和 cp 、 rsync 的区别"></a>rsync 和 cp 、 rsync 的区别</h3><ul><li><p>复制方式： <code>cp</code> 和 <code>scp</code> 会将整个文件复制到目标位置，而 <code>rsync</code>只会复制需要更新的部分，这可以提高复制的速度和效率。</p></li><li><p>支持性： <code>rsync</code> 支持更多的操作，例如文件同步、文件备份、文件恢复等。<code>cp </code>和 <code>scp </code>仅支持文件复制。</p></li><li><p>传输方式：<code>cp</code> 在本地文件系统之间复制文件，<code>scp</code> 进行远程操作，而 <code>rsync</code> 可以在本地或远程机器之间进行文件同步。</p></li><li><p>效率：<code>rsync</code> 更有效率，因为它只复制需要更新的文件。</p></li><li><p>可选项：<code>rsync  </code>提供了更多的可选项和配置选项，例如压缩、部分传输、跨文件系统同步等。</p></li></ul><p>总之， <code>rsync </code> 是一个更强大、更高效的文件复制和同步工具，如果需要在本地或远程机器之间进行文件同步、备份和恢复等操作，建议使用<code>rsync</code>。而 <code>cp</code> 和 <code>scp</code> 则适用于简单的本地文件复制和远程文件传输。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次日志限制和目录切换的学习，有两点思考：</p><p>1、很多时候，更好的方式就在离你不远的地方，就看你愿不愿意往前迈一步去探寻一下，也就是说不能将就，不要有「又不是不能用」的思维，做产品、学技能都是一样；</p><p>2、工作之后的很多技能的学习都是在不断解决问题中学会的，这样会让你慢慢变得很有经验，但不系统，即便某个领域感觉已经非常熟悉了，我觉得也有必要再看看书进行系统化学习，肯定能扫出很多盲点。</p><p>共勉。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;产品的各种环境使用了很多 &lt;code&gt;CentOS&lt;/code&gt; 虚拟机，默认情况下 &lt;code&gt;root&lt;/code&gt; 目录空间是 50 G，随着使用时间越来越长，空间会变得不够用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Docker" scheme="http://fwhyy.com/tags/docker/"/>
    
    <category term="运维" scheme="http://fwhyy.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>dotNET 升级利器：Upgrade Assistant</title>
    <link href="http://fwhyy.com/2023/03/dotnet-upgrade-assistant/"/>
    <id>http://fwhyy.com/2023/03/dotnet-upgrade-assistant/</id>
    <published>2023-03-20T03:29:39.000Z</published>
    <updated>2023-06-19T03:34:57.198Z</updated>
    
    <content type="html"><![CDATA[<p>.NET 发展很快, 现在 .NET 8 的预览版已经发布了，但我们现在还在使用 .NET Core 3.1，将 .NET 升级到 .NET 6 已经势在必行。</p><span id="more"></span><p>记得之前从 .NET Core 2.1 升级到 .NET Core 3.1 的时候，虽然网上有很多的教程，也废了一番力气，各种配置的修改，引用的第三方的库的升级等。</p><p>现在，在 VS2022 的扩展中有一个升级的工具：.NET Upgrade Assistant ，用来做 .NET 框架的升级，非常方便。</p><p>下面来讲解下怎样使用：</p><p>1、在 VS 2022 中进行 .NET Upgrade Assistant 的安装。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191131168.webp"></p><p>按照提示一路下一步即可：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191131132.webp"></p><p>2、创建一个 .NET Core 3.1 的 WebAPI 项目，在项目上点击右键就会出现 Upgrade 按钮：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191131938.webp"></p><p>3、在弹窗中选择升级方式，但也只有这一个选项啊：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191134375.webp"></p><p>4、选择升级的目标版本，这里我选择 .NET 6 ,这是一个长线支持版本：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191134478.webp"></p><p>5、选择需要更新的内容，默认全选，点击「Upgrade selection」进行升级：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191134726.webp"></p><p>6、瞬间，升级就完成了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191132693.webp"></p><p>7、上面的示例升级非常简单，我便马上尝试了产品的代码，多年的积累，产品的代码还是比较复杂的，引用的第三方库也比较多。我是按照项目的依赖关系，从最下层依次到上次进行升级，升级的过程很顺利，没有出现错误，但在编译时出现了两个错误：</p><ul><li>Ionic.zip 组件出现问题；</li><li>Swagger 相关的代码出现问题。</li></ul><p>Ionic.zip的问题是因为这个软件包已经被弃用，换成了 DotNet.zip 就可以了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191132795.webp"></p><p>重新安装 Swashbuckle.AspNetCore 最新的包，并按照 .NET 6 的方式注册，就可以解决了。</p><p>8、编译终于没问题了，程序启动的时候又报错了，原因是 BinaryFormatter 有安全漏洞过，已经不再支持：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191132237.webp"></p><p>有两种方式可以解决这个问题，第一种是直接停止在代码中使用 BinaryFormatter。可以使用 JsonSerializer 或 XmlSerializer  进行替代，具体可以参考：</p><p><a href="https://learn.microsoft.com/zh-cn/dotnet/core/compatibility/core-libraries/5.0/binaryformatter-serialization-obsolete">https://learn.microsoft.com/zh-cn/dotnet/core/compatibility/core-libraries/5.0/binaryformatter-serialization-obsolete</a></p><p>当然，如果代码中对 BinaryFormatter 依赖比较重，修改起来比较麻烦，还可以用一种兼容的方式进行处理，这是一种临时方式，不推荐，毕竟有安全漏洞。操作如下：</p><p>将下面代码加入到 Web 项目中的项目文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;EnableUnsafeBinaryFormatterSerialization&gt;true&lt;/EnableUnsafeBinaryFormatterSerialization&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191132611.webp"></p><p>上面代码添加后，便可忽略掉 BinaryFormatter 的安全性，让程序可以正常运行。</p><p>9、处理了上面几个编译好运行问题后，正常产品代码就从 .NET Core 3.1 升级到 .NET 6 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;.NET 发展很快, 现在 .NET 8 的预览版已经发布了，但我们现在还在使用 .NET Core 3.1，将 .NET 升级到 .NET 6 已经势在必行。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="dotNET" scheme="http://fwhyy.com/tags/dotnet/"/>
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>GPT-4 有什么不一样？</title>
    <link href="http://fwhyy.com/2023/03/gpt-4/"/>
    <id>http://fwhyy.com/2023/03/gpt-4/</id>
    <published>2023-03-15T03:19:15.000Z</published>
    <updated>2023-06-19T03:29:16.398Z</updated>
    
    <content type="html"><![CDATA[<p>一觉醒来，GPT-4 发布了。</p><p>GPT-4 和 GPT-3.5 都是由 OpenAI 开发的大型自然语言处理模型，它们能够理解和生成人类语言。尽管这两个模型在很多方面都相似，但它们之间还是存在一些关键区别：</p><span id="more"></span><p>1、更具创造力</p><p>尽管 GPT-3.5 的表达现已经让人惊艳，但 GPT-4 更具创造性和协作性。它可以生成、编辑和迭代用户的创造性和技术性写作任务，如创作歌曲，编写电影剧本，或学习用户的写作风格。</p><p>GPT-4 相较于 GPT-3.5 具有更多的参数，这使得 GPT-4 在处理复杂任务和生成更准确、自然的回答方面具有更强的能力。这种能力的提升通常会带来更高的准确性和更好的文本生成质量。</p><p>官网的例子很有趣:</p><p>用一个句子解释灰姑娘的情节，每个单词都必须以字母表中从 A 到 Z 的下一个字母开头，而不能重复任何字母。GPT-4 中给出的答案是：</p><blockquote><p>A beautiful Cinderella, dwelling eagerly, finally gains happiness; inspiring jealous kin, love magically nurtures opulent prince; quietly rescues, slipper triumphs, uniting very wondrously, xenial youth zealously.</p></blockquote><p>而在 3.5 中的结果是这样的，差距还是挺大的：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128458.webp"></p><p>2、多模态</p><p>简单说就是在 GPT-3.5 只能输入文本，而在 GPT-4 中可以同时输入文字和图片，输出文本。可以读懂图片中的信息，并结合输入的文本给出答案，比如：给出一个风景照，让 GPT-4 告诉这是什么地方，并制定一个旅行计划。</p><p>相信很快就能支持音频、视频，讲创造更多的可能性。</p><p>3、支持长文本</p><p>GPT-4能够处理超过25,000字的文本，允许用例如长形式的内容创建、扩展会话、文档搜索和分析。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128517.webp"></p><p>甚至可以直接让他读取一个链接的内容，并对内容进行总结：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128758.webp"></p><p>4、时效性</p><p>GPT-4 的最后训练时间为 2021 年 9 月，感觉和 GPT-3.5 差不多，我一开始还以为是最新的数据。</p><p>尽管如此，GPT-4 对自己更了解了，不知道的不会像 GPT-3.5 那样乱说，比如在 GPT-3 中我让评价下满江红这部电影：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128143.webp"></p><p>而在 GPT-4 中，结果更加客观：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128555.webp"></p><p>5、安全性</p><p>之前 GPT-3.5 经常会在一些诱导下输出些不好的内容，在这方面  GPT-4 表现更好，比 GPT-3.5 少 82% 的可能对不允许的内容做出回应，多 40% 的可能产生事实性回应。</p><p>现在要体验 GPT-4，有以下方式：</p><p>1、在 openai 的官网升级为 ChatGPT Plus ,有点小贵：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128080.webp"></p><p>2、poe.com 已经集成了 GPT-4 ，不过有使用限制，用一次之后要等若干个小时：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191128641.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一觉醒来，GPT-4 发布了。&lt;/p&gt;
&lt;p&gt;GPT-4 和 GPT-3.5 都是由 OpenAI 开发的大型自然语言处理模型，它们能够理解和生成人类语言。尽管这两个模型在很多方面都相似，但它们之间还是存在一些关键区别：&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ChatGPT" scheme="http://fwhyy.com/tags/chatgpt/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 应用合集</title>
    <link href="http://fwhyy.com/2023/03/chatgpt-app-collection/"/>
    <id>http://fwhyy.com/2023/03/chatgpt-app-collection/</id>
    <published>2023-03-13T02:26:54.000Z</published>
    <updated>2023-06-19T08:56:22.614Z</updated>
    
    <content type="html"><![CDATA[<p>最近用了一些 ChatGPT 的周边产品，挑几个感觉不错的分享下。</p><span id="more"></span><h2 id="1、Poe"><a href="#1、Poe" class="headerlink" title="1、Poe"></a>1、Poe</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117617.webp"></p><p>地址：<a href="https://poe.com/">https://poe.com</a></p><p>Poe 内置了 Sage、Claude、Dragonfly、和 ChatGPT 。其中，Sage 是基于 ChatGPT 简化版本的 AI 机器人。目前 Poe 移动端只支持 iOS，而且是非国区的，不过网页版可以用。</p><p>目前使用频率比较高的一个工具。</p><h2 id="2、Aski"><a href="#2、Aski" class="headerlink" title="2、Aski"></a>2、Aski</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117989.webp"></p><p>地址：<a href="https://aski.ai/">https://aski.ai/</a></p><p>Aski 是一款基于 OpenAI 的 GPT-3 自然语言处理模型的中文 AI 问答服务。回答快速，几乎无延迟。在问答服务之外，<strong>Aski</strong> 还提供了内容创作服务，支持内容写作、优化，最近又推出了绘画功能。目前，Aski 支持网页端、移动端。</p><p>缺点是收费，注册账号送 10 个 AI 币，有点太少了。</p><h2 id="3、风声雨声"><a href="#3、风声雨声" class="headerlink" title="3、风声雨声"></a>3、风声雨声</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117755.webp"></p><p>地址：<a href="https://fsys.app/translate">https://fsys.app/translate</a></p><p>可以对 epub 、txt 书籍进行翻译，亮点是提供书籍搜索功能，下载好书籍后，将书籍上传到系统，点击开始即可。</p><p>我尝试了下 Working Backwards 这本书，上传完成后根据字数有一个价格的估算，这本书的估算为 6.36 元，不算太贵。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191118148.webp"></p><h2 id="4、ChatHub"><a href="#4、ChatHub" class="headerlink" title="4、ChatHub"></a>4、ChatHub</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117959.webp"></p><p>这是 Chrome 浏览器的一个插件。</p><p>使用这个插件可以一次提问，同时获得 ChatGPT 和 New Bing 的回答。ChatGPT 需要配置自己的 Key 才可以。</p><h2 id="5、OpenGpt：一个AI应用合集"><a href="#5、OpenGpt：一个AI应用合集" class="headerlink" title="5、OpenGpt：一个AI应用合集"></a>5、OpenGpt：一个AI应用合集</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117960.webp"></p><p>地址：<a href="https://open-gpt.app/">https://open-gpt.app/</a></p><p>这个网站现在有 1000 多个应用，比如：写诗、取名、修改错别字、翻译等，按照使用场景分的很细，也可创建自己的应用。</p><p>每天每个用户免费使用 10 次，使用 自己的 API key 可以解除限制。</p><h2 id="6、you-com-的-chat-模块"><a href="#6、you-com-的-chat-模块" class="headerlink" title="6、you.com 的 chat 模块"></a>6、you.com 的 chat 模块</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117951.webp"></p><p>地址：<a href="https://you.com/">https://you.com</a></p><p>you.com 是一个搜索引擎，Chat 是这款搜索引擎中的一个模块。在 Chat 模块进行搜索，中间区域给给出一个最优答案，右侧也会有通过搜索引擎返回的结果列表。</p><h2 id="7、chatpdf"><a href="#7、chatpdf" class="headerlink" title="7、chatpdf"></a>7、chatpdf</h2><p>地址：<a href="https://www.chatpdf.com/">https://www.chatpdf.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117552.webp"></p><p>可以分析 PDF 文件的内容，提取内容，通过问答的方式对 PDF 内容进行学习，不过免费版有一些限制：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117482.webp"></p><p>所以我将《凤凰架构》这本书摘录了不到 50 页，上传后效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117786.webp"></p><h2 id="8、pandagpt"><a href="#8、pandagpt" class="headerlink" title="8、pandagpt"></a>8、pandagpt</h2><p>地址：<a href="https://www.pandagpt.io/">https://www.pandagpt.io/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117261.webp"></p><p>这个和 ChatPDF 有点类似，也是可以帮助我们来阅读 PDF 文件，免费版我将 《凤凰架构》整本书都上传成功了。同样，也是通过问答的方式进行使用：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117188.webp"></p><h2 id="9、周报生成器"><a href="#9、周报生成器" class="headerlink" title="9、周报生成器"></a>9、周报生成器</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191117832.webp"></p><p>地址：<a href="https://weeklyreport.avemaria.fun/zh">https://weeklyreport.avemaria.fun/zh</a></p><p>将一周所做的事情罗列下，就能生成一份很详细的周报，稍微改改就能用，有周报困扰的同学可以试试。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近用了一些 ChatGPT 的周边产品，挑几个感觉不错的分享下。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="ChatGPT" scheme="http://fwhyy.com/tags/chatgpt/"/>
    
    <category term="分享" scheme="http://fwhyy.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>读《沸腾十五年》</title>
    <link href="http://fwhyy.com/2023/03/read-boiling-for-fifteen-years/"/>
    <id>http://fwhyy.com/2023/03/read-boiling-for-fifteen-years/</id>
    <published>2023-03-09T02:24:40.000Z</published>
    <updated>2023-06-19T02:27:00.428Z</updated>
    
    <content type="html"><![CDATA[<p>《沸腾十五年》记录了中国互联网行业从 1995 年到 2009 年的发展历程，深入探讨了互联网行业的商业模式、技术发展、市场竞争等方面的问题，讲述了一群热血青年使用技术改变世界的故事。</p><span id="more"></span><p>它不仅仅是一本关于初代互联网人的创业史，也是一本关于互联网大佬们背后故事的八卦书，让读者有机会深入了解这个行业以及参与者的历史、文化和精神。</p><p>书中的大佬们的创业故事让人佩服，看得让人热血沸腾，但更令人佩服的是本书的作者——林军，他是互联网行业的资深媒体人和创业者，他用自己的亲身经历和深入采访，还原了那段波澜壮阔的时代，也挖掘了很多幕后的信息，让我们对现在已经耳熟能详的企业有更深的理解。</p><p>书中的内容非常丰富，与此同时，我也在这个时代的浪潮中不断接受互联网的洗礼。接下来，我想分享一些我印象深刻的事情：</p><p>1、1995 年被称为中国互联网元年，随着中国电信开通了北京、上海两个 Internet 节点，打开了互联网世界的大门，此时的我刚刚小学毕业，印象中电子产品有电子手表和俄罗斯方块的掌上游戏机，在相对落后的农村，电脑连听都没听说过。</p><p>2、随后的几年，丁磊从电信局离职，创办了网易；王志东创办四通利方，然后和华渊合并变成了大家所熟知的新浪；张朝阳也从硅谷回国，便有了搜狐的诞生，这就是当年互联网的三大门户网站。现在我还清晰地记得，高中时学校所在的镇上有了网吧，去上网时会将一些网址抄写到小本本上，三大门户肯定是在其中的。</p><p>3、除了浏览网页，另一个很流行的活动是使用 QQ 进行聊天。当时，还能申请到 7 位数的 QQ 号。马化腾在做 QQ 的时候肯定没有想到如今能有如此体量，更想不到现在微信成了国民应用。QQ 的厉害还体现在架构上，1998 年张志东设计的 QQ 架构在 10 几年后用户量级过亿仍然适用，真的是不可思议。</p><p>4、从产品本身来说，QQ 最初只是模仿了 ICQ ，但在模仿之后并没有止步于简单的复制或跟随他人的步伐，而是根据中国市场和用户需求不断进化。这就是创新，包括后来的团购、各类互联网 SaaS 应用，大多都是先模仿国外的产品，然后进行本土化改造。所以说，学习好英语非常重要，会打开另一扇门，获得更多的信息，利用好这个信息差，就会创造出很多的机会。</p><p>5、2010 年的 3Q 大战曾轰动一时，其中一方是奇虎360，创始人周鸿祎在早些年还弄过一个产品叫 3721，被很多网友诟病，被称为流氓软件，其背后的原因是为了流量而忽略了用户体验，在网页中利用脚本强制弹窗让用户安装插件，小白用户点击同意莫名其妙安装了软件，资深用户点击拒绝，下次打开网页还会继续弹窗，确实挺讨厌的。最后，3721 被雅虎收购。</p><p>6、一上大学，就有了自己的电脑，计算机专业成了一个买电脑很好的理由。宿舍里电话线拨号上网，印象最深的就是网速特别慢。那会，姚明加入 NBA ，一堆人凑在电脑前，看着不断缓冲且模糊的直播画面，也津津有味。</p><p>7、大学期间，因为网速慢，将资源下载到本地变成了刚需，出现了很多像华军、天空这类的资源站，也出现了很多下载工具：网际快车、网络蚂蚁、快驴等，但迅雷后来者居上，成为了当时最受欢迎的下载工具，就是因为下载速度快。哪怕没有占得先机，在一个用户痛点上下功夫，做到极致，也是有机会的。</p><p>8、百度一直被吐槽，著名的骨灰级程序员左耳朵耗子曾写过一篇文章《作环保的程序员，从不用百度开始》，可见对百度的痛恨之深。尽管如此，百度是我接触互联网时用的第一个搜索引擎，现在使用人数应该也是最多的，特别是非技术人员。</p><p>9、书中讲述李彦宏签订第一轮投资前，投资人和李彦宏的对话令我印象深刻，投资人对李彦宏说：“搜索引擎技术的前三名，一定有你”。在吐槽的背后，不能忽视百度的技术能力，最近 ChatGPT 很火，冯大辉也在公众号文章提到百度在 ChatGPT 这个风口会更能占得先机，在自然语言处理（NLP）领域，百度是唯一一家拥有全栈 AI 技术架构的公司，而且也推出了类 ChatGPT 的服务：文心一言。</p><p>10、豆瓣在互联网绝对是一个独特的存在，创始人阿北是个文艺青年，所以豆瓣一直都有着文艺的气质。技术上也比较激进，选择了当时还比较小众的 Python ，在成熟技术和新技术之间一定是选择新技术，因为他们认为新的技术出现必然是为了解决原有成熟技术的某些问题。豆瓣对开源是积极拥抱的态度，优先选择开源技术，自研技术只要是非业务相关的也全部开源。</p><p>11、豆瓣的开源精神是融入到骨子里、文化中的，印象比较深刻的是内部自发的开源项目 Code，工程师喝酒聊天聊需求，然后自发地认领，做完后提交 pull request ，就这样用业余时间做了一个基于 git 版本控制系统的协作平台，现在在 GitHub 上开源了。</p><p>12、我 2007 年成为豆瓣用户，那会已经工作了，到现在十几年，虽然不算是深度用户，但也一直陪伴着，用的多的功能还是刚推出时的电影、书籍。</p><p>13、开心网的火爆是在 2008 年到 2009 年，当时在一家小公司，有着一个很好的老板和关系融洽的同事们，每天工作之余偷菜、停车，不亦乐乎，现在都还很怀念那段时光。看完本书才发现原来当时的真假开心网是因为资金不足没有买到正牌域名。</p><p>14、读完后，发现书中的创业者或者企业家，要么有高学历，要么拥有强大的家庭背景，或者出国留学过，这些因素在他们的创业路上提供了很多便捷，普通人如果想要取得这样的成绩，除了要付出加倍的努力外，更多的是需要运气。</p><p>15、在这本书结束的 2009 年后，互联网仍然在飞速地进步和发展着，包括人工智能、移动互联网、区块链、5G、元宇宙、Web3，还有最近火爆的 ChatGPT 更是一项具有革命性的技术创新。我相信技术的进步能让我们变得更加自由。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《沸腾十五年》记录了中国互联网行业从 1995 年到 2009 年的发展历程，深入探讨了互联网行业的商业模式、技术发展、市场竞争等方面的问题，讲述了一群热血青年使用技术改变世界的故事。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
    <category term="互联网" scheme="http://fwhyy.com/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>使用微软的 New Bing</title>
    <link href="http://fwhyy.com/2023/03/try-microsoft-new-bing/"/>
    <id>http://fwhyy.com/2023/03/try-microsoft-new-bing/</id>
    <published>2023-03-06T00:13:47.000Z</published>
    <updated>2023-06-19T02:24:20.711Z</updated>
    
    <content type="html"><![CDATA[<p>ChatGPT 现在大家都已经非常熟悉了了，走到哪都能听到讨论的声音，是基于 GPT3.5 的一个语言模型。微软在 2 月推出的新必应（New Bing）是一个基于 GPT4（猜测）模型的搜索和聊天工具，它可以提供更准确和实时的搜索结果，并且集成了Edge 浏览器的数据资源。</p><p>最近申请了 New Bing 简单试用  ，觉得还挺不错的。</p><h2 id="申请"><a href="#申请" class="headerlink" title="申请"></a>申请</h2><p>可以按照下面的步骤来进行新必应（New Bing）的申请：</p><p>1、先下载并安装 Edge 浏览器 dev 版本，在：<a href="https://www.microsoftedgeinsider.com/zh-cn/download/dev">Microsoft Edge 预览体验成员 (microsoftedgeinsider.com)</a>  进行下载安装：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008420.webp"></p><p>2、打开浏览器的设置-&gt;关于，可以进行 New Bing 使用的申请：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008517.webp"></p><p>3、登录后加入候补名单：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008380.webp"></p><p>4、然后就是等待，很幸运，一天的时间就通过了申请，使用界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008300.webp"></p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>New Bing 的主题功能分为聊天、撰写和见解。</p><h3 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h3><p>和 ChatGPT 类似，使用问答的形式进行交互，除了基础的输入框进行提问外，还能设置响应的语气。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008948.webp"></p><h3 id="撰写"><a href="#撰写" class="headerlink" title="撰写"></a>撰写</h3><p>将文字的创作单独剥离出来，提供更多的配置选项，更方便使用：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008833.webp"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a>实时性</h3><p>在聊天功能中，虽然和 ChatGPT 一样都是问答的模式，但它可以实时访问网络数据，找到 ChatGPT 没见过的数据，更加实时。</p><p>例如：我们分别让 New Bing 和 ChatGPT 评价下春节档的电影《满江红》就能看出区别了。</p><p>ChatGPT 并不知道春节上映的电影《满江红》，因为它的语言模型是 2021 年训练的，但可怕的是 ChatGPT 并不知道自己不知道，仍然会胡说八道一通。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008681.webp"></p><p>而在 New Bing 中，能够搜索到最新的信息，还能给出出处链接：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008192.webp"></p><h3 id="互动性"><a href="#互动性" class="headerlink" title="互动性"></a>互动性</h3><p>在问答的过程中 ，New Bing 会给出一些推荐的关键词来和我们进行互动，我们可以通过给出的关键词进一步和 New Bing 进行互动，也可以自己输入新的问题。</p><h3 id="准确性"><a href="#准确性" class="headerlink" title="准确性"></a>准确性</h3><p>New Bing 会根据你提的问题结合搜搜引擎和基础语言模型，最终组成答案进行输出，而且在答案中会给出来源出处，点击链接可以进入到原始网页进行查看。</p><h3 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h3><p>在网页中打开一篇文章，可以让 New Bing 来协助我们进行阅读，总结文章的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008153.webp"></p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>1、2 月 18 日，微软通过官方博客宣布，基于 AI 的新版必应对话功能将加入问答限额，每天最多回答 50 次问题，每次连续对话最多回答 5 个问题。微软称，根据统计，绝大多数用户都能在 5 轮问答内找到满意答案，只有大约 1% 的对话产生超过 50 条消息；定期清除对话记录有助于避免模型产生混淆。</p><p>2、回答的效果上好像也做了些调整，变得相对严肃，记得刚出来时，看了 B 站一个视频，它的风格是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008278.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202306191008563.webp"></p><p>3、账号容易被封，就在我写这篇文章的时候，我的账号已经是不能使用了，一些网友给出的最有效的解决方式就是申请一个新的账号。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>ChatGPT、New Bing、国内的 MOSS、Google 的 Bard ，Notion 也推出了 AI ，相信很快，更多的、更易用的各种应用都会来到我们身边，真的感觉 AI 新纪元要来临了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ChatGPT 现在大家都已经非常熟悉了了，走到哪都能听到讨论的声音，是基于 GPT3.5 的一个语言模型。微软在 2 月推出的新必应（New Bing）是一个基于 GPT4（猜测）模型的搜索和聊天工具，它可以提供更准确和实时的搜索结果，并且集成了Edge 浏览器的数据资源</summary>
      
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT 是什么？越来越清晰了</title>
    <link href="http://fwhyy.com/2023/02/what-is-chatgpt-its-getting-clearer/"/>
    <id>http://fwhyy.com/2023/02/what-is-chatgpt-its-getting-clearer/</id>
    <published>2023-02-21T00:09:55.000Z</published>
    <updated>2023-06-18T23:11:42.740Z</updated>
    
    <content type="html"><![CDATA[<p>两个月前，ChatGPT 刚出来不久，我便注册试用了，在《尝鲜 ChatGPT》中介绍了注册的过程和简单使用的示例。</p><p>最近，ChatGPT 越来越火了，朋友圈、公众号、微博、即刻随处可见关于 ChatGPT 的信息。我也看了不少关于 ChatGPT 的文章，一些疑问也得到解答。</p><h2 id="活跃用户"><a href="#活跃用户" class="headerlink" title="活跃用户"></a>活跃用户</h2><p>ChatGPT 用 2 个月达到月活用户 1 亿，此前记录是 TikTok 用时 9 个月，很多新闻中都提到了这个 1 亿用户来吸引眼球。</p><p>需要说明的是，这里的月活用户不是指注册用户，可能还包含爬虫、游客等。即便如此，我认为也不会是一个很少的数量级，加上最近各大媒体报道，各种注册服务的推出，估计也差不太多。</p><p>关于用户，大辉的这篇文章有详细讲述：</p><p><a href="https://mp.weixin.qq.com/s/iBmJEa4AzZKSO4nfKtCZDQ">https://mp.weixin.qq.com/s/iBmJEa4AzZKSO4nfKtCZDQ</a></p><h2 id="和搜索引擎的对比"><a href="#和搜索引擎的对比" class="headerlink" title="和搜索引擎的对比"></a>和搜索引擎的对比</h2><p>ChatGPT 的使用方式是面向一个文本框，用提问来进行交互；搜索引擎也是一个文本框，通过输入关键字来进行检索。看着很类似，其实有很大差别。</p><p>有几个重要的区别是：</p><ul><li>ChatGPT 因为训练一次，费用昂贵，所以 ChatGPT 不是实时的，而搜索引擎的时效性很高；</li><li>ChatGPT 是基于语义分析，搜索引擎是基于关键字索引；</li><li>ChatGPT 会给一个最优解，搜索引擎的结果为多条符合关键字匹配的内容，我们需要自己对结果进行分析、辨别，然后对比、合并、重新理解，最终得到一个答案；</li><li>ChatGPT 可以基于上下文进行追问，让他知道我们的真实需求，结果也会不断进行优化，搜索引擎只能调整关键字，得到新的结果；</li><li>ChatGPT 仅仅是个结果，搜索引擎会有来源链接。</li></ul><p>不管是 ChatGPT 还是搜索引擎，都是辅助我们的工具，这两者不是对立的，而是各有各的使用场景。</p><p>例如：我要查询天气、看看日历、行业最新资讯等，我肯定用搜索引擎；如果我要写一个很特殊的正则表达式或 Sql ，我就会使用 ChatGPT ，因为我可以通过一大段描述，将我的场景写清楚，ChatGPT 可以理解并给出一个还不错的答案，甚至是一个开箱即用的答案。</p><h2 id="是否能取代程序员？"><a href="#是否能取代程序员？" class="headerlink" title="是否能取代程序员？"></a>是否能取代程序员？</h2><p>记得在低代码比较火热的时候，就有低代码平台是否会跟程序员抢饭碗的话题。几年前，我们去给客户推荐我们的产品，一些有研发能力的客户会比较抵触。</p><p>现在 ChatGPT 火了，大家又开始讨论程序员是不是会被取代？</p><p>上面我也说到，和搜索引擎一样，ChatGPT 只是一个工具，既然是工具就会被人所使用，是为了提高人的创造力和生产力，为我们服务的。</p><p>举两个例子：</p><ul><li>农业机械化生产后，拿着锄头到地里干活的人少了，但会需要操作机器的人；</li><li>低代码流行后，落地一个项目，需要的程序员变少了，但会需要更多的配置和搭建的人员，相比程序员，这些人员的成本更低；</li></ul><p>ChatGPT 也是一样，无论怎么发展，只要利用好，效率会成百上千倍的增长，并且会滋生出来很多新的职业和岗位。</p><p>程序员的日常工作就是把人的诉求通过编程语言表达出来传递给电脑，电脑运算出结果，而 ChatGPT 能够分析语义，这让人的诉求到电脑能够理解这个过程变得容易了，这也就是为什么王建硕会说未来十年中国会新增五亿程序员了，因为借助工具，更多的人都能更电脑进行交互了。</p><h2 id="我们该做些什么？"><a href="#我们该做些什么？" class="headerlink" title="我们该做些什么？"></a>我们该做些什么？</h2><p>一个新的技术出来，有这么三类人：</p><ul><li><p>找到缝隙，赢得先机，狠狠地赚一笔；</p></li><li><p>杞人忧天，各种担心；</p></li><li><p>利用好技术，提升效率。</p></li></ul><p>ChatGPT 因为在国内注册不方便，就有人专门做了收费服务，帮助注册，据说一个月赚几十万。也有人还在想着自己会不会被取代，对我而言，我把 ChatGPT 当成一个效率工具，使用好他就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ChatGPT 是一个开始，可能还会带来革命性的改变。就像蒸汽机引发了工业革命，改变人类的生产方式、浏览器的诞生催生了互联网的发展；乔布斯发布 iPhone 后，宣告了移动互联网的来临。</p><p>但在眼下，我们可以做些力所能及的，比如：将 ChatGPT 集成到微信群，尝试使用下微软发布的 New Bing 。</p><p>未来是什么样，拭目以待。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;两个月前，ChatGPT 刚出来不久，我便注册试用了，在《尝鲜 ChatGPT》中介绍了注册的过程和简单使用的示例。&lt;/p&gt;
&lt;p&gt;最近，ChatGPT 越来越火了，朋友圈、公众号、微博、即刻随处可见关于 ChatGPT 的信息。我也看了不少关于 ChatGPT 的文章，一</summary>
      
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="ChatGPT" scheme="http://fwhyy.com/tags/chatgpt/"/>
    
    <category term="AI" scheme="http://fwhyy.com/tags/ai/"/>
    
  </entry>
  
  <entry>
    <title>深入接触客户才能做出好的产品</title>
    <link href="http://fwhyy.com/2023/02/deep-contact-with-customers-can-make-good-products/"/>
    <id>http://fwhyy.com/2023/02/deep-contact-with-customers-can-make-good-products/</id>
    <published>2023-02-17T00:07:22.000Z</published>
    <updated>2023-06-19T02:24:23.127Z</updated>
    
    <content type="html"><![CDATA[<p>近些年一直在负责开发低代码平台产品，面向的是企业用户，这款产品一方面给公司内部使用，提升项目交付效率，另一方面，一些合作伙伴或有开发能力的甲方，可以借助我们的产品进行系统的开发，给业务部门使用。</p><p>产品的定位非常明确，能够提升交付效率，协助企业进行数字化转型。</p><p>正因为是面向企业用户，所以产品的功能增加不能闭门造车，需要深入地接触客户，了解他们的痛点和诉求，再反向体现到产品功能上。</p><p>前些天，和公司销售一起拜访了几家公司的重点客户，有些感触。</p><h2 id="开始注重效率"><a href="#开始注重效率" class="headerlink" title="开始注重效率"></a>开始注重效率</h2><p>记得早些年做企业的信息化建设，更多的是注重将线下办公搬到线上，现在大多数企业已经是在线上办公，就更注重提升整体的流程效率。</p><p>企业的增效体现在很多方面，这里主要说的是流程方面的效率，客户其实是很有想法的：</p><ul><li><p>纵向上，按照业务线，将跨不同系统的流程进行拉通，会涉及到各种对接、集成；</p></li><li><p>横向上，以某个业务点进行扩散，找出关联业务数据进行展示。</p></li></ul><p>信息化、工作流尽管做了很多年，我感觉还是能挖掘出很多对客户有价值的功能。</p><p>针对流程本身来说，也可以通过数据的支撑反向找出效率的瓶颈点，比如：</p><ul><li>设置超时阈值，从流程到节点到组织和人，找出耗时长的任何事，通过监督来提升效率；</li><li>通过流程的通过率，可以找出表单设计或流程设计上的不合理，然后进行优化；</li><li>如果有些节点通过率 100%，而且几乎不耗时，这种节点可能没有存在的必要；</li></ul><p>除此之外，现在还有专门的公司做 RPA 流程机器人和对流程数据的 AI 智能分析，如何将这些工具和现有的流程平台进行融合，也是值得思考的。</p><h2 id="数据驱动业务"><a href="#数据驱动业务" class="headerlink" title="数据驱动业务"></a>数据驱动业务</h2><p>随着客户信息化越来越成熟，各类系统中都产生了大量的数据。怎样让这些数据能活起来，为企业所用，这是客户很关注的问题。</p><p>一些有开发能力的客户已经在在自己做数据层的东西，底层构建数据仓库，上层提供图形化展示。</p><p>现在很多的低代码平台中都提供有 BI 模块，大多数都是展示层，我们的产品中也有对应的模块，相比较专业 BI 产品，功能还是偏弱。为什么都喜欢做数据展示？首先是技术难度不是很高，但更重要的是领导喜欢看大屏展示，最终决策、掏钱的是领导。</p><p>在低代码产品中，我认为重要的是能扩展和集成，产品本身不适合在这方面去发力。一个产品如果什么都想做，最终什么都做不好。做自己擅长的事情，然后集各家所长，必能成事，做产品如此，做人也是。</p><h2 id="信息孤岛问题依然存在"><a href="#信息孤岛问题依然存在" class="headerlink" title="信息孤岛问题依然存在"></a>信息孤岛问题依然存在</h2><p>大型国企现在还存在信息孤岛问题，这个是我没有想到的。</p><p>传统企业的信息做了好多年了，10 年前跟客户宣讲，都在说要解决信息孤岛问题。这么多年过去，还是有很多企业忙于解决各种问题，上了几十上百套系统，但系统之间还没有很好地进行联通，甚至连基本的待办消息集成都没有做。</p><p>在低代码产品中，添加 SSO、组织机构同步、消息接入等已经算是标配了。但要做好集成不是件容易的事情，涉及到很多利益方，搞定了人，才能搞定事。</p><h2 id="客户更希望在整体规划上能提供指导"><a href="#客户更希望在整体规划上能提供指导" class="headerlink" title="客户更希望在整体规划上能提供指导"></a>客户更希望在整体规划上能提供指导</h2><p>最近在一个视频号听一个大佬讲：技术人员的一个终极梦想就是做架构师 ，相比技术架构，现在售前架构师、企业解决方案架构师越来越吃香。</p><p>原因就是，客户也不知道要做啥？怎么做？提出的都是一些很宏观的目标，或者直接让提供相关的规划方案。</p><p>这其实对售前的要求非常高，要懂客户的行业，了解他们的痛点，能提供解决方案，这样就能牵着客户走，也能得到客户的信任，这种信任会为后续的项目实施带来极大的便利。</p><p>反之，在客户不清楚自己想要什么的情况下，售前还只是听客户讲，拿笔记录，最终交付的东西，客户总是认为不是自己想要的，而我们就会埋怨客户总是在进行需求变更。这种情况下，极少数是客户故意刁难，大多数都是没有真正理解客户的意图导致。</p><p>因为样本足够小，以上可能都是错的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近些年一直在负责开发低代码平台产品，面向的是企业用户，这款产品一方面给公司内部使用，提升项目交付效率，另一方面，一些合作伙伴或有开发能力的甲方，可以借助我们的产品进行系统的开发，给业务部门使用。&lt;/p&gt;
&lt;p&gt;产品的定位非常明确，能够提升交付效率，协助企业进行数字化转型。&lt;</summary>
      
    
    
    
    <category term="思考" scheme="http://fwhyy.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
    <category term="产品" scheme="http://fwhyy.com/tags/%E4%BA%A7%E5%93%81/"/>
    
    <category term="低代码" scheme="http://fwhyy.com/tags/%E4%BD%8E%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>
