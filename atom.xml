<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冯威的博客</title>
  
  <subtitle>公众号：不止dotNET | 临渊羡鱼不如退而结网</subtitle>
  <link href="http://fwhyy.com/atom.xml" rel="self"/>
  
  <link href="http://fwhyy.com/"/>
  <updated>2023-11-24T08:45:19.863Z</updated>
  <id>http://fwhyy.com/</id>
  
  <author>
    <name>oec2003</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>半马连续两周 PB 后的复盘</title>
    <link href="http://fwhyy.com/2023/11/marathon-pb-review/"/>
    <id>http://fwhyy.com/2023/11/marathon-pb-review/</id>
    <published>2023-11-23T08:41:28.000Z</published>
    <updated>2023-11-24T08:45:19.863Z</updated>
    
    <content type="html"><![CDATA[<p>最近，连续跑了两个半马比赛，都 PB 了，个人最好成绩也定格在了 11 月 12 日的南昌马拉松半马，成绩为 142 。</p><p>一直以来，我跑步比较佛系，夏天跑的少、冬天也跑的少，报了比赛就临时突击下，所以总跑量不多。这些年，线上线下，陆陆续续也跑了 29 场半马，但直到今年 4 月宜昌马拉松半程才跑进两小时。</p><span id="more"></span><p>所以说，针对半马而言，如果只是想完赛，还是挺容易，但想要跑出好的成绩，就必须有科学的训练。</p><p>今年 8 月在朋友的带动下，制定了相对正式的训练计划，同时，每天上下班途中在小宇宙听《跑者日历》、《PB计划》，也学习到了不少跑步知识。这些都为 11 月 5 号的黄冈半程和 11 月 12 号的南昌半程 PB 打下了基础。</p><h2 id="科学训练"><a href="#科学训练" class="headerlink" title="科学训练"></a>科学训练</h2><p>关于马拉松训练，目前了解到的有丹尼尔斯训练法和汉森马拉松训练法，因为没有完全吃透，也就没敢冒然网上的一些课表来执行，所以制定的计划是按照自己的实际情况和理解来规划的：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311221832184.webp"></p><ul><li>训练以周为单位，每周一个周期</li><li>每周以有氧慢跑为主</li><li>周末跑一个长距离（LSD），我通常都会跑一个半马</li><li>每周一到两次的强度，间歇或者接近目标马拉松配速的节奏跑</li><li>十一之后，增加了一点点力量的练习，强大的腿部力量和核心，可以让我们跑步不受伤，还能提升成绩</li><li>在我的带动下，老婆也加入了跑步的队伍，每天早上我跑步完后，送小孩上学，然后和老婆一起跑，上图中蓝色字体为和老婆一起跑的公里数</li></ul><h2 id="量变到质变"><a href="#量变到质变" class="headerlink" title="量变到质变"></a>量变到质变</h2><p>对我这种多少年都跑不进 2 小时的爱好者来说，跑量的积累是提升成绩最有效的方式。我看了下 9 月和 10 月的跑量，都超过了 200 公里 ：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311221833254.webp"></p><p>正式因为有了跑量的保证，在 10 月 14 号能跑出 450 配速的 10 公里，在 10 月 21 号能跑出 451 配速的 15 公里。</p><p>这两次的测试，让我对在比赛中跑进 145 充满了信心。</p><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>马拉松比赛在国内越来越火热，加上疫情的放开，更是一签难求。下半年所有报名只有南昌中签了，然后又报了一个不用抽签的黄冈半程马拉松。</p><h3 id="黄冈半程"><a href="#黄冈半程" class="headerlink" title="黄冈半程"></a>黄冈半程</h3><p>黄冈半程是在 11 月 5 号举行，为这场比赛做了充足的准备：</p><p>1、赛前很长的一段时间一直都在关注黄冈的天气；</p><p>2、赛前一周跑量减少，间歇只做 5组，还跑了一次 5 公里的马拉松配速跑；</p><p>3、赛前饮食上尽量多补充碳水。</p><p>结果比赛当天，尽管没下雨，但气温也没有预报的那么低，起跑的时候已经有 19 度了，湿度很大，很闷，赛道也没有想象中的那么平坦。最后结果离目标有一点点差距。当然主要还是训练不够，水平太菜。</p><p>10 公里后，配速就在 5 分开外了，15 公里后想要提速已经提不动了，只能维持在 5 分左右的配速跑完，最终 1 小时 45 分 42 秒完赛，比 4 月的宜昌半马 PB 了 12 分钟。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311221833667.webp"></p><h2 id="南昌半马"><a href="#南昌半马" class="headerlink" title="南昌半马"></a>南昌半马</h2><p>南昌半马就在黄冈比赛完的下一周，中间这一周因为下雨，只慢跑了一个 7 公里，而且天气预报显示 12 号有雨，气温更是低到 10 度以下。</p><p>这些因素已经让我放弃了 PB 的想法，想着安全完赛就好。</p><p>11 号开车到达南昌的时候还在下雨，晚上大概 7 点雨就停了，一直到第二天离开南昌都没有再下，这才有机会在比赛结束后去了滕王阁和万寿宫。</p><p>12 号一早，气温 10 度左右，气温低，跑起来体感却特别舒服，时不时还有一阵冷风刮来，立马就精神了。</p><p>可能是气温低的原因，快到 10 公里的时候，大腿有快要抽筋的感觉，赶紧补充了盐丸和能量胶，看来是盐丸发挥了作用，继续跑了几公里后，腿部没有不适的感觉，最后一公里还跑出了最快配速 430 。最后成绩 1 小时 42 分 25 秒，比一周前的黄冈半马 PB 了 3 分钟。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311221833442.webp"></p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>系统学习跑步的方法和技巧，除了公众号、播客这种零碎的知识获取外，最好的方式就是看书，我选了一些还不错的跑步相关书籍放在豆列中，这些书大多在微信读书中都有，豆列地址如下：</p><p><a href="https://www.douban.com/doulist/157036945/">https://www.douban.com/doulist/157036945/</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>跑步的目的是为了健康，可不能本末倒置了，遇到伤病，该停就停，该歇就歇。在保证健康的前提下再来追求成绩，当然，也可以完全不用追求成绩，跑起来就好。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近，连续跑了两个半马比赛，都 PB 了，个人最好成绩也定格在了 11 月 12 日的南昌马拉松半马，成绩为 142 。&lt;/p&gt;
&lt;p&gt;一直以来，我跑步比较佛系，夏天跑的少、冬天也跑的少，报了比赛就临时突击下，所以总跑量不多。这些年，线上线下，陆陆续续也跑了 29 场半马，但直到今年 4 月宜昌马拉松半程才跑进两小时。&lt;/p&gt;</summary>
    
    
    
    <category term="跑步" scheme="http://fwhyy.com/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
    <category term="马拉松" scheme="http://fwhyy.com/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
  </entry>
  
  <entry>
    <title>.NET8 正式发布， C#12  新变化</title>
    <link href="http://fwhyy.com/2023/11/dotnet-8/"/>
    <id>http://fwhyy.com/2023/11/dotnet-8/</id>
    <published>2023-11-17T08:38:50.000Z</published>
    <updated>2023-11-24T08:40:14.838Z</updated>
    
    <content type="html"><![CDATA[<p>在  .NET Conf  2023  大会上，.NET 8 正式发布了，.NET 8 是一个长期支持（LTS）版本，这意味着可以获得三年的支持和补丁。我们也计划将框架从 .NET Core3.1 升级到 8 ，关于如何升级等升级完成后再来分享。</p><span id="more"></span><p>要使用 .NET 8 ，需要安装相关的 SDK，可以在这个地址进行下载：<a href="https://dotnet.microsoft.com/zh-cn/download/dotnet/8.0%EF%BC%8C%E6%88%96%E8%80%85%E5%B0%86">https://dotnet.microsoft.com/zh-cn/download/dotnet/8.0，或者将</a> VS2022 升级到 17.8 。</p><p>虽然 8 又带来了很多方面的增强，比如：人工智能、云原生、性能、native AOT  等，但我还是最关注  C# 语言和一些框架层面的变化，下面介绍下 C# 12 和框架中的我认为比较实用的新增功能，全部更新说明可以看官方文档：<a href="https://learn.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-8">https://learn.microsoft.com/zh-cn/dotnet/core/whats-new/dotnet-8</a> 。</p><h2 id="序列化增强"><a href="#序列化增强" class="headerlink" title="序列化增强"></a>序列化增强</h2><h3 id="其他类型的内置支持"><a href="#其他类型的内置支持" class="headerlink" title="其他类型的内置支持"></a>其他类型的内置支持</h3><p>1、可以对附加类型：Half、Int128、UInt128 进行序列化，在 .NET 7 中对这些类型序列化时不会报错，但内容不能正常获取；</p><p>2、可以对 ReadOnlyMemory<T> 、Memory<T>  类型进行序列化；</p><p>3、当  T  的类型为  byte  时，序列化结果为  base64，否则为  json 数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using System.Text.Json;</span><br><span class="line">//输出：[65500,170141183460469231731687303715884105727,340282366920938463463374607431768211455]</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(new object[] &#123; Half.MaxValue, Int128.MaxValue, UInt128.MaxValue &#125;));</span><br><span class="line">//输出：&quot;AQIDBAUG&quot;</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize&lt;ReadOnlyMemory&lt;byte&gt;&gt;(new byte[] &#123; 1,2,3,4,5,6&#125;));</span><br><span class="line">//输出：[1,2,3]</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize&lt;Memory&lt;int&gt;&gt;(new int[] &#123; 1, 2, 3 &#125;)); </span><br></pre></td></tr></table></figure><h4 id="接口层次结构"><a href="#接口层次结构" class="headerlink" title="接口层次结构"></a>接口层次结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">IDerived value = new DerivedImplement &#123; Base = 0, Derived = 1 &#125;;</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(value));</span><br><span class="line">//输出：&#123;&quot;Base&quot;:0,&quot;Derived&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">public interface IBase</span><br><span class="line">&#123;</span><br><span class="line">    public int Base &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IDerived : IBase</span><br><span class="line">&#123;</span><br><span class="line">    public int Derived &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DerivedImplement : IDerived</span><br><span class="line">&#123;</span><br><span class="line">    public int Base &#123; get; set; &#125;</span><br><span class="line">    public int Derived &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、上面代码中 IDerived 接口继承了 IBase 接口后，就拥有两个属性了；</p><p>2、在之前的版本（3.1、6、7）中使用包含两个属性的接口 IDerived 来接收对象的实例化，然后进行序列化，得到的结果只有：{Derived”:1} ，继承过来的属性 Base 不能被识别；</p><p>3、在 8 中得到了改进，可以得到期望的结果，值得注意的是，如果之前使用了变通方式来进行处理，升级后需要有针对性进行测试和调整。</p><h3 id="命名策略"><a href="#命名策略" class="headerlink" title="命名策略"></a>命名策略</h3><p>下图是 8  中序列化时对命名策略的支持：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311161902851.webp"></p><p>在之前的版本：3.1、6、7  中都只支持 CamelCase 。在  8  中新增的策略如下：</p><ul><li>KebabCaseLower：小写中划线，例如：user-name</li><li>KebabCaseUpper：大写中划线，例如：USER-NAME</li><li>SnakeCaseLower：小写中划线，例如：user_name</li><li>SnakeCaseUpper：大写中划线，例如：USER_NAME</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var options1 = new JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    PropertyNamingPolicy = JsonNamingPolicy.KebabCaseLower,</span><br><span class="line">&#125;;</span><br><span class="line">var options2 = new JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    PropertyNamingPolicy = JsonNamingPolicy.KebabCaseUpper,</span><br><span class="line">&#125;;</span><br><span class="line">var options3 = new JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,</span><br><span class="line">&#125;;</span><br><span class="line">var options4 = new JsonSerializerOptions</span><br><span class="line">&#123;</span><br><span class="line">    PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseUpper,</span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(new UserInfo() &#123; UserName = &quot;oec2003&quot; &#125;, options1));</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(new UserInfo() &#123; UserName = &quot;oec2003&quot; &#125;, options2));</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(new UserInfo() &#123; UserName = &quot;oec2003&quot; &#125;, options3));</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(new UserInfo() &#123; UserName = &quot;oec2003&quot; &#125;, options4));</span><br><span class="line"></span><br><span class="line">public class UserInfo</span><br><span class="line">&#123;</span><br><span class="line">    public string? UserName &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311161902664.webp"></p><h3 id="调用-API-直接获取到对象"><a href="#调用-API-直接获取到对象" class="headerlink" title="调用 API 直接获取到对象"></a>调用 API 直接获取到对象</h3><p>现在有一个接口返回如下图中的数据：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311161905910.webp"></p><p>如果是在 8 以前的版本中获取该接口的数据，需要先获取到接口内容，然后进行反序列化，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const string RequestUri = &quot;http://localhost:5145/user&quot;;</span><br><span class="line">using var client = new HttpClient();</span><br><span class="line">var stream =await client.GetStreamAsync(RequestUri);</span><br><span class="line">//反序列化</span><br><span class="line">var users = JsonSerializer.DeserializeAsyncEnumerable&lt;UserInfo&gt;(stream);</span><br><span class="line">await foreach(UserInfo user in users)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;姓名：&#123;user.userName&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">public record UserInfo(string userName);</span><br></pre></td></tr></table></figure><p>在版本 8  中可以直接调用 GetFromJsonAsAsyncEnumerable 方法直接得到对象，无需进行反序列化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const string RequestUri = &quot;http://localhost:5145/user&quot;;</span><br><span class="line">using var client = new HttpClient();</span><br><span class="line">IAsyncEnumerable&lt;UserInfo&gt; users = client.GetFromJsonAsAsyncEnumerable&lt;UserInfo&gt;(RequestUri);</span><br><span class="line"></span><br><span class="line">await foreach (UserInfo user in users)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;姓名： &#123;user.userName&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">public record UserInfo(string userName);</span><br></pre></td></tr></table></figure><p>上面两种代码的结果一样，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311161902548.webp"></p><h2 id="随机数增强"><a href="#随机数增强" class="headerlink" title="随机数增强"></a>随机数增强</h2><p>1、在 8 中对随机数类 Random 提供了 GetItems<T>() 方法，可以根据指定的数量在提供的一个集合中随机抽取数据项生成一个新的集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReadOnlySpan&lt;string&gt; colors = new[]&#123;&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Black&quot;&#125;;</span><br><span class="line"></span><br><span class="line">string[] t1 = Random.Shared.GetItems(colors, 10);</span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(t1));</span><br><span class="line"></span><br><span class="line">//输出：[&quot;Black&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Blue&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Green&quot;,&quot;Black&quot;,&quot;Green&quot;,&quot;Blue&quot;]</span><br><span class="line">//每次都会不一样</span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><p>2、通过 Random 提供的 Shuffle<T>() 方法，可以将一个集合中的数据项的顺序打乱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string[] colors = new[]&#123;&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Black&quot;&#125;;</span><br><span class="line">Random.Shared.Shuffle(colors);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(JsonSerializer.Serialize(colors));</span><br><span class="line"></span><br><span class="line">Console.ReadKey();</span><br></pre></td></tr></table></figure><h2 id="新增的提高性能的类型"><a href="#新增的提高性能的类型" class="headerlink" title="新增的提高性能的类型"></a>新增的提高性能的类型</h2><p>1、新增了 FrozenDictionary&lt;TKey,TValue&gt; 和 FrozenSet<T> ，这两个类型在 System.Collections.Frozen 命名空间下，创建这两种类型的集合后，就不允许对键和值进行任何更改，因此可以实现更快的读取操作。</p><p>下面是使用 BenchmarkDotNet  对 FrozenDictionary 和 Dictionary 进行测试的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkRunner.Run&lt;FrozenDicTest&gt;();</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">[SimpleJob(RunStrategy.ColdStart, iterationCount:5)]</span><br><span class="line">public class FrozenDicTest</span><br><span class="line">&#123;</span><br><span class="line">    public static Dictionary&lt;string, string&gt; dic = new() &#123;</span><br><span class="line">        &#123; &quot;name1&quot;,&quot;oec2003&quot;&#125;,</span><br><span class="line">        &#123; &quot;name2&quot;,&quot;oec2004&quot;&#125;,</span><br><span class="line">        &#123; &quot;name3&quot;,&quot;oec2005&quot;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static FrozenDictionary&lt;string, string&gt; fdic = dic.ToFrozenDictionary();</span><br><span class="line"></span><br><span class="line">    [Benchmark]</span><br><span class="line">    public void TestDic()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100000000; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dic.TryGetValue(&quot;name&quot;, out _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Benchmark]</span><br><span class="line">    public void TestFDic()</span><br><span class="line">    &#123;</span><br><span class="line">        for (int i = 0; i &lt; 100000000; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            fdic.TryGetValue(&quot;name&quot;, out _);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从测试结果看，效果还是很明显的：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311161902374.webp"></p><p>2、新增的 System.Buffers.SearchValues<T> 类，可以用来进行字符串的查找和匹配，相比较  string  类型的操作，性能有大幅提升，下面还是用 BenchmarkDotNet 进行测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BenchmarkRunner.Run&lt;SearchValuesTest&gt;();</span><br><span class="line">Console.ReadKey();</span><br><span class="line"></span><br><span class="line">[SimpleJob(RunStrategy.ColdStart, iterationCount: 5)]</span><br><span class="line">public class SearchValuesTest</span><br><span class="line">&#123;</span><br><span class="line">    [Benchmark]</span><br><span class="line">    public void TestString()</span><br><span class="line">    &#123;</span><br><span class="line">        var str = &quot;!@#$%^&amp;*()_1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;</span><br><span class="line">        for (int i = 0; i &lt; 100000000; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str.Contains(&quot;z&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [Benchmark]</span><br><span class="line">    public void TestSearchValues()</span><br><span class="line">    &#123;</span><br><span class="line">        var sv = SearchValues.Create(&quot;!@#$%^&amp;*()_1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;u8);</span><br><span class="line">        byte b = (byte)&quot;z&quot;[0];</span><br><span class="line">        for (int i = 0; i &lt; 100000000; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sv.Contains(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从运行结果看，有大约 5 倍的的提升：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311161902368.webp"></p><h2 id="依赖注入增强"><a href="#依赖注入增强" class="headerlink" title="依赖注入增强"></a>依赖注入增强</h2><p>在 8 之前的版本中，依赖注入写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line">builder.Services.AddTransient&lt;IUser, UserA&gt;();</span><br><span class="line"> </span><br><span class="line">var app = builder.Build();</span><br><span class="line"></span><br><span class="line">app.MapGet(&quot;/user&quot;, (IUser user) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    return $&quot;hello , &#123;user.GetName()&#125;&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br><span class="line"></span><br><span class="line">internal interface IUser</span><br><span class="line">&#123;</span><br><span class="line">    string GetName();</span><br><span class="line">&#125;</span><br><span class="line">internal class UserA: IUser</span><br><span class="line">&#123;</span><br><span class="line">    public string GetName() =&gt; &quot;oec2003&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 IUser 接口有两个实现，上面代码中的写法就只能获取到最后一个注册类的实例，要实现一个接口多个实现类的注入，还需要写一些额外的代码，比较繁琐。</p><p>版本 8 中添加了注入关键字，可以很方便实现，看下面代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var builder = WebApplication.CreateBuilder(args);</span><br><span class="line"></span><br><span class="line">builder.Services.AddKeyedSingleton&lt;IUser, UserA&gt;(&quot;A&quot;);</span><br><span class="line">builder.Services.AddKeyedSingleton&lt;IUser, UserB&gt;(&quot;B&quot;);</span><br><span class="line"></span><br><span class="line">var app = builder.Build();</span><br><span class="line"></span><br><span class="line">app.MapGet(&quot;/user1&quot;, ([FromKeyedServices(&quot;A&quot;)] IUser user) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    return $&quot;hello , &#123;user?.GetName()&#125;&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">app.MapGet(&quot;/user2&quot;, ([FromKeyedServices(&quot;B&quot;)] IUser user) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    return $&quot;hello , &#123;user?.GetName()&#125;&quot;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.Run();</span><br><span class="line"></span><br><span class="line">internal interface IUser</span><br><span class="line">&#123;</span><br><span class="line">    string GetName();</span><br><span class="line">&#125;</span><br><span class="line">internal class UserA: IUser</span><br><span class="line">&#123;</span><br><span class="line">    public string GetName() =&gt; &quot;oec2003&quot;;</span><br><span class="line">&#125;</span><br><span class="line">internal class UserB : IUser</span><br><span class="line">&#123;</span><br><span class="line">    public string GetName() =&gt; &quot;oec2004&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在  .NET Conf  2023  大会上，.NET 8 正式发布了，.NET 8 是一个长期支持（LTS）版本，这意味着可以获得三年的支持和补丁。我们也计划将框架从 .NET Core3.1 升级到 8 ，关于如何升级等升级完成后再来分享。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="C#" scheme="http://fwhyy.com/tags/c/"/>
    
    <category term="DotNet" scheme="http://fwhyy.com/tags/dotnet/"/>
    
    <category term="dotNet8" scheme="http://fwhyy.com/tags/dotnet8/"/>
    
  </entry>
  
  <entry>
    <title>监控利器：普罗米修斯监控中间件(Nginx、Redis、MySql 等)</title>
    <link href="http://fwhyy.com/2023/11/prometheus-monitoring-middleware/"/>
    <id>http://fwhyy.com/2023/11/prometheus-monitoring-middleware/</id>
    <published>2023-11-09T08:36:23.000Z</published>
    <updated>2023-11-24T08:38:35.011Z</updated>
    
    <content type="html"><![CDATA[<p>我们的产品目前使用到的中间件有 Nginx、Redis、RabbitMQ、MySql 等，本文介绍怎样使用 Promtheus 来监控这些中间件。</p><span id="more"></span><p>在《监控利器：普罗米修斯介绍和安装》中有一张图，表明了 Prometheus 的数据走向，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081626495.webp"></p><p>从图中可以看出，监控中间件的第一步就是安装中间件的 exporter，安装有两种方式：下载安装文件进行安装和使用 Docker 进行安装，下面示例中使用的是后者。</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>1、我们产品的前端 Web 部署在 nginx 容器中，需要在容器的配置文件中进行 nginx_status 模块的设置，才能被 exporter 识别。 nginx 配置文件添加下面代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /nginx_status &#123;</span><br><span class="line">       stub_status on;</span><br><span class="line">       access_log off;</span><br><span class="line">       allow all;</span><br><span class="line">      # deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了测试方便直接设置为 allow all 了，实际可以根据需要进行开放和禁用。</li></ul><p>2、修改配置后，重启 Web 容器，访问 <a href="http://ip:port/nginx_status">http://ip:port/nginx_status</a>  ,出现下图界面，说明配置生效：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627093.webp"></p><p>3、执行下面的命令进行 nginx-exporter 容器的安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx/nginx-prometheus-exporter</span><br><span class="line">docker run -p 9113:9113 -d  --restart=always --name nginx-exporter nginx/nginx-prometheus-exporter -nginx.scrape-uri http://10.211.55.3:90/nginx_status</span><br></pre></td></tr></table></figure><ul><li><a href="http://192.168.3.78/nginx_status">http://192.168.3.78/nginx_status</a> 为被监控的 nginx 服务器的地址。</li></ul><p>容器运行后，访问 9113 端口，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627166.webp"></p><p>4、在 prometheus 的配置文件中进行绑定，执行<code>vi /usr/local/prometheus/prometheus.yml</code>，在文件的最下面添加  job 配置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627140.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;nginx&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;10.211.55.3:9113&#x27;]</span><br></pre></td></tr></table></figure><p>5、执行命令 <code>systemctl restart prometheus</code> 重启生效，可以访问 <a href="http://10.211.55.3:9090/targets">http://10.211.55.3:9090/targets</a> 查看状态，如果为 UP 说明 job 设置成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627264.webp"></p><p>6、在 Grafana 中导入 12078 模板：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627752.webp"></p><p>7、最终展示效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627150.webp"></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>1、首先需要安装 redis_exporter ，执行下面命令进行镜像的下载和安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker pull oliver006/redis_exporter </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果 redis 没有密码执行下面命令</span></span><br><span class="line">docker run -d --name redis_exporter -p 9121:9121   --network s2v9_test_s2_net  oliver006/redis_exporter --redis.addr redis://172.66.9.9:6379 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果 redis 有密码执行下面命令</span></span><br><span class="line">docker run -d --name redis_exporter -p 9121:9121   --network s2v9_test_s2_net  oliver006/redis_exporter --redis.addr redis://172.66.9.9:6379 --redis.password &#x27;000000&#x27;</span><br></pre></td></tr></table></figure><ul><li>上面命令中 –network s2v9_test_s2_net 为 redis 容器所在的网络，因为我的 exporter 容器和 redis 容器在一台服务器，设置为同一网络后，–redis.addr 就可以使用容器的内部 IP 和端口。</li><li>如果是分开部署，不需要设置 –network ，使用服务器 IP 和端口即可。</li></ul><p>2、容器运行成功后，浏览器访问界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627290.webp"></p><p>3、在 prometheus 的配置文件中进行绑定，执行<code>vi /usr/local/prometheus/prometheus.yml</code>，在文件的最下面添加 job 配置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081627986.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;reids&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;10.211.55.3:9121&#x27;]</span><br></pre></td></tr></table></figure><p>4、执行命令 <code>systemctl restart prometheus</code> 重启生效，可以访问 <a href="http://10.211.55.3:9090/targets">http://10.211.55.3:9090/targets</a> 查看状态，如果为 UP 说明 job 设置成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081628046.webp"></p><p>5、在 Grafana 中导入 763 编号的模板：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081629990.webp"></p><p>6、最终展示效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081629359.webp"></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>1、首先需要安装 redis_exporter ，执行下面命令进行镜像的下载和安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull kbudde/rabbitmq-exporter:latest</span><br><span class="line"></span><br><span class="line">docker run -d -p 9419:9419 --name rabbitmq-exporter --network s2v9_test_s2_net -e RABBIT_URL=http://172.66.9.8:15672 -e RABBIT_USER=Ican -e RABBIT_PASSWORD=000000 kbudde/rabbitmq-exporter</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>-e RABBIT_URL=<a href="http://172.66.9.8:15672/">http://172.66.9.8:15672</a> ，这里设置的是 RabbitMQ 容器的内部 IP，所以必须设置在同一个网络中，否则需要将 15672 映射出去。</li><li>-e RABBIT_USER、-e RABBIT_PASSWORD 为 RabbitMQ 的用户名和密码，默认为 guest，也可以自行设置。</li></ul><p>2、容器运行成功后，浏览器访问界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081629715.webp"></p><p>3、在 prometheus 的配置文件中进行绑定，执行<code>vi /usr/local/prometheus/prometheus.yml</code>，在文件的最下面添加 job 配置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630361.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;rabbitmq&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;10.211.55.3:9419&#x27;]</span><br></pre></td></tr></table></figure><p>4、执行命令 <code>systemctl restart prometheus</code> 重启生效，可以访问 <a href="http://10.211.55.3:9090/targets">http://10.211.55.3:9090/targets</a> 查看状态，如果为 UP 说明 job 设置成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630040.webp"></p><p>5、在 Grafana 中导入 2121 编号的模板：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630941.webp"></p><p>6、最终展示效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630412.webp"></p><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><p>1、在 mysql 数据库中创建 exporter 账户，并设置权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;exporter&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Aa123456&#x27;;</span><br><span class="line">GRANT PROCESS, REPLICATION CLIENT ON *.* TO &#x27;exporter&#x27;@&#x27;%&#x27;;</span><br><span class="line">GRANT SELECT ON performance_schema.* TO &#x27;exporter&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>2、在目录 <code>/root/exporter/config/mysql</code> 中创建 .my.cnf 文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">host=172.66.9.2</span><br><span class="line">port=3306</span><br><span class="line">user=exporter</span><br><span class="line">password=Aa123456</span><br></pre></td></tr></table></figure><ul><li>host 配置为 mysql 数据库的容器 IP</li><li>user 和 password 配置为新创建的账号和密码</li></ul><p>3、执行下面命令安装 mysqld-exporter ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull prom/mysqld-exporter</span><br><span class="line">docker run -d -p 9104:9104 --network s2v9_test_s2_net --restart=&quot;always&quot; -v /root/exporter/config/mysql/.my.cnf:/.my.cnf prom/mysqld-exporter</span><br></pre></td></tr></table></figure><p>如果没有 .my.cnf 文件的映射，会出现下面错误：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630032.webp"></p><p>4、容器运行成功后，浏览器访问界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630915.webp"></p><p>5、在 prometheus 的配置文件中进行绑定，执行<code>vi /usr/local/prometheus/prometheus.yml</code>，在文件的最下面添加 job 配置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630009.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;mysql&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;10.211.55.3:9104&#x27;]</span><br></pre></td></tr></table></figure><p>6、执行命令 <code>systemctl restart prometheus</code> 重启生效，可以访问 <a href="http://10.211.55.3:9090/targets">http://10.211.55.3:9090/targets</a> 查看状态，如果为 UP 说明 job 设置成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630285.webp"></p><p>7、在 Grafana 中导入 7362 编号的模板：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081630518.webp"></p><p>8、最终展示效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202311081631867.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们的产品目前使用到的中间件有 Nginx、Redis、RabbitMQ、MySql 等，本文介绍怎样使用 Promtheus 来监控这些中间件。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="监控" scheme="http://fwhyy.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="Prometheus" scheme="http://fwhyy.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>监控利器：普罗米修斯介绍和安装</title>
    <link href="http://fwhyy.com/2023/11/install-prometheus/"/>
    <id>http://fwhyy.com/2023/11/install-prometheus/</id>
    <published>2023-11-01T00:29:51.000Z</published>
    <updated>2023-11-24T08:32:27.971Z</updated>
    
    <content type="html"><![CDATA[<p>我们的程序想要稳定的运行，或者说当出现问题时能第一时间知道，这就离不开监控，目前比较主流的就是 Prometheus（普罗米修斯）+ Grafana 的组合。</p><span id="more"></span><p>准备用三篇文章来介绍怎么使用：</p><p>1、基本介绍和安装</p><p>2、和中间件的集成</p><p>3、在 dotNET Core 中的使用</p><p>本文是第一篇：基本介绍和安装。</p><h2 id="Prometheus-介绍"><a href="#Prometheus-介绍" class="headerlink" title="Prometheus 介绍"></a>Prometheus 介绍</h2><p>Prometheus 是一套开源的监控报警系统，由 SoundCloud公司开发，于 2012 年开源。已经广泛应用于 Kubernetes 和 ServiceMesh 等云原生环境中。</p><p>Prometheus 具有以下核心特征：</p><ul><li>多维数据模型：Prometheus 采用时序数据库作为存储，可以灵活的存储多维度的数据。</li><li>灵活的查询语言：Prometheus 使用了功能强大的 PromQL 查询语言，可以实时查询和聚合时序数据。</li><li>拉取式采集：Prometheus 通过 HTTP 协议周期性抓取被监控组件状态，而不是通过端口接收推送数据。</li><li>服务发现：Prometheus 支持各种服务发现机制，可以自动发现监控目标，如果需要监控的服务比较少，也可以使用静态配置。</li><li>多种可视化组件：如 Grafana、PromDash 等，可以用来展示监控数据，本次系列文章中使用 Grafana 做可视化展示。</li><li>告警管理：通过 Alertmanager 负责实现报警功能，既可以使用邮件，也能通过 Webhook 自定义告警处理方式。</li></ul><p>Prometheus 作为云原生应用监控的首选方案，其生态圈非常繁荣。它的出现极大地促进了新的监控思维模式的形成，为构建高可用自动化系统提供了重要保障。</p><h2 id="数据流走向"><a href="#数据流走向" class="headerlink" title="数据流走向"></a>数据流走向</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312036981.webp"></p><ul><li>操作系统和中间件几乎不用做任何配置，目前用到的就发现 nginx 需要配置 nginx_status 模块。</li><li>不同的中间件用不同的 exporter，exporter 会和中间件之间进行连接，所以运行 exporter 的时候都需要指定中间件的地址和端口。</li><li>每个 exporter 运行后有对应的 http 地址。</li><li>Prometheus 的配置文件中对 exporter 的 http 地址进行绑定，配置后重新启动 Prometheus 才能生效，如果监控的中间件比较多，就需要考虑使用服务发现了。</li><li>Grafana 专门用来对 Prometheus 收集的数据进行可视化展示，需要在数据源中配置对 Prometheus 的连接，然后针对不同的中间件使用不同的面板就可以了。</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1、安装 Prometheus 和 Grafana 。</p><p>2、安装部署中间件的 exporter ，本文只介绍 node_exporter 的安装，其他的中间件放到下一篇。</p><p>3、修改 Prometheus 的配置文件，添加 job 节点，并重启让其生效。</p><p>4、在 Grafana 中添加数据源 。</p><p>5、在 Grafana 中添加面板。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>CentOS：7.8</li><li>Grafana：10.1.5</li><li>prometheus：2.47.2</li><li>node_exporter：1.6.1</li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li><p>服务器1：10.211.55.6 （部署 prometheus ）</p></li><li><p>服务器2：10.211.55.14（部署 Grafana、node_exporter ）</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装-Prometheus"><a href="#安装-Prometheus" class="headerlink" title="安装 Prometheus"></a>安装 Prometheus</h3><p>1、在  prometheus 官网下载页面下载相关的安装包，地址如下：</p><p><a href="https://prometheus.io/download/">https://prometheus.io/download/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312038344.webp"></p><p>2、在服务器上执行下面命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br><span class="line">mkdir prometheus</span><br><span class="line">cd prometheus</span><br><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v2.47.2/prometheus-2.47.2.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf prometheus-2.47.2.linux-amd64.tar.gz</span><br><span class="line">cp -R prometheus-2.47.2.linux-amd64 /usr/local/prometheus</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li> 如果使用 wget 下载有问题，就在官网中进行下载。</li></ul><p>3、设置 prometheus 系统服务，执行命令创建服务文件 <code>vi /usr/lib/systemd/system/prometheus.service</code> ，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Prometheus</span><br><span class="line">Documentation=https://prometheus.io/</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">WorkingDirectory=/usr/local/prometheus</span><br><span class="line">ExecStart=/usr/local/prometheus/prometheus </span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>4、启动服务和设置开机自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable prometheus.service</span><br><span class="line">systemctl start prometheus.service</span><br></pre></td></tr></table></figure><p>5、启动后，可以使用 <code>systemctl status prometheus.service</code> 命令查看状态，出现下图界面，表示启动成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312038082.webp"></p><p>6、在浏览器访问地址：<a href="http://10.211.55.3:9090/targets?search=">http://10.211.55.3:9090/targets?search=</a> ，出现下图界面，说明 prometheus 已经安装成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312038563.webp"></p><h3 id="安装-Grafana"><a href="#安装-Grafana" class="headerlink" title="安装 Grafana"></a>安装 Grafana</h3><p>1、在  Grafana 官网下载页面下载相关的安装包，地址如下：<br><a href="https://grafana.com/grafana/download">https://grafana.com/grafana/download</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312038046.webp"></p><p>2、在服务器上执行下面命令进行包的下载和安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br><span class="line">mkdir Grafana</span><br><span class="line">cd Grafana</span><br><span class="line">wget https://dl.grafana.com/oss/release/grafana-10.1.5-1.x86_64.rpm</span><br><span class="line">yum install -y grafana-8.0.6-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p> 3、启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable grafana-server</span><br><span class="line">systemctl start grafana-server</span><br></pre></td></tr></table></figure><p>4、启动后，可以使用 <code>systemctl status grafana-server</code> 命令查看状态，出现下图界面，表示启动成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312129150.webp"></p><p>6、在浏览器访问地址：<a href="http://10.211.55.14:3000/%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%E7%95%8C%E9%9D%A2%EF%BC%8C%E8%AF%B4%E6%98%8E">http://10.211.55.14:3000/，出现下图界面，说明</a> Grafana 已经安装成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039370.webp"></p><h3 id="安装-node-exporter"><a href="#安装-node-exporter" class="headerlink" title="安装 node_exporter"></a>安装 node_exporter</h3><p>node_exporter 是用来监控服务器的 exporter ，按照下面步骤进行安装：</p><p>1、在服务器上执行下面命令进行包的下载和安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br><span class="line">mkdir node_exporter</span><br><span class="line">cd node_exporter</span><br><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v1.6.1/node_exporter-1.6.1.linux-amd64.tar.gz</span><br><span class="line">tar -zxvf node_exporter-1.6.1.linux-amd64.tar.gz</span><br><span class="line">cp -R node_exporter-1.6.1.linux-amd64 /usr/local/node_exporter</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、设置 node_exporter 系统服务，执行命令创建服务文件 <code>vi /usr/lib/systemd/system/node_exporter.service</code> ，文件内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=node_exporter</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/local/node_exporter/node_exporter</span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>3、设置开机自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl enable node_exporter.service</span><br><span class="line">systemctl start node_exporter.service</span><br></pre></td></tr></table></figure><p>4、访问地址：<a href="http://10.211.55.14:9100/">http://10.211.55.14:9100</a> ，出现下图界面，说明安装成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039415.webp"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>1、修改 Prometheus 的配置文件，添加 node_exporter 的绑定，执行命令 <code>vi vi /usr/local/prometheus/prometheus.yml </code> ：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039622.webp"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &#x27;centos-1&#x27;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: [&#x27;10.211.55.14:9100&#x27;]</span><br></pre></td></tr></table></figure><ul><li>Job_name：随便取一个能表达意思的名称即可</li><li>targets：node_exporter 安装后发布出来的地址</li></ul><p>2、执行命令 <code>systemctl restart prometheus</code> 重启 Prometheus 。</p><p>3、在 Grafana 中添加数据源，登录 Grafana 后，在 Data Sources 模块中添加数据源：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039666.webp"></p><p>4、选择 Prometheus 作为数据源并进行配置，将 Prometheus 的地址 <a href="http://10.211.55.3:9090/">http://10.211.55.3:9090</a> ，填写在 server url 中：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039974.webp"></p><p>5、想要在 Grafana 中进行数据的展示，需要导入 dashborards  模板，这个地址中有各类模版可供选择：<a href="https://grafana.com/grafana/dashboards/">https://grafana.com/grafana/dashboards/</a> 。在 Grafana 的 Dashboards 模块中进行导入：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039992.webp"></p><p>6、输入编号：11074，这是可以展示服务器监控信息的 dashborard 模板：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312039911.webp"></p><p>7、Load 后，进行导入：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312040107.webp"></p><p>8、该 dashborard 模板最终展示的数据效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310312040846.webp"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们的程序想要稳定的运行，或者说当出现问题时能第一时间知道，这就离不开监控，目前比较主流的就是 Prometheus（普罗米修斯）+ Grafana 的组合。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="监控" scheme="http://fwhyy.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="Prometheus" scheme="http://fwhyy.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>聊聊六边形架构</title>
    <link href="http://fwhyy.com/2023/10/talk-about-hexagonal-architecture/"/>
    <id>http://fwhyy.com/2023/10/talk-about-hexagonal-architecture/</id>
    <published>2023-10-24T00:27:49.000Z</published>
    <updated>2023-11-24T08:31:17.549Z</updated>
    
    <content type="html"><![CDATA[<p>指导我们写出漂亮代码有一种方式是学习设计模式，自从 Gof 四人组的《设计模式》出版后，各类设计模式的书层出不穷。熟读这类书籍，对面试肯定是有帮助的，但代码能力是否有大的长进就不一定了，如果没能理解背后的思想，去生搬硬套，只会起反作用。</p><span id="more"></span><p>背后的思想就是指面向对象的原则：</p><ul><li>单一职责原则（SRP）</li><li>开放封闭原则（OCP）</li><li>里氏替换原则（LSP）</li><li>接口隔离原则（ISP）</li><li>依赖倒置原则（DIP）</li></ul><p>这些原则就是告诉我们应该怎么合理地组织类和方法。最终使我们开发的程序能够满足：可扩展、可复用、可阅读。只是看这些原则比较抽象，最近看了下六边形架构，我认为对代码的编写有很好的指导作用，下面就聊聊六边形架构。</p><h2 id="什么是六边形架构？"><a href="#什么是六边形架构？" class="headerlink" title="什么是六边形架构？"></a>什么是六边形架构？</h2><p>六边形架构（Hexagonal Architecture），也被称为端口与适配器架构（Ports and Adapters Architecture），是一种软件架构模式，旨在实现高内聚、低耦合和可测试性的应用程序设计。该架构由 Alistair Cockburn 发明，他是敏捷宣言的签署者之一。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310231840474.webp"></p><p>从上图可以看出有内外两层六边形，深蓝色和浅蓝色。</p><ul><li>内层（深蓝色）：负责领域内的业务逻辑，相对独立，不用关注任何外部依赖或技术细节，也不用关心外部的客户端和服务，我们定义为领域层。</li><li>外层（浅蓝色）：完成外部应用、基础资源等的交互和访问，负责获取不同的业务域的数据，进行业务逻辑的组装，我们定义为应用层。</li></ul><p>上图中的紫色部分的 context 是我们在实践过程中添加的，在应用层中进行逻辑组装时，如果没有业务上下文的概念，很多方法会导致被重复调用，所以在业务入口会进行上下文的初始化，将长下文贯穿整个调用链。</p><h2 id="端口和适配器"><a href="#端口和适配器" class="headerlink" title="端口和适配器"></a>端口和适配器</h2><p>六边形架构也被称为端口与适配器架构，端口和适配器是两个非常关键且重要的概念。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口是应用程序定义的接口，必须由外界实现，以便应用程序可以接收或发送信息，进行解耦。这个接口是广义的，不光是指 Interface，WebAPI 接口，一些类的公共方法也属于接口的范畴。</p><p>端口有分为两种：</p><ul><li><p>入站端口：业务服务对外暴露的公有方法；</p></li><li><p>出站端口：出站端口只一组方法的接口定义，提供一种规范，供出站适配器来实现。</p></li></ul><p>使用端口和适配器进行处理应用程序的输入和输出，端口只是一种抽象，是应用程序在不了解任何内容的情况下与外界交互的一种方式。</p><p>例如：如果想要进行数据库的读取和写入，不是直接操作数据库，而是在接口中定义读取和写入的方法。应用程序不需要知道数据来自哪里，需要写到什么地方去，可能是数据库，也可能是文件系统或缓存，甚至会同时操作。</p><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器是连接应用程序核心和外部接口的桥梁。它负责将外部请求转换为应用程序核心可以理解的格式，并将核心的响应转换为外部接口可以接受的格式。</p><p>适配器也分为两种：</p><ul><li>入站适配器：通常就是对外的 RestAPI，通过调用入站端口来处理外部的请求，也可以是消息队列的消费者，进行一些事件的监听，来处理异步业务，当接收到消息时也是调用入站端口来进行处理；</li><li>出站适配器：出站适配器实现出站接口，调用外部的服务来实现一个完整的业务逻辑，出站适配器也可以是消息队列的生产者。</li></ul><p>当要将数据保存到数据库中时，适配器从接口定义的数据格式中获取数据，并将其转换为可以写入数据库的内容，重要的是，无论在适配器中怎么变化，核心域和接口不会发生变化。这就非常有用，将应用程序的核心逻辑和外部存储隔离开了。</p><p>正是由于端口和适配器的存在，程序变得稳定和容易变化。</p><h2 id="为什么叫六边形架构？"><a href="#为什么叫六边形架构？" class="headerlink" title="为什么叫六边形架构？"></a>为什么叫六边形架构？</h2><p>为什么是叫六边形架构？而不是三角形、圆形、正方形呢？</p><p>目前没有明确的理由说明为什么是六边形，而不是其他的形状。或许只是因为六边形比较好看。又或许，一个小的六边形代表这一个模块，一个系统有很多这种模块组成，模块之间有输入输出的交互，就像蜂窝一样。</p><p>而蜂窝正好是六边形的。</p><h2 id="六边形架构的特点"><a href="#六边形架构的特点" class="headerlink" title="六边形架构的特点"></a>六边形架构的特点</h2><p>通过六边形架构，应用程序核心成为了架构的中心，具有清晰的边界和职责，可以独立于外部接口进行测试和演进。外部接口和适配器负责处理与外部系统的交互，使应用程序核心保持独立和可复用。主要有以下特点：</p><ul><li>高内聚和低耦合：应用程序核心独立于外部依赖，使得不同部分的修改不会对其他部分产生影响，提高了代码的可维护性。</li><li>可测试性：应用程序核心可以轻松地进行单元测试，因为它不依赖于具体的外部接口或技术细节。</li><li>可扩展性：通过添加新的适配器，可以很容易地与新的外部系统进行集成，而不会对应用程序核心产生影响。</li></ul><h2 id="六边形架构的原则"><a href="#六边形架构的原则" class="headerlink" title="六边形架构的原则"></a>六边形架构的原则</h2><p>当我们谈论六边形架构时，有几个核心原则需要考虑。这些原则指导我们持续优化软件架构，使系统的各个模块能够独立地演化和变化，同时保持其整体的稳定性。</p><p>1、分离关注点：六边形架构将系统划分为不同的层次，每个层次都有其特定的职责和关注点。这种分离使得每个组件可以专注于自身的任务，降低了耦合性，提高了模块的可复用性和可测试性。</p><p>2、内外部分离：六边形架构将系统划分为内部和外部两个六边形，分别代表核心业务逻辑和外部接口。内部六边形负责处理核心业务逻辑，而外部六边形则负责处理业务整合和外部系统的交互。这种内外部分离的设计使得系统更容易扩展和适应变化。</p><p>3、依赖注入：六边形架构鼓励使用依赖注入来管理组件之间的依赖关系。通过依赖注入，组件的依赖关系可以在运行时进行配置，而不是在编译时固定。这样可以实现组件之间的松耦合，并且方便进行替换和测试。</p><p>4、接口驱动：六边形架构强调基于接口编程，通过定义清晰的接口和协议来促进组件之间的通信。接口的使用可以提高组件的可替换性和可测试性，并支持多态性和可扩展性。</p><p>5、测试驱动：六边形架构鼓励在开发过程中采用测试驱动开发（TDD）的方法。通过编写测试用例来定义组件的行为，然后逐步实现和改进组件以满足测试的要求。这种测试驱动的开发方法有助于保证系统的质量和稳定性。</p><p>根据这些原则，可以发现，这些就是在文章开头提到的哪些面向对象的原则。通过六边形架构的包装，更具备实操性。</p><h2 id="和-DDD-、微服务的关系"><a href="#和-DDD-、微服务的关系" class="headerlink" title="和 DDD 、微服务的关系"></a>和 DDD 、微服务的关系</h2><p>在网上查相关资料，六边形架构往往都跟 DDD 、微服务在一起被提及。他们之间其实没有很必然的联系。</p><p>就像微服务和 DDD 一样，也没有必然联系，因为：</p><p>1、DDD 中子域和限界上下文的概念可以对应到微服务中的服务；</p><p>2、微服务中一个服务可以由一个团队进行开发，DDD 的一个领域模型也是建议由一个独立的团队负责。</p><p>所以，微服务和领域驱动开发（DDD）常常会一起提及，在学习的时候，也会两种一起学，互相配合能够更好地落地。</p><p>如果说，微服务是架构风格、DDD 是架构设计方法、那么六边形架构就是一种具体的指导编码的架构实践。</p><h2 id="一些资料"><a href="#一些资料" class="headerlink" title="一些资料"></a>一些资料</h2><p>1、VS 的 HexagonalX 扩展</p><p>在 VS 中可以安装六边形架构的扩展，安装后在创建项目时就会多出六边形架构的项目类型可供选择。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310231840495.webp"></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310231840282.webp" alt="image-20231023183747985"></p><p>2、几个 GitHub 上的示例项目和文章</p><p><a href="https://github.com/alesimoes/hexagonal-clean-architecture">https://github.com/alesimoes/hexagonal-clean-architecture</a></p><p><a href="https://github.com/ivanpaulovich/clean-architecture-manga">https://github.com/ivanpaulovich/clean-architecture-manga</a></p><p><a href="https://blog.allegro.tech/2020/05/hexagonal-architecture-by-example.html">https://blog.allegro.tech/2020/05/hexagonal-architecture-by-example.html</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;指导我们写出漂亮代码有一种方式是学习设计模式，自从 Gof 四人组的《设计模式》出版后，各类设计模式的书层出不穷。熟读这类书籍，对面试肯定是有帮助的，但代码能力是否有大的长进就不一定了，如果没能理解背后的思想，去生搬硬套，只会起反作用。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="架构" scheme="http://fwhyy.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>如何设计 API？</title>
    <link href="http://fwhyy.com/2023/10/how-to-design-the-api/"/>
    <id>http://fwhyy.com/2023/10/how-to-design-the-api/</id>
    <published>2023-10-17T01:42:48.000Z</published>
    <updated>2023-10-21T09:44:07.273Z</updated>
    
    <content type="html"><![CDATA[<p>在前后端分离的设计中，不管使用什么语言，后端都需要提供 WebAPI 给前端使用。如果是一个平台级的产品，还有可能需要将平台的公共 API 提供给第三方系统使用，这些都要考虑到 API 的设计。</p><span id="more"></span><p>本文聊下 API 设计可能遇到的问题以及处理方式。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>1、客户端种类比较多，不容易实现差异化。</p><p>以我们现在正在做的低代码平台来说，存在的客户端有下面这些：</p><ul><li>Web 端应用程序</li><li>移动端的应用程序</li><li>第三方开发人员编写的应用程序</li><li>自定义组件（符合规范的 Vue 前端组件，可以无缝和平台进行整合）</li><li>平台配置的脚本（直接配置在平台中，可以调用接口、处理界面元素）</li></ul><p>不同的客户端在调用接口时，输入输出会存在差异，比如：移动端的数据列表功能和结构上比 PC 端要简单很多，如果调用统一的接口，会造成浪费。</p><p>2、客户端直接对 API 进行调用。</p><ul><li><p>API 如果拆分的比较细，一次操作会发出多个请求才能拿到想要的数据，效率比较低</p></li><li><p>当需要多个请求时，还需要在客户端进行逻辑的组合，这样每个客户端可能都有一套自己的逻辑，不容易维护</p></li><li><p>服务如果进行拆分和合并，客户端代码需要同步进行修改</p></li><li><p>如果 API 进行了修改，第三方调用方需要配合修改，但这中间的沟通成本会很高，有时甚至不可行</p></li></ul><p>要解决这些问题，就应该单独提供一个独立的公共 API，而不是直接让第三方开发人员或其他客户端直接访问平台公开的 API ，涉及到独立的公共 API，API 网关就要出场了。</p><h2 id="API-网关"><a href="#API-网关" class="headerlink" title="API  网关"></a>API  网关</h2><p>API 网关是一种服务，是外部进入到应用程序内部的入口点。负责请求路由、身份验证、限流、熔断、流量监控等各种功能。</p><h3 id="路由请求"><a href="#路由请求" class="headerlink" title="路由请求"></a>路由请求</h3><p>路由请求是 API 网关的核心功能，当网关收到请求时，会去查询路由映射关系，将请求指定到相应的服务。跟 Nginx 的反向代理有点类似。</p><p>路由的配置可以是静态的，也可以是动态的，比如在 Ocelot 中，可以在 json 文件中进行路由映射的配置，也可以使用代码的方式按照需求进行动态路由修改。</p><p>参考：<a href="https://github.com/oec2003/StudySamples/tree/master/UpdateOcelotConfig">https://github.com/oec2003/StudySamples/tree/master/UpdateOcelotConfig</a></p><h3 id="组合多个服务"><a href="#组合多个服务" class="headerlink" title="组合多个服务"></a>组合多个服务</h3><p>在使用我们平台搭建的业务系统中，打开数据列表的详情，会做下面几件事情：</p><ul><li>获取按钮配置</li><li>获取表单模型</li><li>获取表单字段权限（根据不同的人员，获取的是不同流程节点的权限）</li><li>获取表单数据</li></ul><p>在 API 网关中可以对客户端提供统一入口调用，将这些来自不同服务的接口进行整合，统一输出，因为网关和服务都在内网，传输速度比较快，和客户端需要同时获取多个 API 请求相比，提升了效率。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310161742890.webp" alt="image-20231016161047257"></p><h3 id="专属-API"><a href="#专属-API" class="headerlink" title="专属 API"></a>专属 API</h3><p>作为一个平台，对外提供的公共 API 颗粒度往往不会很细，否则就不具备通用性了。如果针对不同的移动端（安卓、iOS）、或者特定的第三方平台，有一些细节上的区别。</p><p>网关可以为不同类型的客户端提供独立的 API。</p><h3 id="一些扩展能力"><a href="#一些扩展能力" class="headerlink" title="一些扩展能力"></a>一些扩展能力</h3><ul><li>身份认证</li><li>访问授权</li><li>限流</li><li>熔断</li><li>缓存</li><li>指标收集</li><li>日志记录</li></ul><p>这些扩展能力并非只有在 API 网关中才能实现，在后端服务中一样可以。但有些能力放到 API 网关中会更合适。</p><p>例如：身份认证、限流、熔断等，就是在请求还为触及服务时就已经处理了，会更加安全，也会让后端服务更稳固。</p><h3 id="网关的选择"><a href="#网关的选择" class="headerlink" title="网关的选择"></a>网关的选择</h3><p>在 .NET Core 中可以选择的开源网关产品有：Ocelot、Kong、Envoy 等。</p><p>Ocelot：是一个基于.NET Core的轻量级 API 网关，用于构建和管理微服务架构中的 API 网关。作为一个开源项目，Ocelot 提供了一种灵活、可扩展的方式来集中处理请求路由、认证授权、请求转发、负载均衡和缓存等功能。</p><p>Kong：是在 Nginx 中运行的 Lua 程序。得益于 Nginx 的性能优势，Kong 相比于其它的开源 API 网关来说，性能方面是最好的。由于大中型公司对于 Nginx 运维能力都比较强，所以选择 Kong 作为 API 网关，无论是在性能还是在运维的把控力上，都是比较好的选择。</p><p>Envoy：是一个开源的高性能代理和通信中间件，专为云原生应用程序设计。它由 Lyft 开发并于 2017年成为 Cloud Native Computing Foundation（CNCF）的毕业项目之一。虽然 Envoy 本身是用 C++ 编写的，但它可以与任何语言和框架进行集成，包括 .NET Core。</p><p>网关的选择需要能解决当前面临的问题。关于各种网关的使用方式，以及优缺点的对比，后面再进行详细介绍。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>不管是 API 的设计还是代码架构的设计，原则其实都差不多，要能够松耦合、易扩展、在满足现有需求的基础上，再多往前想一步，避免过度设计。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前后端分离的设计中，不管使用什么语言，后端都需要提供 WebAPI 给前端使用。如果是一个平台级的产品，还有可能需要将平台的公共 API 提供给第三方系统使用，这些都要考虑到 API 的设计。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="架构" scheme="http://fwhyy.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="API" scheme="http://fwhyy.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>这个国庆，又出发了（武汉-平潭）</title>
    <link href="http://fwhyy.com/2023/10/this-national-day-we-set-off-again-wuhan-pingtan/"/>
    <id>http://fwhyy.com/2023/10/this-national-day-we-set-off-again-wuhan-pingtan/</id>
    <published>2023-10-09T01:40:37.000Z</published>
    <updated>2023-10-21T09:41:59.637Z</updated>
    
    <content type="html"><![CDATA[<p>国庆长假结束了。在这个长假里，三个人一台车又出发了。</p><p>对于上班族来说，一年中，国庆假期是难得的适合出行的日子，所以，从 16 年开始，每年的国庆都有出行的计划，直到疫情出现。</p><ul><li>2016 年：长沙-常德-宜昌-荆州</li><li>2017 年：襄阳</li><li>2018 年：十堰-西安</li><li>2019 年：安庆-南浔-杭州-合肥</li></ul><p>当决定在疫情后的第一个国庆长假出行时，就已经做好了大堵车和看人头的准备，我一直认为，在路上发生的一切都属于旅行的一部分。</p><h2 id="路线规划"><a href="#路线规划" class="headerlink" title="路线规划"></a>路线规划</h2><p>关于路线的规划，遵循下面几个原则：</p><p>1、最远到达的距离尽量不超过 1000 公里，否则时间上不太够用；</p><p>2、从武汉到目标城市之间找一个城市中转，回程可以找另一个中转城市；</p><p>3、先大致确定一个方向，然后在地图上找目标城市和中转城市；</p><p>4、规划仅供参考，计划总是赶不上变化，所以酒店不宜一开始把每天的都订好（除非可以免费退的那种），不提前订又会遇到价格高和订不上的问题，需要权衡。</p><p>这个国庆，选择的是东南方向，目的地福州和平潭岛，去的时候经过景德镇，回来的时候从抚州中转，可以去附近的古镇转转，但是从平潭晒了一天太阳后，非常累，临时决定不去抚州了，订了一个资溪的度假酒店，休息调整。</p><p>恰恰是临时决定去的度假酒店，是女儿最喜欢的。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082202992.webp"></p><h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><h3 id="Day1（9-月-29）"><a href="#Day1（9-月-29）" class="headerlink" title="Day1（9 月 29）"></a>Day1（9 月 29）</h3><p>上午十点多出发，下午三点多到达景德镇，一路非常通畅，甚至一些路段一辆车都没有，完全感受不到节日的热闹。</p><p>在酒店安顿好后，便去了陶溪川，对这里印象很深刻：</p><p>1、有非常多的卖瓷器小物件的摊位，而且摊主都是年轻漂亮的小姐姐或帅气的小哥哥；</p><p>2、瓷器小物件价格很贵；</p><p>3、适合拍照。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082203208.webp" alt="陶溪川"></p><p>网上查当地的美食，有一家叫「樊记牛骨粉」，看到的所有店子都叫「樊记牛骨粉」，倒也不用挑了，随便进一个即可。牛骨粉、冷粉、饺子粑、油条包糯米，一个店子搞定，油条包糯米挺不错，第二天去抚州弄，又买了一次。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082203020.webp"></p><h3 id="Day2（9-月-30）"><a href="#Day2（9-月-30）" class="headerlink" title="Day2（9 月 30）"></a>Day2（9 月 30）</h3><p>离景德镇约 50 公里左右有一个瑶里古镇风景区，距离瑶里古镇十分钟车程的地方还有一处鲜为人知的古朴村落，这个地方叫做—东埠古街古码头。</p><p>这个地方没有商业化，可以看到村民在河里钓鱼、洗衣服。尽管是在国庆期间，也只能看见很少的几个游客。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082203056.webp" alt="东埠古街古码头"></p><p>离开东埠古街，继续驱车前往瑶里，果然商业化重的地方人就多，没能找到停车位，然后又临时找到了一个寒溪村。</p><p>寒溪村后面的山上是一片茶园，茶园最高处矗立着一座大型艺术品「大地之灯」，是著名建筑师马岩松的作品。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082203882.webp" alt="寒溪村"></p><p>回到市区后，又去了九集小镇（规模巨大的一个夜市）、雕塑瓷厂、、御窑博物馆（需要提前预约）、抚州弄，基本上该去的地方都去了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082203980.webp"></p><p>Day3（10 月 1）</p><p>因为担心堵车，早饭后简单逛了下三宝村就前往福州了，运气很好，高速上依旧没什么车。下午 6 点多到达酒店，酒店在三坊七巷附近。</p><p>晚上步行去了三坊七巷，途中经过了几个居民区，在大榕树的映衬下，非常的静谧，等到了三坊七巷，又人山人海，形成了鲜明的对比。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310090613273.webp" alt="三坊七巷"></p><p>Day4（10 月 2）</p><p>2 号的安排是福州市内，上下杭、烟台山一圈逛下来已经是下午 4 点多了，地铁加步行的出行模式也让我惊喜的发现福州的地铁是免费的（截止到 12 月）。</p><p>晚上老婆提议去了福州大学附近的永嘉夜市，依然是乘坐免费的地铁。永嘉夜市的人刚刚好，不多不少，在国庆期间，只要人不多，体验就会很好。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082204183.webp"></p><p>Day5（10 月 3）</p><p>去海边是这次旅行女儿最期待的，但是否去平潭犹豫了很久，就担心人太多。最后查到一个非常小众的五星沙滩，在去仙人井的途中右转进去，经过一个村庄的小路，就到了，果然不负所望，人非常少。</p><p>中午从五星海滩离开，女儿还依依不舍。</p><p>接着导航风车森林公路，因为是单行线，路边可以停车，我们找了合适位置停好车，下车拍照，可能是因为台风「小犬」的原因，很多人劝退了，人比想象中的少。</p><p>在平潭，我们只去了五星海滩和看了海上风车，想想没有排队、没有拥堵，也就很知足了。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310082204243.webp"></p><p>Day6（10 月 4）</p><p>没有提前预定抚州的酒店，就可以临时改变行程了。老婆找的资溪度假酒店非常不错，下高速几公里就到了。价格是这次行程中最便宜的，设施和环境是最好的。</p><p>女儿在酒店的儿童游乐场玩的很嗨。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310090613489.webp" alt="资溪"></p><p>Day7（10 月 5）</p><p>安全抵达武汉。</p><h2 id="跑步"><a href="#跑步" class="headerlink" title="跑步"></a>跑步</h2><p>尽管是十一旅行，跑步可不能拉下。</p><h3 id="景德镇"><a href="#景德镇" class="headerlink" title="景德镇"></a>景德镇</h3><p>10 月 1 号在景德镇跑了 10.01  公里来庆祝国庆。景德镇市区不大，酒店的正前方是陶溪川，我特意从反方向跑，最后还是绕到了陶溪川。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310090612933.webp"></p><h3 id="福州"><a href="#福州" class="headerlink" title="福州"></a>福州</h3><p>4 号是离开福州的日子，早上 5 点起床，跑向离酒店只有 3 公里的闽江公园，沿着江边跑了一个来回，然后跑回酒店。</p><p>江边的绿道以及城市的道路都被榕树包裹着，6 点多，太阳已经升起，但一点都不晒，非常舒服。</p><p>福州真的是一个非常适合跑步的城市。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310090612099.webp"></p><h3 id="资溪"><a href="#资溪" class="headerlink" title="资溪"></a>资溪</h3><p>酒店在一个山上，起床后就沿着上山的路往下跑，偶然发现旁边有一条环境优美的绿道，绿道总共 3 公里左右，跑了几个来回。</p><p>可能是因为山里氧气很足，523 的配速，心率只有 138。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202310090612738.webp"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>1、可能是运气，也可能是路线和出行时间选择的好，一路上没有看人头、大堵车；</p><p>2、景德镇挺好，就是东西太贵，陶溪川的陶瓷卖的贵，酒店也贵，房间比床大一点的汉庭要都要 600 多；</p><p>3、福州之前不是很了解，这次印象很不错，特别是到处可见的古榕树让人印象深刻，城市绿化特别好；</p><p>4、如果不是万不得已，最好不要提前把酒店都订了，这样比较灵活，不好玩，随时可以换地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;国庆长假结束了。在这个长假里，三个人一台车又出发了。&lt;/p&gt;
&lt;p&gt;对于上班族来说，一年中，国庆假期是难得的适合出行的日子，所以，从 16 年开始，每年的国庆都有出行的计划，直到疫情出现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2016 年：长沙-常德-宜昌-荆州&lt;/li&gt;
&lt;li&gt;2</summary>
      
    
    
    
    <category term="旅行" scheme="http://fwhyy.com/categories/%E6%97%85%E8%A1%8C/"/>
    
    
    <category term="旅行" scheme="http://fwhyy.com/tags/%E6%97%85%E8%A1%8C/"/>
    
    <category term="自驾" scheme="http://fwhyy.com/tags/%E8%87%AA%E9%A9%BE/"/>
    
    <category term="平潭" scheme="http://fwhyy.com/tags/%E5%B9%B3%E6%BD%AD/"/>
    
    <category term="景德镇" scheme="http://fwhyy.com/tags/%E6%99%AF%E5%BE%B7%E9%95%87/"/>
    
  </entry>
  
  <entry>
    <title>B 端软件：开发转产品经理可能遇到的坑</title>
    <link href="http://fwhyy.com/2023/09/b-side-software-development-to-product-managers-may-encounter-pitfalls/"/>
    <id>http://fwhyy.com/2023/09/b-side-software-development-to-product-managers-may-encounter-pitfalls/</id>
    <published>2023-09-26T01:37:57.000Z</published>
    <updated>2023-10-21T09:39:35.982Z</updated>
    
    <content type="html"><![CDATA[<p>有一类产品经理是由开发工程师转岗而来。就拿我来说，自从管理产品团队后，经常会和团队的产品经理进行新功能的讨论、会考虑产品未来的发展方向和路径，慢慢的我的工作重心也更多的偏向产品设计。</p><span id="more"></span><p>本文就聊聊从开发工程师转变为产品经理可能会遇到的问题。</p><h2 id="思维转变"><a href="#思维转变" class="headerlink" title="思维转变"></a>思维转变</h2><p>开发工程师大多是工程思维。</p><p>产品经理需要的是产品思维。</p><p>前些天，在团队内部的一个需求讨论会上，产品经理和开发工程师都有参与，我提出一个需求的 UI  交互思路，开发工程师马上指出：“如果这样做的话，实现上某某地方会调整比较大；某某地方新增的部分实现比较复杂。” </p><p>这就是典型的思考方式没有在一个维度上，从产品的角度，需要考虑的是功能交互的合理性、怎样才能真正解决用户的痛点。在这个前提之下，再考虑应该怎么实现，该怎样去做取舍。</p><p>工程思维更关注效率、如何实现，也就是「How」；而产品思维更关注场景、用户的真实需求，也就是「Why」。 在具体的产品开发中，产品思维和工程思维都很重要，需要将两者结合起来。</p><p>产品思维需要工程的配合与支撑，但如果只有工程思维，最后可能会做出一堆无用的功能。</p><h2 id="保持空杯心态"><a href="#保持空杯心态" class="headerlink" title="保持空杯心态"></a>保持空杯心态</h2><p>不要以为自己的开发经验就是优势，而忽视了产品经理所需要的其他知识和技能。应该将你具备的开发技能变成加分项，而不要变成束缚。</p><p>除了我们熟悉的开发技能，还需要补齐产品经理的基础知识，如市场分析、需求分析、用户研究、产品设计、项目管理等，并且不断学习和实践。</p><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><p>对开发工程师来说，沟通能力也很重要，只不过平时的工作只需要按照要求高质量编写代码就行，不会刻意在这个方面去做提升。</p><p>产品经理就不一样，对内要和开发团队进行沟通，对外要和需求方进行沟通，沟通能力是一个必备技能。</p><p>在公司中，不同职位与不同资历的人，彼此的认知都不同，作为产品经理，需要团结团队里的每一个人，让大家朝着同一个目标努力。</p><p>产品经理需要跟所有人解释，某件事的重要性，某个功能为什么存在，某件事为什么要那么做等等。而且，因为认知的差别，你与每个人的沟通方式也要有差别，找到合适的沟通方式才能获得对方支持。</p><h2 id="挖掘真实需求"><a href="#挖掘真实需求" class="headerlink" title="挖掘真实需求"></a>挖掘真实需求</h2><p>客户往往在提需求的时候还会赠送一个解决方案，会告诉你怎么做，而没有说为什么要这么做。开发工程师擅长的就是按照一个实现方案将功能实现。</p><p>当转为产品经理后，就不能被客户牵着鼻子走，需要去挖掘客户背后的真实需求，之前看《有效需求分析》时有个例子现在还记忆深刻：</p><blockquote><p>晚上小孩吵着说要吃饼干，最后给了点面包，小孩吃完就乖乖睡着了，在这里吃饼干是方案，需求是小孩的肚子饿了，当没有饼干时，可以使用第二种方案，给他吃面包也可以解决这个需求问题。</p></blockquote><p>搞懂了小孩的真实需求是肚子饿，而不是吃饼干或面包，事情就好办多。所以，只有了解了真实背景，挖掘了客户背后的诉求，才能设计出能够解决客户痛点的产品功能。</p><h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><p>程序员就是一个需要持续学习的职业，不过当工作需要的技能非常熟练后，往往就疏于学习了。当转产品经理后更是需要有持续学习的能力。</p><p>如果做的是平台型产品，功能不断迭代，需要将不同类型的客户需求收集、分析、转化为平台功能，客户的类型在变化、客户的使用习惯也可能变化，不学习难以应对这种变化。</p><p>如果做的是业务型产品，你需要快速熟悉和了解一个行业，才能和客户、业务专家平等对话，在《麦肯锡方法》中介绍快速了解一个行业可以按下面三个步骤：</p><p>1、总结行业的 100 个关键词；</p><p>2、找三五个专家访谈，了解各种行业问题；</p><p>3、找三五本行业专业书籍，仔细阅读并找出共性。</p><p>上面的三个步骤就是学习的过程。</p><h2 id="注重业务场景"><a href="#注重业务场景" class="headerlink" title="注重业务场景"></a>注重业务场景</h2><p>很多时候，开发工程师把一个功能的代码写完，提交测试了，可能还不清楚这个功能具体是做什么用的。这是因为看到的是点而不是面。</p><p>当转为产品经理后，就需要有全局的思维，从宏观上来思考问题，以满足实际业务场景为目的，然后再逐步分解到具体的功能点。如果还是像做开发时那样，产品会变成一堆零碎功能的堆砌，看似很强大，实则是四不像。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>从开发工程师到产品经理，是一个比较大的跨越，首先需要提高认知维度，知道产品经理和开发工程师的不同，然后再转变思维模式，思维模式变了，最终做事的方式方法自然就会发生变化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有一类产品经理是由开发工程师转岗而来。就拿我来说，自从管理产品团队后，经常会和团队的产品经理进行新功能的讨论、会考虑产品未来的发展方向和路径，慢慢的我的工作重心也更多的偏向产品设计。&lt;/p&gt;</summary>
    
    
    
    <category term="产品" scheme="http://fwhyy.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="B 端软件" scheme="http://fwhyy.com/tags/b-%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="产品经理" scheme="http://fwhyy.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>从马拉松到越野跑：一次新的挑战</title>
    <link href="http://fwhyy.com/2023/09/from-marathon-to-trail-running-a-new-challenge/"/>
    <id>http://fwhyy.com/2023/09/from-marathon-to-trail-running-a-new-challenge/</id>
    <published>2023-09-12T01:34:58.000Z</published>
    <updated>2023-10-21T09:36:14.321Z</updated>
    
    <content type="html"><![CDATA[<p>从 16 年开始跑步以来大小马拉松比赛参加过十几场，近几年，身边有朋友从公路马拉松转战到了越野跑，在他们的带动下，我对越野跑有了更多的关注和了解。并且和一个朋友一起报了 12 月份的大岩山越野赛 30 公里组别，正式开启了我的越野之路。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309120747336.webp"></p><p>隔行如隔山，一研究发现越野跑跟公路马拉松差别巨大。下面就说说区别和一些注意事项。</p><h2 id="越野跑和公路马拉松的区别"><a href="#越野跑和公路马拉松的区别" class="headerlink" title="越野跑和公路马拉松的区别"></a>越野跑和公路马拉松的区别</h2><p>赛道：公路马拉松是在城市的平坦或略有起伏（上高架、大桥）的道路上进行，而越野跑是在山野、森林、沙漠等自然环境中进行，赛道地形复杂多变，有大量的上下坡，甚至需要攀爬或涉水。</p><p>距离：公路马拉松的标准距离是 42.195 公里，半程马拉松  21.0975  公里。而越野跑的距离则没有固定的标准，从几公里到几百公里都有可能，一般分为短程、中程、长程和超长程等不同级别。像我这次报的 30 公里，就属于难度比较低的级别。</p><p>时间：公路马拉松的比赛时间一般在 2 到 6 个小时之间，而越野跑的比赛时间则可能长达几天甚至几周，需要在山野中过夜或者自行选择休息点。</p><p>难度：公路马拉松的难度主要取决于配速和耐力，而越野跑的难度则涉及到技巧、体能、装备、安全、心理等多方面的因素，需要更高的综合素质和适应能力。</p><p>规则：公路马拉松的规则相对简单明确，主要是按照时间和顺序划分名次和奖励，而越野跑的规则则根据不同的赛事有所差异，一般会有强制装备、累计爬升、限时关门等要求，需要提前了解并遵守。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309120747491.webp"></p><h2 id="装备"><a href="#装备" class="headerlink" title="装备"></a>装备</h2><p>在越野跑中，有强制装备需要检查，这一点和公路马拉松有很大的区别，之所以要检查强制装备，是为了安全考虑，特别是 21  年的  522 事件后，强制装备更加严格了。</p><h3 id="越野鞋"><a href="#越野鞋" class="headerlink" title="越野鞋"></a>越野鞋</h3><p>相比马拉松跑鞋，越野跑鞋需要提供更好的抓地力和保护，以应对更复杂的地形。提及比较多的有下面几个品牌：</p><ul><li>凯乐石  Fuga EX 系列</li><li>HOKA  飞速羚羊系列</li><li>奥创 奥林巴斯系列</li></ul><p>鞋子非常重要，能力范围内需要买好一点的。</p><h3 id="越野跑背包（强制）"><a href="#越野跑背包（强制）" class="headerlink" title="越野跑背包（强制）"></a>越野跑背包（强制）</h3><p>用于装载能量补给、水、急救包等必要物品。30 公里距离的 5L 就够用了，在朋友的推荐下，准备选购 UG 的 6 升越野包。</p><p>如果你的腰包能装下所有强制装备，不用背包也可以。</p><h3 id="号码布和参赛手环（强制）"><a href="#号码布和参赛手环（强制）" class="headerlink" title="号码布和参赛手环（强制）"></a>号码布和参赛手环（强制）</h3><p>识别身份，需要全程佩戴。</p><h3 id="计时芯片（强制）"><a href="#计时芯片（强制）" class="headerlink" title="计时芯片（强制）"></a>计时芯片（强制）</h3><p>计时芯片需要好好保护，否则跑的累死，没有成绩了。需要注意的是保温毯可能对计时芯片有屏蔽作用，不要放在一起。</p><h3 id="急救毯（强制）"><a href="#急救毯（强制）" class="headerlink" title="急救毯（强制）"></a>急救毯（强制）</h3><p>应该是超过  30 公里的距离必须全程携带，关键时候可以救命。使用时建议尽量贴身，打结后套住头部，然后包覆核心躯干，再穿上外套，防风，隔湿，保温。</p><p>急救毯尺寸不小于 1.5m x 2.0m 。</p><p>急救毯属于消耗类强制装备，使用后不允许丢弃，须凭已消耗的装备或装备包装到达站点更换新的装备。</p><h3 id="救生口哨（强制）"><a href="#救生口哨（强制）" class="headerlink" title="救生口哨（强制）"></a>救生口哨（强制）</h3><p>大部分越野包都有配备，如果使用的是腰包，需要单独佩戴。仅在遇到危险，需要帮助时使用。</p><h3 id="急救包：弹力绷带、无菌敷料（强制）"><a href="#急救包：弹力绷带、无菌敷料（强制）" class="headerlink" title="急救包：弹力绷带、无菌敷料（强制）"></a>急救包：弹力绷带、无菌敷料（强制）</h3><ul><li>弹力绷带用于局部固定及加压包扎，规格要求不小于 100cm X 5cm</li><li>无菌敷料主要用于伤口止血，防止污染，规格要求不小于 10cm X 10cm</li></ul><p>急救用品也属于消耗类强制装备，可自用或给需要帮助的选手使用，消耗后凭有效证明可到补给站补充。</p><h3 id="智能手机及充电宝（强制）"><a href="#智能手机及充电宝（强制）" class="headerlink" title="智能手机及充电宝（强制）"></a>智能手机及充电宝（强制）</h3><ul><li>手机的手机号码需和报名信息填写的号码一致</li><li>智能手机需具备查看官方发布的赛事轨迹和导航的功能</li><li>比赛期间需保证手机处于可通联状态</li><li>预估自己手机的耗电情况，随身携带足量的充电宝确保手机全程可用，有的赛事会强制要求带充电宝</li></ul><h3 id="水具（强制）"><a href="#水具（强制）" class="headerlink" title="水具（强制）"></a>水具（强制）</h3><ul><li>很多越野包自带软水壶，没有软水壶的，搞两瓶矿泉水插在越野包上也是可以的</li><li>水具必须可密封</li><li>容量必须大于强制装备的规定，不同赛事和组别要求不一样</li><li>除了软水壶，还需要便携式水杯</li></ul><h3 id="防水防风连帽夹克（强制）"><a href="#防水防风连帽夹克（强制）" class="headerlink" title="防水防风连帽夹克（强制）"></a>防水防风连帽夹克（强制）</h3><ul><li>帽子与身体部分必须为一体结构</li><li>服装面料为防水材质，所有的缝线处须有压胶密封</li></ul><h3 id="头灯"><a href="#头灯" class="headerlink" title="头灯"></a>头灯</h3><p>通常  50  公里或以上组别才需要头灯。</p><h3 id="长袖保暖上衣（强制）"><a href="#长袖保暖上衣（强制）" class="headerlink" title="长袖保暖上衣（强制）"></a>长袖保暖上衣（强制）</h3><p> 建议服装面辅料为抓绒、羊毛或其他具有保暖速干效果的材质，保暖上衣重量不低于200g。</p><h3 id="应急能量食品"><a href="#应急能量食品" class="headerlink" title="应急能量食品"></a>应急能量食品</h3><p>不一定是能量胶，所有高热量的食品都可以，有的赛事会要求必须携带不低于其组别要求数量（能量值）的能量食品。</p><h3 id="手表"><a href="#手表" class="headerlink" title="手表"></a>手表</h3><p>我用的佳明 245 没有越野功能，不过这次有人带着一起跑，倒不着急买新的手表，目前关注的手表：佳明  255、265 、955，高驰的  apex 2 pro  等。</p><h3 id="其他装备"><a href="#其他装备" class="headerlink" title="其他装备"></a>其他装备</h3><p>全指手套、帽子、太阳镜、登山杖，防晒霜，防晒臂套等。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309120747385.webp"></p><h2 id="越野跑训练"><a href="#越野跑训练" class="headerlink" title="越野跑训练"></a>越野跑训练</h2><p>从马拉松转到越野跑，训练的重点应该从速度和耐力转向力量和平衡，当然为了能跟得上朋友的速度，速度也需要有所提升。</p><p>下面是我的计划：</p><p>1、比赛时间为  12 月 3 号，还有  3  个月的时间可以训练。</p><p>2、平均每个月的跑量在 200 公里以上，增加跑量是因为越野跑需要更强的耐力和体能，不过在训练的同时也需要注意休息，让身体能够恢复。</p><p>3、每周一到两次的间歇跑，400m X 10 ，配速  430，通过间歇跑来提升下速度。</p><p>4、3  个月内，至少两次长距离的  LSD（25～28 公里）。</p><p>5、加强核心力量，可以提高你在复杂地形中的稳定性和平衡性，可以进行卷腹、单杠提膝等练习。</p><p>6、加强腿部力量，即便是公路马拉松，腿部力量也非常重要，可以减少受伤的风险，可以进行深蹲、爬楼等练习。</p><p>7、每周至少一次的爬升训练，选择一些有坡度的路段或者楼梯进行上下跑，需要注意调整步幅和节奏，避免过度用力或气喘。</p><p>8、技巧练习，越野跑中有很多的技巧，如下坡跑、越障跑、使用登山杖等，这些技巧都需要你通过实践和练习来掌握和熟练。</p><p>9、找个山路跑跑，适应下环境。</p><h2 id="著名的越野赛事"><a href="#著名的越野赛事" class="headerlink" title="著名的越野赛事"></a>著名的越野赛事</h2><p>全球有很多著名的越野赛事，例如：</p><ul><li>UTMB（Ultra-Trail du Mont-Blanc）：这是世界上最著名的越野跑赛事之一，每年在法国、意大利、瑞士三国交界处的阿尔卑斯山脉举行，以环绕欧洲最高峰勃朗峰为特色，共有 7 个不同级别的比赛，从 15 公里到 170 公里不等，吸引了来自全球的顶尖选手和爱好者参与。</li><li>WSER（Western States Endurance Run）：这是世界上最古老的100英里（约161公里）越野跑赛事之一，每年在美国加利福尼亚州举行，以穿越西部山脉和河谷为特色，从海拔2400米的高山到海拔400米的平原，温差可达40摄氏度，是一项极具挑战性的赛事。</li><li>UTWT（Ultra-Trail World Tour）：这是一个国际性的越野跑系列赛事，每年在全球不同的地点举行多场超长程（超过100公里）的比赛，包括 UTMB、WSER 等知名赛事在内，为选手提供了一个展示自己和与其他选手竞争的平台。</li></ul><p>国内的有香港 100、崇礼 168、莫干山越野挑战赛、柴古唐斯越野挑战赛等。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309120749742.webp"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、参赛选手在领取参赛物品前，必须携带安全强制装备清单中所有装备接受检查，不符合条件者将无法领取参赛物品。</p><p>2、选手在比赛过程中必须全程携带与所参赛组别对应的所有安全强制装备，组委会将在起终点及赛道中进行安全强制装备检查，参赛选手须无条件配合，检查不合格者将接受组委会的处罚。</p><p>3、消耗类强制装备（急救毯、能量食品、急救包），使用后不允许丢弃，须凭已消耗的装备或装备包装到达站点更换新的装备。</p><p>4、组委会有权在赛前根据天气情况，追加强装的种类及数量，注意官方信息的发布。</p><p>5、安全第一，越野跑中可能会遇到各种危险和困难，如迷路、受伤、脱水、低温、高原反应等，所以你需要做好充分的准备和预防，携带必要的装备和物品，并且遵守赛事规则和指示，在遇到问题时及时求助或放弃。</p><p>6、尊重自然，越野跑中你会接触到很多美丽而脆弱的自然景观和生态系统，所以你需要尊重自然，保护环境，不要破坏植被或动物，不要乱扔垃圾或其他物品，并且尽量减少对自然资源的消耗。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>敬畏自然，安全最重要，希望 12 月份能安全完赛，也期待明年能挑战更高级别的赛事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从 16 年开始跑步以来大小马拉松比赛参加过十几场，近几年，身边有朋友从公路马拉松转战到了越野跑，在他们的带动下，我对越野跑有了更多的关注和了解。并且和一个朋友一起报了 12 月份的大岩山越野赛 30 公里组别，正式开启了我的越野之路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h</summary>
      
    
    
    
    <category term="跑步" scheme="http://fwhyy.com/categories/%E8%B7%91%E6%AD%A5/"/>
    
    
    <category term="马拉松" scheme="http://fwhyy.com/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/"/>
    
    <category term="跑步" scheme="http://fwhyy.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
    <category term="越野跑" scheme="http://fwhyy.com/tags/%E8%B6%8A%E9%87%8E%E8%B7%91/"/>
    
  </entry>
  
  <entry>
    <title>分享几个网站和工具（202309）</title>
    <link href="http://fwhyy.com/2023/09/share-some-website-and-tools-202309/"/>
    <id>http://fwhyy.com/2023/09/share-some-website-and-tools-202309/</id>
    <published>2023-09-05T01:32:48.000Z</published>
    <updated>2023-10-21T09:33:49.990Z</updated>
    
    <content type="html"><![CDATA[<p>最近又收集了一些工具和站点，分享给大家。</p><span id="more"></span><h2 id="Wrokout"><a href="#Wrokout" class="headerlink" title="Wrokout"></a>Wrokout</h2><p><a href="https://workout.lol/">https://workout.lol</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050626666.webp"></p><p>这个一个辅助锻炼的网站，选择锻炼器械，也包括自重，然后选择需要锻炼的部位，就会给出一些列的视频教程。</p><p>对于健身初学者来说，很有帮助。</p><h2 id="roadmap"><a href="#roadmap" class="headerlink" title="roadmap"></a>roadmap</h2><p><a href="https://roadmap.sh/">https://roadmap.sh/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050626549.webp"></p><p>一个技术学习路线图的网站，提供前端、后端、全栈等，还有各种具体的技术，如：Python、.NET Core、Vue 等。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050626921.webp"></p><p>每一个知识点的详情页面中会提供相关的学习资源。</p><h2 id="Youtube-中文配音"><a href="#Youtube-中文配音" class="headerlink" title="Youtube 中文配音"></a>Youtube 中文配音</h2><p><a href="https://www.youtube-dubbing.com/">https://www.youtube-dubbing.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050627656.webp"></p><p>这是一款 Chrome 浏览器插件，安装插件后，在 YouTube 视频的下方会出现「开始翻译播放」，点击此按钮，稍等片刻，视频语音会变成 AI 的翻译后的中文语音：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050627765.webp"></p><h2 id="TypeScript-开源教程"><a href="#TypeScript-开源教程" class="headerlink" title="TypeScript 开源教程"></a>TypeScript 开源教程</h2><p><a href="https://github.com/wangdoc/typescript-tutorial">https://github.com/wangdoc/typescript-tutorial</a></p><p><a href="https://wangdoc.com/">https://wangdoc.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050627590.webp"></p><p>TypeScript 是由 Microsoft 开发和维护的编程语言，它是 JavaScript 的超集，它在 JavaScript 的基础上添加了一些新的特性和语法，使开发者能够更容易编写可靠、可维护的代码。</p><p>这本书的作者是阮一峰，阮一峰的博客很早就在关注，一个很大的特点就是很擅长深入浅出地去讲解各种知识点。</p><h2 id="APP-截图网站"><a href="#APP-截图网站" class="headerlink" title="APP  截图网站"></a>APP  截图网站</h2><p><a href="https://uinotes.com/pin">https://uinotes.com/pin</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050627492.webp"></p><p>一个 APP UI 截图资源的网站，可以按照公司和行业进行筛选。多看看一些优秀的设计方案，对产品经理激发灵感很有帮助。</p><h2 id="大厂关停服务"><a href="#大厂关停服务" class="headerlink" title="大厂关停服务"></a>大厂关停服务</h2><p><a href="https://killedby.tech/">https://killedby.tech</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050628220.webp"></p><p>记录一些大公司：谷歌、苹果和微软等已经关停或未来会关停的产品和服务，可以按时间轴去进行查看。</p><h2 id="企典-钉钉出品的免费企业信息查询工具"><a href="#企典-钉钉出品的免费企业信息查询工具" class="headerlink" title="企典-钉钉出品的免费企业信息查询工具"></a>企典-钉钉出品的免费企业信息查询工具</h2><p><a href="https://dingtalk.com/qidian/home">https://dingtalk.com/qidian/home</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050628581.webp"></p><p>天眼查、企查查的竞品，刚上线不久，趁现在还是免费，可以赶紧查起来。</p><h2 id="Gpt-Demo-发现最新最好用的-AI-工具"><a href="#Gpt-Demo-发现最新最好用的-AI-工具" class="headerlink" title="Gpt Demo - 发现最新最好用的 AI 工具"></a>Gpt Demo - 发现最新最好用的 AI 工具</h2><p><a href="https://www.gptdemo.net/cn/">https://www.gptdemo.net/cn/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050628696.webp"></p><p>一个帮助我们了解现在各种 AI 工具动态的网站，网站提供了非常全面的 AI 工具分类以及标签供你选择，包括功能介绍、免费与否和用户评论。</p><p>在现在 AI 工具层出不穷的现状下，用这个网站正好可以做下筛选。</p><h2 id="AI-新闻聚合网站"><a href="#AI-新闻聚合网站" class="headerlink" title="AI 新闻聚合网站"></a>AI 新闻聚合网站</h2><p><a href="https://allainews.com/">https://allainews.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050629183.webp"></p><p>如果你对人工智能、机器学习、深度学习、NLP 等有兴趣，那么这个网站可以帮你更好了解相关的信息和发展情况。</p><p>汇聚了各类新闻、博客、播客等。</p><h2 id="Pake-版本的-YouTube-Music"><a href="#Pake-版本的-YouTube-Music" class="headerlink" title="Pake 版本的 YouTube Music"></a>Pake 版本的 YouTube Music</h2><p><a href="https://github.com/tw93/Pake">https://github.com/tw93/Pake</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050629532.webp"></p><p>YouTube Music 没有 Mac 版，最近发现 Pake 的 Github 主页上已经提供了 YouTube Music 客户的下载。</p><p>Pake 是一个可以将网页应用打包为客户端的开源项目，我在 Mac 上使用即刻就是使用 Pake 制作的。</p><h2 id="Awesome-Web-Desktops"><a href="#Awesome-Web-Desktops" class="headerlink" title="Awesome Web Desktops"></a>Awesome Web Desktops</h2><p><a href="https://simone.computer/#/webdesktops">https://simone.computer/#/webdesktops</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050631549.webp"></p><p>可以在这个网站中体验 160 多个桌面操作系统，上图是 Windows 98 的系统界面。开发者非常热衷于复古计算机，并且非常喜欢 90 年代和 2000 年代初的仿拟设计用户界面。</p><p>包括开发者的主页也是这个风格：<a href="https://simone.computer/">https://simone.computer</a></p><h2 id="一款内置-AI-的-PDF-工具"><a href="#一款内置-AI-的-PDF-工具" class="headerlink" title="一款内置 AI 的 PDF 工具"></a>一款内置 AI 的 PDF 工具</h2><p><a href="https://www.pdfgear.com/">https://www.pdfgear.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050631082.webp"></p><p>支持 Windows/macOS/ios，并且都是免费的。它支持数十种格式与 PDF 之间的转换，并且支持编辑、压缩、签名、文本提取、OCR文字识别等功能。</p><p>亮点就是接入了 AI 聊天机器人，没有聊天限制，扫描版一样可以解析。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050631313.webp"></p><h2 id="Spacedrive"><a href="#Spacedrive" class="headerlink" title="Spacedrive"></a>Spacedrive</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202309050632164.webp"></p><p>一直都觉得 Mac 上的访达不太好用，最近发现了 Spacedrive 这个工具，不过还需要排队。</p><p>Spacedrive 是一个强大的文件浏览器，可以帮助你更好地管理和组织你的文件。支持 macOS、Windows、Linux、iOS 和 Android。</p><p>期待早日可以试用。</p><h2 id="一点资料"><a href="#一点资料" class="headerlink" title="一点资料"></a>一点资料</h2><p><a href="https://docs.qq.com/aio/DWVRkZ1RUWHRsdU1J?p=3xevUv9be6t0B1pY9ZK5AA">https://docs.qq.com/aio/DWVRkZ1RUWHRsdU1J?p=3xevUv9be6t0B1pY9ZK5AA</a></p><p>一些大师关于写作的言论，有王小波、莫言、余华、史铁生等。</p><p><a href="https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf">https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf</a></p><p>认知偏差知识手册。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近又收集了一些工具和站点，分享给大家。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="分享" scheme="http://fwhyy.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="网站" scheme="http://fwhyy.com/tags/%E7%BD%91%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>博客园，挺住</title>
    <link href="http://fwhyy.com/2023/08/cnblogs-hold-on/"/>
    <id>http://fwhyy.com/2023/08/cnblogs-hold-on/</id>
    <published>2023-08-29T01:30:31.000Z</published>
    <updated>2023-10-21T09:31:52.952Z</updated>
    
    <content type="html"><![CDATA[<p>昨天才看到博客园团队在 8 月 16 号的发文：《弹尽粮绝，会员救园：会员上线，命悬一线》。第一时间就充会员支持了，尽管会员功能还不完善，需要添加企业微信人工处理。</p><span id="more"></span><p>我算是博客园的老用户了，06 年注册，发表过文章 300 多篇，曾经也到过前 100 名，近些年玩独立博客、写公众号后，使用频率就没那么高了，排名也因后来规则改变下降到 2000 多。但对博客园，依然怀有深深的感情。</p><p>今天又逛了逛园子，回想起之前的往事，这些名字仍然历历在目：老赵、张善友、宝玉、Terrylee、  artech、 anytao、路过秋天、金色海洋 、吉日、灵感之源、装配脑袋、司徒正美等。如今，也就张善友和宝玉近期在园子中有更新。</p><p>现在各类网站都充斥着广告、带货、周边、卖课，博客园算是一股清流，可能也正是如此，才会导致今天的经营困难。</p><p>希望博客园能度过这次难关，也能找到好的商业模式，慢慢走向正轨。虽然不常回去，但当我想回的时候，他还能安安静静的在那里。</p><p>购买会员通道：<a href="https://cnblogs.vip/">https://cnblogs.vip</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天才看到博客园团队在 8 月 16 号的发文：《弹尽粮绝，会员救园：会员上线，命悬一线》。第一时间就充会员支持了，尽管会员功能还不完善，需要添加企业微信人工处理。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="博客园" scheme="http://fwhyy.com/tags/%E5%8D%9A%E5%AE%A2%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>插件开发：实现 PicGo 图片转 webp 格式</title>
    <link href="http://fwhyy.com/2023/08/plugin-development-implement-picgo-image-to-webp-format-1/"/>
    <id>http://fwhyy.com/2023/08/plugin-development-implement-picgo-image-to-webp-format-1/</id>
    <published>2023-08-28T01:28:07.000Z</published>
    <updated>2023-10-21T09:29:31.012Z</updated>
    
    <content type="html"><![CDATA[<p>我写一些文档或者公众号文章使用的是  Typora，如果涉及到文章中有图片时，直接复制图片粘贴到 Typora 中，然后使用  PicGo 上传到图床。</p><p>这样不管是发布公众号（公众号会从图床下载然后上传）还是博客，图片地址的问题就解决了。但会有另外一个问题，网上下载的图片或者截图的图片通常比较大，现在我都是手动将文件转为 webp 格式，然后重新复制到 Typora 中，非常麻烦。</p><span id="more"></span><p>后来发现  PicGo 有插件机制，一个想法就诞生了：</p><ul><li>在 Typora 点击右键上传图片时，PicGo  插件接收到图片地址并将图片转为 webp 格式，存储到本地，返回给  PicGo  新的 webp 文件的地址；</li><li>PicGo 接收到新的地址进行图床的上传。</li></ul><p>下面就来讲解下怎样来实现这个插件的开发。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>node：v16.18.1</li><li>npm：9.1.2</li><li>PicGo：2.3.1</li><li>TypeScript：5.1.6</li></ul><h2 id="写代码前的准备"><a href="#写代码前的准备" class="headerlink" title="写代码前的准备"></a>写代码前的准备</h2><p>1、全局安装  picgo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install picgo -g</span><br></pre></td></tr></table></figure><p>2、使用  picgo  命令创建一个插件项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picgo init plugin convert-to-webp</span><br></pre></td></tr></table></figure><p>PicGo 的插件名称要求必须带有前缀：<code>picgo-plugin</code> ，否则不能识别，使用  picgo 脚手架创建插件项目时，后面的名称只需写真实名称即可，否则前缀会重复。</p><p>执行上面命令后，会有命令行的向导，需要填写一些关键信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">? Plugin name: convert-to-webp</span><br><span class="line">? Plugin description: convert image to webp</span><br><span class="line">? author: oec2003</span><br><span class="line">? Choose modules you want to develop:</span><br><span class="line"> ◯ uploader</span><br><span class="line"> ◯ transformer</span><br><span class="line">❯◯ beforeTransformPlugins</span><br><span class="line"> ◯ beforeUploadPlugins</span><br><span class="line"> ◯ afterUploadPlugins</span><br><span class="line"> </span><br><span class="line">Your plugin is just used in CLI? (Y/n) n</span><br><span class="line">? Use TS or JS? (Use arrow keys)</span><br><span class="line">❯ Yes, use TS Project(recommended) </span><br><span class="line">  Yes, use JS Project </span><br><span class="line">? Your plugin has some shortcut for GUI? (Y/n) n</span><br></pre></td></tr></table></figure><p>3、向导中推荐使用  TS  语言，我这里使用的就是默认选项，所以需要全局安装  typescript：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>4、本插件的目的需要将上传的图片转为  webp  格式，需要  sharp 库，安装命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g sharp</span><br><span class="line">npm install @types/sharp --save-dev</span><br></pre></td></tr></table></figure><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>1、使用脚手架创建的代码只有一个 index.ts 文件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272138599.webp"></p><p>2、在根目录中执行<code>npm install</code> 安装依赖。</p><p>3、index.ts 代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sharp <span class="keyword">from</span> <span class="string">&#x27;sharp&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; promises <span class="keyword">as</span> fs &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PicGo &#125; <span class="keyword">from</span> <span class="string">&#x27;picgo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = <span class="function">(<span class="params">ctx: PicGo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handle = <span class="keyword">async</span> (ctx: PicGo): <span class="built_in">Promise</span>&lt;PicGo&gt; =&gt; &#123;</span><br><span class="line">    <span class="comment">// ctx.input 是一个数组，因为都是单个文件上传，所以取数组中第一个数据就行</span></span><br><span class="line">    <span class="comment">// imgPath 得到的就是文件的本地路径</span></span><br><span class="line">    <span class="keyword">let</span> [imgPath] = ctx.input;</span><br><span class="line">    <span class="keyword">let</span> imgExt= path.extname(imgPath);</span><br><span class="line">    <span class="comment">//如果上传的就是 webp 格式的文件直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (imgExt === <span class="string">&#x27;.webp&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将文件转为 webp 格式的流</span></span><br><span class="line">    <span class="keyword">let</span> imgBuffer = <span class="keyword">await</span> sharp(imgPath)</span><br><span class="line">      .webp()</span><br><span class="line">      .toBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到 webp 文件的本地路径</span></span><br><span class="line">    <span class="keyword">const</span> webpPath =path.join(path.dirname(imgPath), path.basename(imgPath, imgExt) + <span class="string">&#x27;.webp&#x27;</span>);</span><br><span class="line">    <span class="comment">//将 webp 文件写入本地，我是想要在本地保留 webp 文件的备份</span></span><br><span class="line">    <span class="comment">// 如果不需要，也可以在 afterUploadPlugins 事件中将本地文件删除</span></span><br><span class="line">    <span class="keyword">await</span> fs.writeFile(webpPath, imgBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的 webp 地址包装为数组返回给  ctx 的 input 对象 </span></span><br><span class="line">    ctx.input = [webpPath]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> register = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//注意：此处需要使用 beforeTransformPlugins 事件</span></span><br><span class="line">    ctx.helper.beforeTransformPlugins.register(<span class="string">&#x27;picgo-plugin-convert-to-webp&#x27;</span>, &#123;</span><br><span class="line">      handle</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    register</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、执行命令 <code>npm run build</code> 进行打包，打包后会生成 dist 目录，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272138899.webp"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、在 PicGo 的插件设置中，导入本地插件：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139541.webp"></p><p>2、目录选择 dist 目录所在的目录：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139700.webp"></p><p>3、安装成功后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139512.webp"></p><p>4、这时可以截图粘贴到 Typora 中，点击右键上传图片：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139551.webp"></p><p>上传成功后，会发现已经变成了 webp 格式：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139762.webp"></p><h2 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h2><p>1、如果插件的代码有修改，可以在 package.json 文件中升级一个版本，重新打包：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272141636.webp"></p><p>2、卸载插件，不卸载进行本地插件导入，会提示成功，但实际没有成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272143098.webp"></p><p>3、重新本地导入插件。</p><p>4、导入成功后，需要更新插件：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139721.webp"></p><p>5、更新成功后，需要重启才能生效：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272140389.webp"></p><p>6、重启后，如果看到版本变为 1.0.1 表示更新成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272140314.webp"></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在导入本地插件或者进行图片上传的过程中，有可能会出现错误，错误日志会记录在 picgo.log 文件中，在 Mac 系统中，该文件的路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Application\ Support/picgo/picgo.log</span><br></pre></td></tr></table></figure><p>比如：我们在代码中可以通过下面的代码来输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.log.info(&#x27;ctx.input.path&#x27;+imgPath)</span><br></pre></td></tr></table></figure><p>在 picgo.log 中就会输出日志：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272140648.webp"></p><p>通过这个日志文件的内容，可以进行错误的排查。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本插件的源码已经上传到 Github，地址如下：</p><p><a href="https://github.com/oec2003/picgo-plugin-convert-to-webp">https://github.com/oec2003/picgo-plugin-convert-to-webp</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我写一些文档或者公众号文章使用的是  Typora，如果涉及到文章中有图片时，直接复制图片粘贴到 Typora 中，然后使用  PicGo 上传到图床。&lt;/p&gt;
&lt;p&gt;这样不管是发布公众号（公众号会从图床下载然后上传）还是博客，图片地址的问题就解决了。但会有另外一个问题，网上下载的图片或者截图的图片通常比较大，现在我都是手动将文件转为 webp 格式，然后重新复制到 Typora 中，非常麻烦。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="插件开发" scheme="http://fwhyy.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="PicGo" scheme="http://fwhyy.com/tags/picgo/"/>
    
  </entry>
  
  <entry>
    <title>插件开发：实现 PicGo 图片转 webp 格式</title>
    <link href="http://fwhyy.com/2023/08/plugin-development-implement-picgo-image-to-webp-format/"/>
    <id>http://fwhyy.com/2023/08/plugin-development-implement-picgo-image-to-webp-format/</id>
    <published>2023-08-28T01:18:14.000Z</published>
    <updated>2023-08-28T03:19:28.719Z</updated>
    
    <content type="html"><![CDATA[<p>我写一些文档或者公众号文章使用的是  Typora，如果涉及到文章中有图片时，直接复制图片粘贴到 Typora 中，然后使用  PicGo 上传到图床。</p><span id="more"></span><p>这样不管是发布公众号（公众号会从图床下载然后上传）还是博客，图片地址的问题就解决了。但会有另外一个问题，网上下载的图片或者截图的图片通常比较大，现在我都是手动将文件转为 webp 格式，然后重新复制到 Typora 中，非常麻烦。</p><p>后来发现  PicGo 有插件机制，一个想法就诞生了：</p><ul><li>在 Typora 点击右键上传图片时，PicGo  插件接收到图片地址并将图片转为 webp 格式，存储到本地，返回给  PicGo  新的 webp 文件的地址；</li><li>PicGo 接收到新的地址进行图床的上传。</li></ul><p>下面就来讲解下怎样来实现这个插件的开发。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>node：v16.18.1</li><li>npm：9.1.2</li><li>PicGo：2.3.1</li><li>TypeScript：5.1.6</li></ul><h2 id="写代码前的准备"><a href="#写代码前的准备" class="headerlink" title="写代码前的准备"></a>写代码前的准备</h2><p>1、全局安装  picgo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install picgo -g</span><br></pre></td></tr></table></figure><p>2、使用  picgo  命令创建一个插件项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">picgo init plugin convert-to-webp</span><br></pre></td></tr></table></figure><p>PicGo 的插件名称要求必须带有前缀：<code>picgo-plugin</code> ，否则不能识别，使用  picgo 脚手架创建插件项目时，后面的名称只需写真实名称即可，否则前缀会重复。</p><p>执行上面命令后，会有命令行的向导，需要填写一些关键信息，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">? Plugin name: convert-to-webp</span><br><span class="line">? Plugin description: convert image to webp</span><br><span class="line">? author: oec2003</span><br><span class="line">? Choose modules you want to develop:</span><br><span class="line"> ◯ uploader</span><br><span class="line"> ◯ transformer</span><br><span class="line">❯◯ beforeTransformPlugins</span><br><span class="line"> ◯ beforeUploadPlugins</span><br><span class="line"> ◯ afterUploadPlugins</span><br><span class="line"> </span><br><span class="line">Your plugin is just used in CLI? (Y/n) n</span><br><span class="line">? Use TS or JS? (Use arrow keys)</span><br><span class="line">❯ Yes, use TS Project(recommended) </span><br><span class="line">  Yes, use JS Project </span><br><span class="line">? Your plugin has some shortcut for GUI? (Y/n) n</span><br></pre></td></tr></table></figure><p>3、向导中推荐使用  TS  语言，我这里使用的就是默认选项，所以需要全局安装  typescript：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><p>4、本插件的目的需要将上传的图片转为  webp  格式，需要  sharp 库，安装命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g sharp</span><br><span class="line">npm install @types/sharp --save-dev</span><br></pre></td></tr></table></figure><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>1、使用脚手架创建的代码只有一个 index.ts 文件，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272138599.webp"></p><p>2、在根目录中执行<code>npm install</code> 安装依赖。</p><p>3、index.ts 代码如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> sharp <span class="keyword">from</span> <span class="string">&#x27;sharp&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; promises <span class="keyword">as</span> fs &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; PicGo &#125; <span class="keyword">from</span> <span class="string">&#x27;picgo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = <span class="function">(<span class="params">ctx: PicGo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handle = <span class="keyword">async</span> (ctx: PicGo): <span class="built_in">Promise</span>&lt;PicGo&gt; =&gt; &#123;</span><br><span class="line">    <span class="comment">// ctx.input 是一个数组，因为都是单个文件上传，所以取数组中第一个数据就行</span></span><br><span class="line">    <span class="comment">// imgPath 得到的就是文件的本地路径</span></span><br><span class="line">    <span class="keyword">let</span> [imgPath] = ctx.input;</span><br><span class="line">    <span class="keyword">let</span> imgExt= path.extname(imgPath);</span><br><span class="line">    <span class="comment">//如果上传的就是 webp 格式的文件直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (imgExt === <span class="string">&#x27;.webp&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将文件转为 webp 格式的流</span></span><br><span class="line">    <span class="keyword">let</span> imgBuffer = <span class="keyword">await</span> sharp(imgPath)</span><br><span class="line">      .webp()</span><br><span class="line">      .toBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到 webp 文件的本地路径</span></span><br><span class="line">    <span class="keyword">const</span> webpPath =path.join(path.dirname(imgPath), path.basename(imgPath, imgExt) + <span class="string">&#x27;.webp&#x27;</span>);</span><br><span class="line">    <span class="comment">//将 webp 文件写入本地，我是想要在本地保留 webp 文件的备份</span></span><br><span class="line">    <span class="comment">// 如果不需要，也可以在 afterUploadPlugins 事件中将本地文件删除</span></span><br><span class="line">    <span class="keyword">await</span> fs.writeFile(webpPath, imgBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的 webp 地址包装为数组返回给  ctx 的 input 对象 </span></span><br><span class="line">    ctx.input = [webpPath]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ctx;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> register = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//注意：此处需要使用 beforeTransformPlugins 事件</span></span><br><span class="line">    ctx.helper.beforeTransformPlugins.register(<span class="string">&#x27;picgo-plugin-convert-to-webp&#x27;</span>, &#123;</span><br><span class="line">      handle</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    register</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、执行命令 <code>npm run build</code> 进行打包，打包后会生成 dist 目录，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272138899.webp"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、在 PicGo 的插件设置中，导入本地插件：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139541.webp"></p><p>2、目录选择 dist 目录所在的目录：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139700.webp"></p><p>3、安装成功后如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139512.webp"></p><p>4、这时可以截图粘贴到 Typora 中，点击右键上传图片：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139551.webp"></p><p>上传成功后，会发现已经变成了 webp 格式：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139762.webp"></p><h2 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h2><p>1、如果插件的代码有修改，可以在 package.json 文件中升级一个版本，重新打包：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272141636.webp"></p><p>2、卸载插件，不卸载进行本地插件导入，会提示成功，但实际没有成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272143098.webp"></p><p>3、重新本地导入插件。</p><p>4、导入成功后，需要更新插件：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272139721.webp"></p><p>5、更新成功后，需要重启才能生效：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272140389.webp"></p><p>6、重启后，如果看到版本变为 1.0.1 表示更新成功：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272140314.webp"></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在导入本地插件或者进行图片上传的过程中，有可能会出现错误，错误日志会记录在 picgo.log 文件中，在 Mac 系统中，该文件的路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Application\ Support/picgo/picgo.log</span><br></pre></td></tr></table></figure><p>比如：我们在代码中可以通过下面的代码来输出日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.log.info(&#x27;ctx.input.path&#x27;+imgPath)</span><br></pre></td></tr></table></figure><p>在 picgo.log 中就会输出日志：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308272140648.webp"></p><p>通过这个日志文件的内容，可以进行错误的排查。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本插件的源码已经上传到 Github，地址如下：</p><p><a href="https://github.com/oec2003/picgo-plugin-convert-to-webp">https://github.com/oec2003/picgo-plugin-convert-to-webp</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我写一些文档或者公众号文章使用的是  Typora，如果涉及到文章中有图片时，直接复制图片粘贴到 Typora 中，然后使用  PicGo 上传到图床。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="插件开发" scheme="http://fwhyy.com/tags/%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    <category term="PicGo" scheme="http://fwhyy.com/tags/picgo/"/>
    
  </entry>
  
  <entry>
    <title>软件推荐：Mac神器  Raycast</title>
    <link href="http://fwhyy.com/2023/08/software-recommendation-mac-artifact-raycast/"/>
    <id>http://fwhyy.com/2023/08/software-recommendation-mac-artifact-raycast/</id>
    <published>2023-08-21T01:12:17.000Z</published>
    <updated>2023-08-28T03:13:36.871Z</updated>
    
    <content type="html"><![CDATA[<p>Raycast 是一款 Mac 上的启动器工具，功能类似于 Mac 自带的 「焦点（Spotlight）」。关于启动器工具，如果你没使用过 Spotlight ，一定用过或听说过大名鼎鼎的  Alfred 。启动器工具可以让他们快速打开  Mac  应用，而 Raycast 不仅仅只是一个启动器。</p><span id="more"></span><p>用了 Raycast 后，我默默把 Alfred 设置了开机不自动启动，也许很快就会卸载掉。</p><p>下面就介绍下 Raycast 的使用。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Raycast 的安装非常简单，官网下载即可。</p><p>官网地址：<a href="https://www.raycast.com/">https://www.raycast.com/</a></p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202127374.webp"></p><p>Raycast 的  Pro  版需要每月  8  美元，提供  AI  功能，如果需要将  AI  能力升级到  GPT-4 ，则需要每月 16  美元，不过对我来说，免费功能已经完全够用。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>默认 Raycast 随电脑启动，运行在后台，需要使用的时候按快捷键 <code>option + 空格</code> 就可以打开操作界面，<code>option + 空格</code> 是默认的设置，也可以通过设置修改为其他，界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202127207.webp"></p><p>在输入框中输入关键字就能快速打开应用或文件。</p><h2 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h2><p>刚安装 Raycast，应用会置顶一个 Walkthrough 指令，也就是新用户指南。里面有介绍非常多的基础使用方法，甚至是用了很久可能都没有发现的小技巧。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202127509.webp"></p><p>按照这个里面的指引，可以快速学习 Raycast 的用法。当然不看这个指引，随着慢慢使用的深入，也能了解到所有功能，看个人选择了。</p><h2 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h2><p>Raycast 有命令、脚本、应用、快链四种类型的指令</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202127879.webp"></p><ul><li>命令：比如搜索文件、安装的扩展</li><li>脚本：暂未使用到</li><li>应用：Mac 中安装的应用 ，包括使用 Parallels 安装的应用</li><li>快链：可以设置网站链接、并可以添加参数实现直接 Google 搜索</li></ul><h2 id="搜索文件名"><a href="#搜索文件名" class="headerlink" title="搜索文件名"></a>搜索文件名</h2><p>Raycast 支持搜索文件，默认情况下会匹配文件名和文件内容，这样效果会比较差，可能会搜索出来大量的不需要的文件。</p><p>在设置中可以将搜索命令的配置修改为只按名称搜索：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126951.webp"></p><p>在 Raycast 的操作界面出现时，按 <code>Command + ,</code> 可以打开设置界面。</p><h2 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h2><p>在 Mac 中可以三指向上滑来切换窗口，还是非常方便的，就是当活动窗口打开太多时，不太好找。在 Raycast 中使用 <code>Switch Windows</code> 命令也可以用来切换窗口：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126509.webp"></p><p>选中 <code>Switch Windows</code> ，点击回车会列出所有活动的窗口，可以进行选择打开。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126151.webp"></p><p>使用 Raycast 切换窗口有些时候还不如三指滑动便捷，但有两个好处：</p><ul><li>活动窗口多时会更方便</li><li>手指可以一直在键盘上</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>可以在 Store 中进行扩展的安装。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126319.webp"></p><p>在想要安装的扩展上点击右键就可以进行安装，现在 Store 的扩展程序非常丰富。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126932.webp"></p><h2 id="词典"><a href="#词典" class="headerlink" title="词典"></a>词典</h2><p>Raycast 默认的 Define word 使用的是 Mac 默认的词典，并且只能查单词，在 Store 中可以有很多选择，比如：Google 翻译、Deepcast 等，我选择的是 Easy Dictionary 。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126544.webp"></p><p>有多种翻译的对比，对于一些临时的翻译，不需要再单独打开一个翻译软件或者在浏览器中打开翻译网站。</p><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126234.webp"></p><p>设置别名有两个好处：</p><ul><li>可以更快速的定位</li><li>没有设置别名，选择命令后，需要回车才能进入到具体功能，设置了别名，输入别名后，输入空格就能直接操作</li></ul><h2 id="剪切板历史"><a href="#剪切板历史" class="headerlink" title="剪切板历史"></a>剪切板历史</h2><p>这个功能是一个惊喜，在 Mac 中想要使用剪切板历史的功能需要使用单独的软件，如：Paste、PasteNow 等。</p><p>而 Raycast 内置了这个功能， 我设置了别名 p ，当我敲入 <code>p+空格</code> 就会进入到剪切板界面。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126895.webp"></p><p>选择想要粘贴的记录，直接回车就可以粘贴到当前活动的 APP  中，也可以  <code>Command + k </code> 打开更多的操作，比如：复制、预览、保存等。</p><h2 id="Quicklinks"><a href="#Quicklinks" class="headerlink" title="Quicklinks"></a>Quicklinks</h2><p>Quicklinks 有两个用途：</p><ul><li>快速打开常用的站点</li><li>用于「指定某个搜索引擎搜索」或「指定在某个网站执行站内搜索」。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126709.webp"></p><p>1、 设置了别名  g</p><p>2、设置 了快捷键  command + G</p><p>3、设置链接地址，{Query} 为占位符</p><p>4、选择默认浏览器</p><h2 id="集成-Logseq"><a href="#集成-Logseq" class="headerlink" title="集成 Logseq"></a>集成 Logseq</h2><p>我是  Logseq  的 重度使用者，Raycast 的  store  中有  Logseq  的扩展，安装后可以在 Logseq 中直接写文本插入到  Logseq  的日志中。</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126454.webp"></p><p>输入  command +  空格后，内容就成功插入了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202308202126394.webp"></p><p>除了添加日志外，还能直接搜索  Logseq  中的内容。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Raycast 是一款 Mac 上的启动器工具，功能类似于 Mac 自带的 「焦点（Spotlight）」。关于启动器工具，如果你没使用过 Spotlight ，一定用过或听说过大名鼎鼎的  Alfred 。启动器工具可以让他们快速打开  Mac  应用，而 Raycast 不仅仅只是一个启动器。&lt;/p&gt;</summary>
    
    
    
    <category term="成长" scheme="http://fwhyy.com/categories/%E6%88%90%E9%95%BF/"/>
    
    
    <category term="工具" scheme="http://fwhyy.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="分享" scheme="http://fwhyy.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>B 端软件：怎样进行竞品分析</title>
    <link href="http://fwhyy.com/2023/08/b-end-software-how-to-conduct-competitor-analysis/"/>
    <id>http://fwhyy.com/2023/08/b-end-software-how-to-conduct-competitor-analysis/</id>
    <published>2023-08-14T01:01:35.000Z</published>
    <updated>2023-08-15T07:03:19.861Z</updated>
    
    <content type="html"><![CDATA[<p>不管是从零开始做一款软件，还是在现有的软件中进行功能迭代，都少不了去找一些类似的软件和功能进行研究，这个就叫竞品分析。</p><p>竞品分析（Competitive Analysis）来源于商业和市场营销领域。指对目标客户群体中提供相似产品或服务的竞争对手的系统分析与研究。</p><p>作为一个 B 端产品经理，在日常工作中也经常会需要进行竞品分析。下面谈谈我对竞品分析的一些理解。</p><span id="more"></span><h2 id="竞品分析的目的"><a href="#竞品分析的目的" class="headerlink" title="竞品分析的目的"></a>竞品分析的目的</h2><p>1、如果你新进入一个行业，竞品分析可以让你快速地了解行业知识和相关的业务。</p><p>2、如果为了设计一个既强大又易用的功能而绞尽脑汁，那竞品分析可以为你打开思路。</p><p>3、多看看外面的世界，对设计产品时的思维方式、思考角度很有帮助，避免闭门造车。</p><h2 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h2><p>在做竞品分析之前，一定要先搞清楚两个点。</p><p>1、所设计的软件或产品的目标用户是谁？</p><p>2、针对目标用户，哪些是核心功能？哪些是辅助功能？</p><p>例如，同样是低代码产品，是偏技术人员使用还是偏业务人员使用，不同的侧重在功能设计时操作逻辑可能完全不同。</p><p>所以，在做竞品分析的时候，不能只是将功能原封不动地抄过来，否则最终会迭代成四不像。我们分析出来的结果只能作为决策的参考信息，而不应当成为决策的决定性依据。</p><h2 id="竞品的类型"><a href="#竞品的类型" class="headerlink" title="竞品的类型"></a>竞品的类型</h2><p>1、直接竞品：指的就是主要功能和核心用户群都基本相同的产品。 </p><p>研究直接竞品，可以直观地帮助我们看到自家产品与对方产品在功能、业务流程、用户体验上的直接区别，直观地看到自己在哪些点做的好，在哪些点做的不好。这种直观的对比，可以更清晰地进行功能的改进和规划，少走弯路。</p><p>2、间接竞品：间接竞品有两类：</p><ul><li><p>一类是用户群相同，主要功能不同</p></li><li><p>一类是主要功能类似，但用户群不同</p></li></ul><blockquote><p>例如：你做的低代码产品是面向头部客户、采用私有化部署的方式进行业务落地。那么像明道云、氚云等就属于功能类似，用户群不同。因为他们是  SaaS  模式，面向中小企业。</p><p>像泛微也是面向头部客户、也可以采用私有化部署，但他的业务主要还是  OA  相关，这种就属于用户相同，主要功能不相同。</p></blockquote><p>间接竞品能帮助我们获取一些框架外的参考或灵感，有助于打破常规，出圈突破。</p><h2 id="竞品分析关键点"><a href="#竞品分析关键点" class="headerlink" title="竞品分析关键点"></a>竞品分析关键点</h2><p>1、确定目标</p><ul><li><p>搞清楚做竞品分析的目的是什么?</p></li><li><p>是为了调整产品策略还是优化产品的用户体验?</p></li><li><p>是为了产品整体功能的横向拓展还是某个特定功能的纵向深入优化？</p></li><li><p>最后的分析报告是给谁用？UI  设计？产品经理？工程师？还是老板？</p></li></ul><p>就跟阅读一样，带着这些目的和问题，会更高效。只有想清楚了这些问题，在选择竞品、搜集资料、对比分析时才会有的放矢。</p><p>2、结合第一点中的问题和思考，按照上面归纳的竞品的类型，合理选择竞品。</p><p>3、对比分析</p><ul><li>结合不同的竞品，整理功能列表，颗粒度尽可能小</li><li>将功能重合度高的进行优先级排序</li><li>如果这些重合度高的功能在我们自己的产品中还没有，那就可以重点分析了</li></ul><h2 id="分析过程中的方式方法"><a href="#分析过程中的方式方法" class="headerlink" title="分析过程中的方式方法"></a>分析过程中的方式方法</h2><p>1、当我们去试用一个竞品时，可以先把主流程完整地走一遍，在这个过程中，结合目标问题，总结出总体架构，每个产品都有自己的一条核心主线，掌握这条主线就很容易顺藤摸瓜去了解全部。</p><p>2、发现和自己产品不太一样的功能或者操作体验时，去思考竞品中的设计能解决什么问题？可以切中什么样的场景？</p><p>3、如果推导出了场景，先将自己假想成一个小白用户，遇到这样的场景时，期望能有什么样的功能来满足需求。然后想想如果自己是这个产品的负责人、设计者，会用什么方案来解决？跟竞品的设计会有什么样的差异？</p><p>4、自己的产品在业务落地时，肯定会遇到各种各样客户个性化要求，面对这些客户问题，在竞品中有没有更好的解决方案？</p><p>5、当然在过程中，也可以采用自己熟悉的工具加以辅助，例如：SWOT 分析法、用户体验五要素分析法、PEST 模型等等。</p><h2 id="收集信息的渠道"><a href="#收集信息的渠道" class="headerlink" title="收集信息的渠道"></a>收集信息的渠道</h2><p>了解更多的信息渠道，可以更全方位地了解到竞品的公司情况、产品功能等。</p><p>1、能直接试用的，最好的方式就是注册账号去进行试用。</p><p>2、部分功能对免费用户不开放时，可以去查看帮助文档、视频教程。</p><p>3、找到竞品产品的公众号、视频号、微博、官网案例等，去翻阅历史信息，可以了解竞品的发展历程、功能选择的取舍。</p><p>4、通过一些专业咨询网站，可以从侧面了解到竞品的信息，还可以了解行业信息。例如：智研咨询、艾瑞咨询、36氪企服点评等。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>竞品分析是一件耗费精力的事情，也是一项需要有耐心的工作。需要通过科学的分析方法，为产品设计提供实用的参考价值，这些价值最后会体现为良好的用户体验、完整的功能闭环和更好的营收。</p><p>至于竞品分析的结果怎么呈现，我觉得不太重要，重要的是中间分析的过程和结论。至于结果怎么呈现，看报告写给谁用？再来决定是采用表格、图表、还是文档的形式。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不管是从零开始做一款软件，还是在现有的软件中进行功能迭代，都少不了去找一些类似的软件和功能进行研究，这个就叫竞品分析。&lt;/p&gt;
&lt;p&gt;竞品分析（Competitive Analysis）来源于商业和市场营销领域。指对目标客户群体中提供相似产品或服务的竞争对手的系统分析与研究。&lt;/p&gt;
&lt;p&gt;作为一个 B 端产品经理，在日常工作中也经常会需要进行竞品分析。下面谈谈我对竞品分析的一些理解。&lt;/p&gt;</summary>
    
    
    
    <category term="产品" scheme="http://fwhyy.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="B 端软件" scheme="http://fwhyy.com/tags/b-%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="竞品分析" scheme="http://fwhyy.com/tags/%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>B 端软件：产品经理正确打开方式</title>
    <link href="http://fwhyy.com/2023/08/the-correct-opening-method-for-the-b-end-software-product-manager/"/>
    <id>http://fwhyy.com/2023/08/the-correct-opening-method-for-the-b-end-software-product-manager/</id>
    <published>2023-08-02T01:53:13.000Z</published>
    <updated>2023-08-15T06:58:26.124Z</updated>
    
    <content type="html"><![CDATA[<p>早些年 B 端软件流行瀑布式开发，以给客户提供解决方案为目的，没有成熟的产品，以定制化的方式进行交付，这里面有一个重要的岗位衔接着客户和开发，就是：需求分析师。</p><span id="more"></span><p>现在 B 端软件有很多的业务型产品软件、也有很多平台型产品软件，需求分析师变少了，产品经理变多了。</p><p>本文聊聊 B 端软件开发中的产品经理应该做些什么？</p><p>疫情前面试过不少产品经理，大部分提到 APP 、小程序的设计如数家珍，但涉及到 B 端软件就有点力不从心了，说明 B 端软件和 C 端有着很大的区别：</p><p>1、C 端软件服务于个人；B 端软件服务于企业、组织。</p><p>2、C  端软件更注重体验，希望简单易用，像微信，全国人民都在使用、抖音，三岁小孩都知道手指往上滑；B 端软件更注重效率，能给企业带来价值，降本增效。</p><p>3、C 端软件的使用角色相对单一，就是使用软件的个人；B 端软件有上层决策者、中层管理者、下层普通员工，会涉及到不同角色的工作台、权限、数据视图、操作流程等。</p><p>4、C 端软件要么花时间、要么花钱，尽管如此，每个人还是自愿花时间和金钱在上面；B 端软件能帮企业赚钱或省钱，但对普通员工来说，不一定是友好的，可能会改变工作习惯或增加工作量，需要自上而下，宣传、培训到最后熟练使用。</p><p>5、C 端软件通常凸显核心功能，其他辅助；B 端软件可能存在业务对使用人群有所偏重，但都很重要。</p><p>6、C 端软件使用简单，迁移成本低，导致有些笔记类软件担心用户流失，开放度小，限制导入导出数据；B 端软件从采购初期企业就有各种考虑，到最终上线使用，会经历一个相对长的时间、会涉及很多不同的业务部门，迁移成本高。所以很多战略项目即使不赚钱也要先把坑占着，后面才能做二期、三期。</p><p>正是因为有着很大的差别，所以在设计 B 端软件的时候，思考的方式、角度、侧重点都不一样，了解这些差别，能帮助产品经理更好地理解 B 端产品。</p><p>对 B 端产品经理来说，去设计一款 B 端软件，也是有章法可寻的，例如：拿开发具备低代码能力的  aPaaS  平台来说：</p><p>1、搞清楚开发的软件最终用户是业务人员还是技术人员？</p><p>2、搞清楚软件是私有化部署还是  SaaS  模式提供服务？还是需要同时支持两种？</p><p>3、了解  aPaaS  平台、低代码的概念、基本业务逻辑和实现原理，现在低代码已经烂大街了，资料非常地多。</p><p>4、做竞品分析，现在各种云产品都可以注册试用，即使有些付费功能不能用，也可以通过帮助文档了解功能详情和设计思路。做竞品分析的目的不是去抄功能，而是结合软件的最终目标，提升自己对业务的理解。</p><p>5、理清核心功能脉络，在企业级应用中，可以分四个部分：</p><ul><li>浏览器打开的界面中的各种交互和 UI 展现</li><li>审批流</li><li>业务流</li><li>集成扩展能力</li></ul><p>根据四个点可以去思考：</p><ul><li>界面的交互怎么样才能比较灵活？UI  风格怎样适应不同的行业？</li><li>审批中是自动流转还是手动选择下一节点和处理人？审批是独立挂载还是和数据模型集成在一起？</li><li>业务流的触发点有哪些？界面的交互和业务流怎么高效结合？</li><li>需要具备哪些扩展能力？</li></ul><p>6、上面提到了在 B 端软件中有高层、中层、底层不同的角色，不同的角色看到的工作台不一样、数据不一样、功能菜单、按钮不一样，需要设计既能满足业务又能操作简单的权限体系。</p><p>7、除了核心功能这条主线，还需要考虑一些辅助能力，比如：日志、监控、预警、配置等。</p><p>8、所有功能梳理完后，需要从中摘出一条最小可执行的单元，也就是  MVP，然后进行原型设计，包括：页面操作逻辑、交互规则。</p><p>9、拉着技术的前后端负责人，进行宣讲，听听意见，如果涉及到实现问题也能提前进行沟通。</p><p>10、方案确定后，配合 UI 进行高清图的设计，包括颜色、精细布局、字体、字号，整体效果出来后可以再进行一轮沟通和讨论。</p><p>上面是举例说明了产品经理做事的步骤，在实践这些步骤时，产品经理需要具备一些基本能力：</p><p>1、学习能力：从没接触过 B 端软件，到能熟练掌握概念、业务流程等需要有极强的学习和理解能力。</p><p>2、沟通能力：要能理解需求方的要求，也要和技术进行实现相关的沟通。</p><p>3、专业知识：如果是做垂直行业软件需要熟悉对应行业的业务、如果是通用性需要了解行业共性的知识、其他还包括专业工具的使用、软件开发流程等。</p><p>4、抽象思维：需求方在提需求时，往往会赠送一个解决方案，产品经理这时就不能照单全收，需要有自己的思考，挖出背后真实需求，并转化为软件中的一个功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;早些年 B 端软件流行瀑布式开发，以给客户提供解决方案为目的，没有成熟的产品，以定制化的方式进行交付，这里面有一个重要的岗位衔接着客户和开发，就是：需求分析师。&lt;/p&gt;</summary>
    
    
    
    <category term="产品" scheme="http://fwhyy.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="B 端软件" scheme="http://fwhyy.com/tags/b-%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="产品经理" scheme="http://fwhyy.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>怎样在  Github  中使用免密登录？</title>
    <link href="http://fwhyy.com/2023/07/how-to-use-password-free-login-in-github/"/>
    <id>http://fwhyy.com/2023/07/how-to-use-password-free-login-in-github/</id>
    <published>2023-07-23T01:49:05.000Z</published>
    <updated>2023-08-15T06:51:41.607Z</updated>
    
    <content type="html"><![CDATA[<p>我们在互联网上注册各种网站，密码经常会忘记，非常麻烦。以前还能各网站使用同一密码，虽然不太安全，但好记。现在各种网站的密码规则变强，还都不太一样，记密码就更难了。</p><p>如果有一种方式，能免密登录，就可以解决记不住密码的烦恼了。</p><span id="more"></span><h2 id="什么是免密登录？"><a href="#什么是免密登录？" class="headerlink" title="什么是免密登录？"></a>什么是免密登录？</h2><p>免密登录其实我们每天都在使用。</p><p>手机上按下指纹、或者刷个脸就能进入系统，类似这样的操作就是免密登录，只不过在  PC  使用浏览器访问网站时，大多都还是需要使用账号密码登录，为了安全性，可能还需要输入各种稀奇古怪的验证码。</p><p>现在有一种无需输入密码的解决方案：Passkey 。</p><h2 id="什么是-Passkey-？"><a href="#什么是-Passkey-？" class="headerlink" title="什么是 Passkey ？"></a>什么是 Passkey ？</h2><p>1、Passkey  不需要使用密码，而是使用密钥，接入了  Passkey 的网站会保存用户的公钥，登陆时用户使用私钥。</p><p>2、用户不需要知道私钥是什么，也不需要在登录时输入私钥，私钥通过「身份管理器」来提供。</p><p>2、「身份管理器」负责生成密钥，私钥自己保管，公钥提供给网站，「身份管理器」通常指指纹识别、人脸识别、或一些专用设备。</p><p>3、用户登录，网站会向「身份管理器」发请求，身份管理器验证身份（指纹、人脸识别）后允许使用私钥。</p><p>4、对用户来说就是按下指纹就登录网站了。</p><p>5、Passkey 的官网地址为：<a href="https://www.passkeys.io/">https://www.passkeys.io/</a> ，可以去进行体验。</p><h2 id="如何在-Github-中使用？"><a href="#如何在-Github-中使用？" class="headerlink" title="如何在  Github  中使用？"></a>如何在  Github  中使用？</h2><p>1、点击「头像」-&gt;「Feature preview」-&gt;「Passkeys」，将 Passkeys  功能开启，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655666.webp"></p><p>2、点击「头像」-&gt;「Settings」，进行设置：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655807.webp"></p><p>3、开启了  Passkeys  功能后，在「Password and authentication」设置中就可以看到  Passkeys  的设置，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655985.webp"></p><p>4、点击「Add a passkey」后会出现  Github  的登录确认：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655819.webp"></p><p>5、确认后点击「Add passkey」按钮：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221656679.webp"></p><p>6、因为我的使用场景是  Mac  上的  Chrome  浏览器，我选择的是「此设备」：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655038.webp"></p><p>7、根据向导继续，会弹出指纹校验的界面，在电脑上进行指纹识别就可以了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655571.webp"></p><p>8、指纹识别成功后，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655331.webp"></p><p>9、可以看到在  Passkeys  中成功加入了我的身份信息：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221655885.webp"></p><p>10、现在可以退出  Github  来试试新的登录方式了，点击使用  Passkey  方式，进行指纹识别就可以成功登录了：</p><p><img src="https://cdn.jsdelivr.net/gh/oec2003/hblog-images/img/202307221656776.webp"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望  Passkey  能被更多的网站接入，这样就可以解决记密码的烦恼了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们在互联网上注册各种网站，密码经常会忘记，非常麻烦。以前还能各网站使用同一密码，虽然不太安全，但好记。现在各种网站的密码规则变强，还都不太一样，记密码就更难了。&lt;/p&gt;
&lt;p&gt;如果有一种方式，能免密登录，就可以解决记不住密码的烦恼了。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="http://fwhyy.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Github" scheme="http://fwhyy.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>读《快速阅读术》</title>
    <link href="http://fwhyy.com/2023/07/reading-fast-reading-techniques/"/>
    <id>http://fwhyy.com/2023/07/reading-fast-reading-techniques/</id>
    <published>2023-07-19T00:28:16.000Z</published>
    <updated>2023-07-19T00:29:01.263Z</updated>
    
    <content type="html"><![CDATA[<p>1、我读书很慢，和这本书的作者一样，但这本书的作者现在能一天读一本，甚至是两本，让人很羡慕，所以我看了这本书，想学习下快速阅读的技巧。</p><span id="more"></span><p>2、可能是书名的魔力，读这本书是我有史以来读的最快的一本书，一天之内就读完了，这么快读完一本书，有没有收获呢？下面就来说说。</p><p>3、读书不是要把所有的内容都记住。当然，我们也记不住，有时不在状态，看到后一页，就忘了前一页；有时放慢速度，仔细阅读，也未必能记住。所以我们的目的是要吸收各种「知识片段」，积少成多，汇小溪以成江海。</p><p>4、每天在统一时间进行阅读，让读书成为一种生活习惯，哪怕只读  10  分钟。这对每个人来说都应该不成问题，10  分钟怎么着也能挤出来。建议早睡早起，早上脑子比较清醒，我现在就是把这个统一的时间放在了早上。</p><p>5、不是所有的书籍都适合快速阅读，比如故事性强、技术类的就不适合快速阅读。个人感觉观点类、成长类的比较适合。需要先找对书，再采用快速阅读的方法。</p><p>6、拿到书后，仔细阅读序言和目录，可以先找自己感兴趣的章节进行阅读，避免每次都只看个开头，就像背四级单词一样。阅读目录，可以把握全书的整体框架和论述的推进过程。</p><p>7、可以同时阅读很多本书籍，硅谷天使投资人纳瓦尔·拉威康特说过：“读书应该看情绪。人们每天的想法都不固定，情绪状态也在不断波动，因此，不要与情绪对抗，根据当时的状态，选择不同的书。这样做也能帮你保持定期阅读的习惯。”</p><p>8、书中的内容不是每个字都需要阅读的，可以合理利用小标题进行跳读，跳读并不会影响到对整本书的理解。还有像作者自述、案例部分也能跳读，当我们对核心观点了解和理解后，可以再回过头来看这些例子来进行巩固。</p><p>9、读的越快，理解会越深，与其拖拖拉拉读 10 天，不如全神贯注读 60 分钟。这一点我深有体会，有时一本书放久了，再拿起来阅读，几乎要重现开始了。</p><p>10、读书就像呼吸一样，读书时有输入，也要有输出，最简单的「呼」就是摘抄，然后对摘抄的内容进行一句话评论，记录当时场景下的感想，便于日后回忆。以写来读，还可以明确阅读角度，区分重要和非重要部分。</p><p>11、带着目的去读，准备问题、确定好关键词，现在电子书阅读可以很方便进行全文检索，使用关键词进行搜索，前后上下文快速浏览，以寻找答案为目的。就像去一个荒岛探宝，肯定不会在岛上每一片土地都去寻找，一定是根据线索，采用最便捷的方式。</p><p>12、本文就属于可以快速阅读的范畴，每一条都是独立的，之间没有很深的关联；不需要按照顺序，跳着看、挑着看、倒着看都可以。</p><p>13、有时「读书慢」这个标签会束缚我们，只要摘去这无意之中贴在自己身上的标签，就会发现一个能够随心所欲阅读的自己。也不用担心是否吸收、是否记住，因为读书这个过程以及看过的内容，会自然变成养分，滋养着我们。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、我读书很慢，和这本书的作者一样，但这本书的作者现在能一天读一本，甚至是两本，让人很羡慕，所以我看了这本书，想学习下快速阅读的技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="读书" scheme="http://fwhyy.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
    <category term="读书笔记" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="读书" scheme="http://fwhyy.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>B 端软件：信创、国产化知识梳理</title>
    <link href="http://fwhyy.com/2023/07/b-end-software-sorting-out-knowledge-on-innovation-and-localization/"/>
    <id>http://fwhyy.com/2023/07/b-end-software-sorting-out-knowledge-on-innovation-and-localization/</id>
    <published>2023-07-11T02:05:09.000Z</published>
    <updated>2023-07-12T02:07:41.216Z</updated>
    
    <content type="html"><![CDATA[<p>现在，做  ToB  软件，不管是跟客户沟通、内部会议、还是网上的资讯，经常会看到安可、信创、国产化这样的字眼。</p><span id="more"></span><p>下面通过模拟一些问题，来梳理国产化相关的知识。</p><p>1、什么是安可？</p><p>安可是「安全可靠」的简称。2019 年，我国启动了「安全可靠工程」，旨在加强信息和网络安全领域的能力。通过安全可靠工程，我国证明了具有安全可靠的关键系统、关键应用和关键软硬件产品的研发和集成能力，初步实现了对国外信息技术产品的全方位替代。</p><p>2、什么是信创？</p><p>信创是「信息技术应用创新产业」的简称，主要包括基础设施、基础软件、应用软件和信息安全等四大领域。</p><p>可以把信创理解为安可的升级版本。</p><p>2020 年央行成立金融信创生态实验室，第一批「金融信创解决方案」出现，被公认为信创产业的应用实践元年。</p><p>3、什么是  2+8+N  体系？</p><p>2020  年，我国提出了「2+8+N」的安全可控体系，其中：</p><ul><li>2：党、政府</li><li>8：金融、交通、电信、教育、电力、航空航天、石油和医疗八个行业</li><li>N：其他行业，例如：汽车、地产、物流等</li></ul><p>党和政府部门先行，随后逐步在涉及国计民生的 8 大行业实现安全可靠、自主可控，保障国家信息安全的工作全面展开，最后是其他行业。</p><p>4、为什么要发展信创产业？</p><p>通过自主研发和推广自主化、国产化的技术标准，从信息安全角度出发，达到自主可控，解决核心技术「卡脖子」的问题，不受制于外国技术的制约。</p><p>俄乌战争后，微软、西门子、甲骨文、SAP、Autodesk、ABB、GENESYS、 Red Hat、GitHub、Docker 等基础软件、开源社区、核心工业软件厂商相继停止俄罗斯境内服务，值得我们警醒。</p><p>所以，安可和信创对于提升我国IT产业核心竞争力、促进数字经济发展以及构建新基建都有着重要的价值。</p><p>5、信创产品有哪些发展阶段？</p><p>新创产业现在已经进入到了「规模化推广期」，从发展到现在可以分为四个阶段：</p><ul><li>萌芽期（1999-2005）：1999 年时任科技部部长徐冠华指出中国信息产业缺芯少魂（指的是芯片和操作系统），Xteam、蓝点、中科红旗、银河麒麟、中软 Linux 等公司陆续成立，产业进入萌芽期。</li><li>起步期（2006-2013）：2006 年，「核高基」政策推出，明确核心电子器件、高端通用芯片及基础软件产品方向，标志着信创产业的起步。</li><li>试点期（2014-2017）：2014 年中央网络安全与信息化领导小组成立，研究制定网络安全和信息化发展战略、宏观规划和重大政策，推动国家网络安全和信息化法治建设，不断增强安全保障能力。2016年《十三五国家信息化规划》出台，各地开始部署现代信息技术产业生态体系，信<br>创试点工作进入实质性阶段。</li><li>推广期（2018- 至今）：2018年-2019年，中兴/华为被美国制裁，美国开始加大对中国进出口限制，我国加速推进自主研发应用试点并扩大范围，信创产业招投标大幅增加，信创产业从「试点实践」进入「规模化推广阶段」。</li></ul><p>6、信创产业的范畴有哪些？</p><p>信创产业主要涉及基础硬件、基础软件、应用软件、信息安全四大板块。从软件关注的纬度来看，涉及：</p><ul><li>芯片：鲲鹏（ARM）、海光（x86）、龙芯（MIPS）、兆芯（x86）、飞腾（ARM）、申威（Alpha）等</li><li>操作系统：中标麒麟、银河麒麟、统信UOS、华为欧拉、中兴新支点、中科红旗等</li><li>数据库：达梦、易鲸捷、腾讯 TDSQL、华为 GaussDB、中兴通讯 GoldenDB、人大金仓KingBase 等</li><li>中间件：东方通、普元中间件、金蝶天燕、宝兰德中间件等</li><li>云服务：阿里云、华为云、QingCloud、DaoCloud  等</li></ul><p>7、.NET 符合信创要求吗？</p><p>很多人一听到 .NET 就会想到微软，一想到微软就会说能跨平台吗？能部署到  Liunx  吗？这种思想还停留在  10  几年前。</p><p>下面简单说下 .NET 的历程就可以清晰地知道现在的 .NET 并不是以前的 .NET Framework 。</p><ul><li>2002 年 2 月 23 日最早的 .NET Framework 1.0 发布</li><li>.NET Framework 的最后一个版本为 .NET Framework 4.8.1</li><li>2014  年  3  月，.NET 基金会成立</li><li>2016  年 6  月，.NET Core 1.0 项目正式发布，拥抱开源，实现跨平台，.NET Core 最新的为 .NET Core 3.1</li><li>2020  年  11  月，.NET 5 发布，实现了大融合，是一个重要的转折</li><li>2021  年  11  月，.NET 6 发布，LTS  版本，截止到  2024  年  11 月</li><li>2022  年  11  月，.NET 7 发布</li><li>目前 .NET 8  的预览版已经发布，预计今年 11  月发布正式版</li></ul><p>所以现在说 .NET 是指 .NET Core 和 .NET 5之后的版本，这些版本有下面一些特点，完全符合信创要求：</p><ul><li>采用最开放的 MIT 的开源协议</li><li>归属于中立的第三方组织 .NET 基金会掌控，不属于任何商业公司，除了微软，还有其他很多大公司，如  Google、AWS、三星 等都在里面</li><li>完美支持  x86 、ARM</li></ul><p>8、全部国产化才能项目落地吗？</p><p>未来肯定是这样的。</p><p>但以我的经验来看，目前重点还是芯片、操作系统、数据库，只要是涉及到信创，进行国产化部署，这三大件是一定需要使用国产化的，数据库大概率是达梦。</p><p>中间件，不同的企业有不同的要求，有的使用东方通、有的使用普元、有的强制要求必须适配、有的还能允许暂时使用开源中间件，如：redis、mongodb 等。</p><p>所以，做国产化适配，也可以分步骤：</p><ul><li>先进行程序的适配，能在不同的 CPU 架构中编译、运行</li><li>再进行数据库适配，可以优先支持达梦</li><li>最后进行中间件适配</li></ul><p>9、信创产业的未来规划是什么？</p><p>2022 年 9 月底，国资委下发了重要的国资发 79 号文件，全面指导并要求国央企落实信息化系统的信创国产化改造。其中，明确要求所有中央企业在 2022 年 11 月底前将安可替代总体方案报送国资委。</p><p>自 2023 年 1 月起，每季度末向国资委报送信创系统替换进度。最终要求 2027 年底前，实现所有中央企业的信息化系统安可信创替代。</p><ul><li><p>2022 年 11 月底，完成信创改造方案规划并报送国资委</p></li><li><p>2023 年 1 月起，每季度报送信息化系统信创改造的最新进度</p></li><li><p>2027 年底，全部国央企必须完成信息化系统的信创改造工作</p></li></ul><p>10、信创产业的发展趋势是什么？</p><p>目前我国信创产业的发展主要由政策主导，各省政府通过财政补贴促进供给端快速发展。</p><p>但随着 B 端和 C 端对国产安全的需求逐渐释放，信创发展的驱动力也将从政策主导转为需求主导。同时，随着信创渗透率进一步提高，信创产品也越来越接近 C 端消费者，生态圈进一步完善。</p><p>未来三年，随着信创产品市场化程度进一步推进，信创产业尤其是党政信创将迎来常态化发展，为下游区域经销商和服务商带来新机会。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在，做  ToB  软件，不管是跟客户沟通、内部会议、还是网上的资讯，经常会看到安可、信创、国产化这样的字眼。&lt;/p&gt;</summary>
    
    
    
    <category term="产品" scheme="http://fwhyy.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="国产化" scheme="http://fwhyy.com/tags/%E5%9B%BD%E4%BA%A7%E5%8C%96/"/>
    
    <category term="B 端软件" scheme="http://fwhyy.com/tags/b-%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
    <category term="信创" scheme="http://fwhyy.com/tags/%E4%BF%A1%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>B 端软件：常见知识梳理</title>
    <link href="http://fwhyy.com/2023/07/b-end-software-common-knowledge-sorting/"/>
    <id>http://fwhyy.com/2023/07/b-end-software-common-knowledge-sorting/</id>
    <published>2023-07-05T09:49:40.000Z</published>
    <updated>2023-07-05T09:50:48.492Z</updated>
    
    <content type="html"><![CDATA[<p>我一直从事企业级软件研发工作，也就是我们通常称之为 B 端软件。近年来，我的工作重心主要在研发低代码平台和 aPaaS 平台，这使我对 B 端软件有了更深入的理解。</p><span id="more"></span><p>和 B 端软件对应的就是我们熟悉的 C 端软件，我们手机中安装的那些  APP  就属于此类。那么，他们之间的主要区别是什么呢？</p><p>最初始的印象是  B  端面向企业，而 C  端则面向个人。</p><p>最近我看到一个有趣的结论：</p><ul><li>C 端主要解决终端消费者的问题，需要耗费时间和金钱。例如抖音、淘宝、京东等应用程序。</li><li>B 端主要致力于赚钱和增加价值，解决组织的增值需求，即所谓的 「降本增效」。例如 OA 可以提高办公效率，低代码平台则可以提高软件交付效率。</li></ul><p>当然这种解释并不完全准确，因为 C 端也有很多学习类和效率提升类的软件。但是这样的解释可以帮助我们更快地理解它们之间的不同。</p><p>在接触 B 端软件慢慢深入后，发现有很多的维度和角度去看待  B  端软件。</p><h2 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h2><p>1、SaaS（Software as a Service）：软件即服务。SaaS 是一种让用户通过网络访问软件的模式。在这种模式下，软件被部署在云端，用户无需安装就可以使用。SaaS 提供商负责软件的维护和更新。</p><p>2、PaaS（Platform as a Service）：平台即服务。PaaS 提供了一个云端平台，让开发者可以在这个平台上开发、运行和管理应用程序。开发者无须关心底层基础设施，可以专注于应用开发。</p><p>3、IaaS（Infrastructure as a Service）：基础设施即服务。IaaS 提供了虚拟化的计算、存储和网络资源。用户可以按需购买资源，而无须投资购买硬件设备。IaaS 提供商负责基础设施的管理和维护。例如：阿里云的  OSS  服务。</p><p>关于这三者，曾经在播客中听一个大佬是这么类比的：</p><blockquote><p>SaaS ：凡是给一个账号和密码的，就可以认为是一个  SaaS  服务，就像住酒店，选择房型和时长，支付相应的费用，我们是客户，酒店提供  SaaS  服务。</p><p>PaaS：你盖一栋楼，按照酒店的规格装修好，租给他人去经营管理，你就是提供  PaaS  服务。</p><p>IaaS：你搞定水电缴费、蔬菜生鲜的供货、床单被套送洗，这就是在为酒店提供  IaaS  服务。</p></blockquote><p>除此之外，还有一种模式叫 aPaaS（Application Platform as a Service）：应用平台即服务。aPaaS 是 PaaS 的一种特殊形式，它提供了一个集成的开发、运行和管理应用程序的环境。用户可以在 aPaaS 平台上快速构建、部署和扩展应用程序。Gartner 对其所下的定义是：</p><blockquote><p>这是基于PaaS（平台即服务）的一种解决方案，支持应用程序在云端的开发、部署和运行，提供软件开发中的基础工具给用户，包括数据对象、权限管理、用户界面等。</p></blockquote><p>要确定一家平台是不是 aPaaS，只需要看该平台是否拥有开发应用系统的能力，能不能快速开发出一套软件系统。</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>1、个性化：记得早期做企业项目，全个性化定制，使用传统的瀑布模式开发：</p><ul><li>需求分析和客户的业务方沟通完需求，整理成需求文档；</li><li>进行高保正  UI  图的设计和技术层面的设计，找客户确认；</li><li>确认后进行开发、测试上线；</li><li>进入后期运维阶段。</li></ul><p>个性化定制的产品大多都是解决客户特定场景问题，无法进行复用，每一个新的客户进行项目落地，又需要重头开始，导致成本高、收益低。</p><p>2、垂直化：想要让边际成本比较低，就需要从个性中找共性，所以就出现了泛微、蓝凌、致远的  OA  办公软件；金蝶、用友的财务、人力资源软件；明源的房地产软件等。</p><p>垂直化的商业软件对于中小公司可以开箱即用，对于大型企业客户来说也需要一定的个性化定制和改造才能上线使用。这里的定制和第一阶段的个性化定制就是两个层面的东西了。</p><p>3、多样化：随着  B  端软件越来越成熟，企业信息化建设越来越完善，B  端软件越来越丰富和多样，从只支持  PC  端访问到支持多终端使用；从支持单机部署到分布式、容器化、SaaS 模式；从解决某一个特定场景问题到多领域发展，例如：泛微现在不单单只是一个  OA  系统了。</p><p>4、集成化：功能虽然在不断增强和扩展，但不可能把所有事情都做了，需要的是将擅长的事情发挥到极致。要完成更大的业务目标就需要进行集成和连接，只要涉及到这些方面：</p><ul><li>获取第三方系统的数据进行展示。</li><li>业务上有需要和第三方系统进行数据传递和交互。</li><li>特定的功能需要对接专有软件或服务，例如：电子签章、Office  文档编辑、查询企业信息、地图显示等。</li></ul><p>现在的一些  aPaaS  平台基本都具备各种集成的能力。</p><p>5、平台化：制定标准和规范，让更多的  ISV（独立软件开发商）能在平台上进行软件开发，或者让一些软件厂商能将自己产品和平台进行适配，当入驻的软件越多，平台的能力就越强，最终打造一个软件的生态。例如钉钉和企业微信的应用中心。</p><h2 id="运维角度"><a href="#运维角度" class="headerlink" title="运维角度"></a>运维角度</h2><p>从运维部署的角度来看，B  端软件可以分为公有云、私有云、混合云三种方式。</p><p>1、公有云：公有云是指第三方服务提供商（如 AWS、阿里云、华为云等）提供的云计算资源和服务。在这种情况下，企业不需要购买和维护自己的硬件和基础设施，而是根据使用情况付费。公有云的优点包括快速部署、按需付费和弹性扩展。</p><p>2、私有云：私有云是指企业内部建立和维护的云计算环境。企业可以在自己的数据中心内部署私有云，或者托管在第三方数据中心。私有云的优点包括更高的安全性、更好的性能和更强的定制能力。</p><p>3、混合云：混合云是公有云和私有云的结合，企业可以根据业务需求和安全性要求灵活地在两者之间切换。这种部署方式兼具公有云的灵活性和私有云的安全性，使企业能够将敏感数据放在私有云中，而将其他可扩展的工作负载放在公有云中。</p><p>现在，国产化是一种趋势，符合信创要求也属于常规操作了，所以产品除了能在不同的云进行部署外，还需要能适配各类国产服务器、数据库、中间件。</p><h2 id="业务划分"><a href="#业务划分" class="headerlink" title="业务划分"></a>业务划分</h2><p>如果你刚刚接触  B  端软件，在各种会议沟通中，可能经常会听到一些业务名词，比如  OA、ERP  等，下面列举些常见的业务系统：</p><p>1、OA （ Office Automation）：办公自动化。它是指通过计算机技术和通讯技术来提高办公效率，实现办公信息化、网络化、智能化的一系列技术和管理手段。常见功能有：即时通讯、日程安排、文档管理、协同办公、流程管理、知识管理、任务管理等。例如：泛微、蓝凌、致远。</p><p>2、ERP（Enterprise Resource Planning）：企业资源规划。ERP 系统是一种集成的管理信息系统，它可以帮助企业管理生产、采购、销售、财务等业务流程。例如：SAP。</p><p>3、CRM（Customer Relationship Management）：客户关系管理。CRM 系统用于管理企业与客户之间的关系，包括客户信息管理、销售线索、线索跟进、市场营销等功能。例如：纷享销客、销售易。</p><p>4、MES（Manufacturing Execution System）：制造执行系统。MES系统主要用于生产过程的实时监控和调度，以提高生产效率和产品质量。</p><p>5、WMS （Warehouse Management System）：仓库管理系统。WMS系统是一种用于管理仓库物流和库存的软件系统，包括入库、出库、库存管理、库存盘点等方面的管理。</p><p>6、SRM（Supplier Relationship Management）：供应商关系管理。SRM系统帮助企业管理与供应商的关系，包括供应商信息管理、采购管理、供应链协同等功能。例如：企企通。</p><p>7、HCM（Human Capital Management）：人力资本管理。HCM系统用于管理企业的人力资源，包括招聘、培训、绩效评估等功能。</p><p>8、SCM（Supply Chain Management）：供应链管理。SCM系统用于管理企业的供应链活动，包括物流、库存管理、需求预测等功能。</p><p>9、PLM（Product Lifecycle Management）：产品生命周期管理。PLM系统用于管理产品从设计到退役的整个生命周期，包括产品设计、生产、维护等环节。</p><p>10、EAM（Enterprise Asset Management）：企业资产管理。EAM系统用于管理企业的固定资产，包括资产登记、维护、报废等功能。</p><p>11、BI（Business Intelligence）：商业智能。BI系统用于收集、分析和呈现企业数据，帮助企业进行决策支持和战略规划。例如：帆软、思迈特、海致等。</p><p>12、BPM（Business Process Management）：业务流程管理。BPM 系统用于对企业的业务流程进行管理和优化，以提高企业的运营效率和灵活性。</p><p>13、DMS（Document Management System）：文档管理系统。DMS 系统用于管理企业的电子文档，包括文档存储、检索、版本控制等功能。</p><p>14、MDM（Master Data Management）：主数据管理。MDM 系统用于管理企业的主数据，如客户、产品、供应商、物料等核心数据，确保数据的准确性和一致性。</p><p>15、ITSM（IT Service Management）：IT服务管理。ITSM 系统用于管理企业的IT服务，包括服务台、事件管理、配置管理等功能。</p><p>16、电子签约：电子签约系统是一种基于互联网技术的合同签署方式，它通过数字化、网络化的方式，使得双方可以在不同的地点、不同的时间完成合同签署，从而提高合同签署的效率和便捷性。例如：E 签宝、金格、法大大、契约锁等。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我一直从事企业级软件研发工作，也就是我们通常称之为 B 端软件。近年来，我的工作重心主要在研发低代码平台和 aPaaS 平台，这使我对 B 端软件有了更深入的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="产品" scheme="http://fwhyy.com/categories/%E4%BA%A7%E5%93%81/"/>
    
    
    <category term="B 端软件" scheme="http://fwhyy.com/tags/b-%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
